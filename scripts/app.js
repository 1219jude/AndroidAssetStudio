(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _pages = require('./pages');

var _studio = require('./studio');

var _imagelib = require('./imagelib');

window.pages = _pages.pages; /*
                              * Copyright 2016 Google Inc.
                              *
                              * Licensed under the Apache License, Version 2.0 (the "License");
                              * you may not use this file except in compliance with the License.
                              * You may obtain a copy of the License at
                              *
                              *     http://www.apache.org/licenses/LICENSE-2.0
                              *
                              * Unless required by applicable law or agreed to in writing, software
                              * distributed under the License is distributed on an "AS IS" BASIS,
                              * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                              * See the License for the specific language governing permissions and
                              * limitations under the License.
                              */

},{"./imagelib":5,"./pages":10,"./studio":24}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Analysis = undefined;

var _drawing = require('./drawing');

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise; /*
                                                                                           * Copyright 2016 Google Inc.
                                                                                           *
                                                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                           * you may not use this file except in compliance with the License.
                                                                                           * You may obtain a copy of the License at
                                                                                           *
                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                           *
                                                                                           * Unless required by applicable law or agreed to in writing, software
                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                           * See the License for the specific language governing permissions and
                                                                                           * limitations under the License.
                                                                                           */

var Analysis = exports.Analysis = {};

Analysis.TRIM_RECT_WORKER_JS = '\n    self.onmessage = function(event) {\n      var l = event.data.size.w, t = event.data.size.h, r = 0, b = 0;\n\n      var alpha;\n      for (var y = 0; y < event.data.size.h; y++) {\n        for (var x = 0; x < event.data.size.w; x++) {\n          alpha = event.data.imageData.data[\n              ((y * event.data.size.w + x) << 2) + 3];\n          if (alpha >= event.data.minAlpha) {\n            l = Math.min(x, l);\n            t = Math.min(y, t);\n            r = Math.max(x, r);\n            b = Math.max(y, b);\n          }\n        }\n      }\n\n      if (l > r) {\n        // no pixels, couldn\'t trim\n        postMessage({ x: 0, y: 0, w: event.data.size.w, h: event.data.size.h });\n        return;\n      }\n\n      postMessage({ x: l, y: t, w: r - l + 1, h: b - t + 1 });\n    };';

Analysis.MAX_TRIM_SRC_SIZE = 500;

Analysis.getTrimRect = function (ctx, size, minAlpha) {
  if (!ctx.canvas) {
    // Likely an image
    var src = ctx;
    ctx = _drawing.Drawing.context(size);
    _drawing.Drawing.copy(ctx, src, size);
  }

  var scale = 1;
  if (size.w > Analysis.MAX_TRIM_SRC_SIZE || size.h > Analysis.MAX_TRIM_SRC_SIZE) {
    scale = size.w > Analysis.MAX_TRIM_SRC_SIZE ? Analysis.MAX_TRIM_SRC_SIZE / size.w : Analysis.MAX_TRIM_SRC_SIZE / size.h;
    var scaledSize = { w: size.w * scale, h: size.h * scale };
    var tmpCtx = _drawing.Drawing.context(scaledSize);
    tmpCtx.drawImage(ctx.canvas, 0, 0, size.w, size.h, 0, 0, scaledSize.w, scaledSize.h);
    ctx = tmpCtx;
    size = scaledSize;
  }

  var worker = void 0;
  var promise = new _Promise(function (resolve, reject) {
    if (minAlpha == 0) {
      resolve({ x: 0, y: 0, w: size.w, h: size.h });
    }

    minAlpha = minAlpha || 1;

    worker = runWorkerJs_(Analysis.TRIM_RECT_WORKER_JS, {
      imageData: ctx.getImageData(0, 0, size.w, size.h),
      size: size,
      minAlpha: minAlpha
    }, function (resultingRect) {
      resultingRect.x /= scale;
      resultingRect.y /= scale;
      resultingRect.w /= scale;
      resultingRect.h /= scale;
      resolve(resultingRect);
      worker = null;
    });
  });

  Object.defineProperty(promise, 'worker', {
    get: function get() {
      return worker;
    }
  });

  return promise;
};

Analysis.getCenterOfMass = function (ctx, size, minAlpha) {
  return new _Promise(function (resolve, reject) {
    if (!ctx.canvas) {
      // Likely an image
      var src = ctx;
      ctx = _drawing.Drawing.context(size);
      _drawing.Drawing.copy(ctx, src, size);
    }

    if (minAlpha == 0) {
      resolve({ x: size.w / 2, y: size.h / 2 });
    }

    minAlpha = minAlpha || 1;

    var l = size.w,
        t = size.h,
        r = 0,
        b = 0;
    var imageData = ctx.getImageData(0, 0, size.w, size.h);

    var sumX = 0;
    var sumY = 0;
    var n = 0; // number of pixels > minAlpha
    var alpha;
    for (var y = 0; y < size.h; y++) {
      for (var x = 0; x < size.w; x++) {
        alpha = imageData.data[(y * size.w + x << 2) + 3];
        if (alpha >= minAlpha) {
          sumX += x;
          sumY += y;
          ++n;
        }
      }
    }

    if (n <= 0) {
      // no pixels > minAlpha, just use center
      resolve({ x: size.w / 2, h: size.h / 2 });
    }

    resolve({ x: Math.round(sumX / n), y: Math.round(sumY / n) });
  });
};

/**
 * Helper method for running inline Web Workers, if the browser can support
 * them. If the browser doesn't support inline Web Workers, run the script
 * on the main thread, with this function body's scope, using eval. Browsers
 * must provide BlobBuilder, URL.createObjectURL, and Worker support to use
 * inline Web Workers. Most features such as importScripts() are not
 * currently supported, so this only works for basic workers.
 * @param {String} js The inline Web Worker Javascript code to run. This code
 *     must use 'self' and not 'this' as the global context variable.
 * @param {Object} params The parameters object to pass to the worker.
 *     Equivalent to calling Worker.postMessage(params);
 * @param {Function} callback The callback to run when the worker calls
 *     postMessage. Equivalent to adding a 'message' event listener on a
 *     Worker object and running callback(event.data);
 */
function runWorkerJs_(js, params, callback) {
  var URL = window.URL || window.webkitURL || window.mozURL;
  var Worker = window.Worker;

  if (URL && Worker && hasBlobConstructor_()) {
    // The Blob constructor, Worker, and window.URL.createObjectURL are all available,
    // so we can use inline workers.
    var bb = new Blob([js], { type: 'text/javascript' });
    var worker = new Worker(URL.createObjectURL(bb));
    worker.onmessage = function (event) {
      callback(event.data);
    };
    worker.postMessage(params);
    return worker;
  } else {
    // We can't use inline workers, so run the worker JS on the main thread.
    (function () {
      var __DUMMY_OBJECT__ = {};
      // Proxy to Worker.onmessage
      var postMessage = function postMessage(result) {
        callback(result);
      };
      // Bind the worker to this dummy object. The worker will run
      // in this scope.
      eval('var self=__DUMMY_OBJECT__;\n' + js);
      // Proxy to Worker.postMessage
      __DUMMY_OBJECT__.onmessage({
        data: params
      });
    })();

    // Return a dummy Worker.
    return {
      terminate: function terminate() {}
    };
  }
};

// https://github.com/gildas-lormeau/zip.js/issues/17#issuecomment-8513258
// thanks Eric!
function hasBlobConstructor_() {
  try {
    return !!new Blob();
  } catch (e) {
    return false;
  }
}

},{"./drawing":3,"es6-promise":27}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Drawing = undefined;

var _tinycolor = require('tinycolor2');

var _tinycolor2 = _interopRequireDefault(_tinycolor);

var _effects = require('./effects');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Drawing = exports.Drawing = {};

Drawing.context = function (size) {
  var canvas = document.createElement('canvas');
  canvas.width = size.w;
  canvas.height = size.h;
  canvas.style.setProperty('image-rendering', 'optimizeQuality', null);
  return canvas.getContext('2d');
};

Drawing.copy = function (dstCtx, src, size) {
  dstCtx.drawImage(src.canvas || src, 0, 0, size.w, size.h);
};

Drawing.clear = function (ctx, size) {
  ctx.clearRect(0, 0, size.w, size.h);
};

Drawing.drawCenterInside = function (dstCtx, src, dstRect, srcRect) {
  if (srcRect.w / srcRect.h > dstRect.w / dstRect.h) {
    var h = srcRect.h * dstRect.w / srcRect.w;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x, dstRect.y + (dstRect.h - h) / 2, dstRect.w, h);
  } else {
    var w = srcRect.w * dstRect.h / srcRect.h;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x + (dstRect.w - w) / 2, dstRect.y, w, dstRect.h);
  }
};

Drawing.drawCenterCrop = function (dstCtx, src, dstRect, srcRect) {
  if (srcRect.w / srcRect.h > dstRect.w / dstRect.h) {
    var w = srcRect.h * dstRect.w / dstRect.h;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x + (srcRect.w - w) / 2, srcRect.y, w, srcRect.h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
  } else {
    var h = srcRect.w * dstRect.h / dstRect.w;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x, srcRect.y + (srcRect.h - h) / 2, srcRect.w, h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
  }
};

Drawing.drawImageScaled = function (dstCtx, src, sx, sy, sw, sh, dx, dy, dw, dh) {
  src = src.canvas || src;

  // algorithm: when scaling down, downsample by at most a factor of 2 per iteration
  // to avoid poor browser downsampling
  while (dw < sw / 2 || dh < sh / 2) {
    var tmpDw = Math.ceil(Math.max(dw, sw / 2));
    var tmpDh = Math.ceil(Math.max(dh, sh / 2));
    var tmpCtx = Drawing.context({ w: tmpDw, h: tmpDh });

    tmpCtx.clearRect(0, 0, tmpDw, tmpDh);
    tmpCtx.drawImage(src, sx, sy, sw, sh, 0, 0, tmpDw, tmpDh);

    src = tmpCtx.canvas;
    sx = sy = 0;
    sw = tmpDw;
    sh = tmpDh;
  }

  dstCtx.drawImage(src, sx, sy, sw, sh, dx, dy, dw, dh);
};

Drawing.drawLayers = function (dstCtx, size, layerTree) {
  drawLayer_(dstCtx, layerTree);

  function drawLayer_(dstCtx, layer) {
    var layerCtx = Drawing.context(size);

    if (layer.children) {
      drawGroup_(layerCtx, layer);
    } else if (layer.draw) {
      layer.draw(layerCtx);
    }

    if (layer.effects) {
      // apply effects in a new buffer
      var effectsCtx = Drawing.context(size);
      _effects.Effects.fx(layer.effects, effectsCtx, layerCtx, size);
      layerCtx = effectsCtx;
    }

    Drawing.copy(dstCtx, layerCtx, size);
  }

  function drawGroup_(dstCtx, group) {
    var dstCtxStack = [dstCtx];

    group.children.filter(function (layer) {
      return !!layer;
    }).forEach(function (layer) {
      drawLayer_(dstCtxStack[dstCtxStack.length - 1], layer);
      if (layer.mask) {
        // draw future layers into a separate buffer (later gets masked)
        var maskedContentCtx = Drawing.context(size);
        dstCtxStack.push(maskedContentCtx);
      }
    });

    while (dstCtxStack.length > 1) {
      var targetCtx = dstCtxStack[dstCtxStack.length - 2];
      var contentCtx = dstCtxStack[dstCtxStack.length - 1];
      targetCtx.save();
      targetCtx.globalCompositeOperation = 'source-atop';
      Drawing.copy(targetCtx, contentCtx, size);
      targetCtx.restore();
      dstCtxStack.pop();
    }
  }
};

},{"./effects":4,"tinycolor2":29}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Effects = undefined;

var _drawing = require('./drawing');

var OUTER_EFFECTS = new Set(['outer-shadow', 'cast-shadow']); /*
                                                               * Copyright 2016 Google Inc.
                                                               *
                                                               * Licensed under the Apache License, Version 2.0 (the "License");
                                                               * you may not use this file except in compliance with the License.
                                                               * You may obtain a copy of the License at
                                                               *
                                                               *     http://www.apache.org/licenses/LICENSE-2.0
                                                               *
                                                               * Unless required by applicable law or agreed to in writing, software
                                                               * distributed under the License is distributed on an "AS IS" BASIS,
                                                               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                               * See the License for the specific language governing permissions and
                                                               * limitations under the License.
                                                               */

var INNER_EFFECTS = new Set(['inner-shadow', 'score']);
var FILL_EFFECTS = new Set(['fill-color', 'fill-lineargradient', 'fill-radialgradient']);

var Effects = exports.Effects = {
  fx: function fx(effects, dstCtx, src, size) {
    effects = effects || [];

    var outerEffects = effects.filter(function (e) {
      return OUTER_EFFECTS.has(e.effect);
    });
    var innerEffects = effects.filter(function (e) {
      return INNER_EFFECTS.has(e.effect);
    });
    var fillEffects = effects.filter(function (e) {
      return FILL_EFFECTS.has(e.effect);
    });

    var tmpCtx = void 0,
        bufferCtx = void 0;

    // First render outer effects
    var padLeft = void 0,
        padRight = void 0,
        padBottom = void 0,
        padTop = void 0;
    padLeft = padRight = padBottom = padTop = outerEffects.reduce(function (r, e) {
      return Math.max(r, e.blur || 0);
    }, 0);

    var paddedSize = {
      w: size.w + padLeft + padRight,
      h: size.h + padTop + padBottom
    };

    tmpCtx = _drawing.Drawing.context(paddedSize);

    outerEffects.forEach(function (effect) {
      switch (effect.effect) {
        case 'cast-shadow':
          tmpCtx.clearRect(0, 0, paddedSize.w, paddedSize.h);
          tmpCtx.drawImage(src.canvas || src, padLeft, padTop);
          renderCastShadow_(tmpCtx, paddedSize.w, paddedSize.h);
          dstCtx.drawImage(tmpCtx.canvas, padLeft, padTop, size.w, size.h, 0, 0, size.w, size.h);
          break;

        case 'outer-shadow':
          var tColor = tinycolor(effect.color || '#000');
          var alpha = tColor.getAlpha();
          tColor.setAlpha(1);

          if (supportsCanvasFilters_()) {
            tmpCtx.save();
            tmpCtx.clearRect(0, 0, paddedSize.w, paddedSize.h);
            tmpCtx.filter = 'blur(' + (effect.blur || 0) + 'px)';
            tmpCtx.drawImage(src.canvas || src, padLeft, padTop);
            tmpCtx.globalCompositeOperation = 'source-atop';
            tmpCtx.fillStyle = tColor.toRgbString();
            tmpCtx.fillRect(0, 0, paddedSize.w, paddedSize.h);
            tmpCtx.restore();

            dstCtx.save();
            dstCtx.translate(effect.translateX || 0, effect.translateY || 0);
            dstCtx.globalAlpha = alpha;
            dstCtx.drawImage(tmpCtx.canvas, padLeft, padTop, size.w, size.h, 0, 0, size.w, size.h);
            dstCtx.restore();
          } else {
            dstCtx.save();
            dstCtx.globalAlpha = alpha;
            dstCtx.shadowOffsetX = paddedSize.w;
            dstCtx.shadowOffsetY = 0;
            dstCtx.shadowColor = tColor.toRgbString();
            dstCtx.shadowBlur = canvasShadowBlurForRadius_(effect.blur || 0);
            dstCtx.drawImage(src.canvas || src, (effect.translateX || 0) - paddedSize.w, effect.translateY || 0);
            dstCtx.restore();
          }
          break;
      }
    });

    // Next, render the source, fill effects (first one), and inner effects
    // in a buffer (bufferCtx)
    bufferCtx = _drawing.Drawing.context(size);
    tmpCtx = _drawing.Drawing.context(size);
    tmpCtx.drawImage(src.canvas || src, 0, 0);
    tmpCtx.globalCompositeOperation = 'source-atop';

    // Fill effects
    var fillOpacity = 1.0;
    if (fillEffects.length) {
      var effect = fillEffects[0];
      fillOpacity = 'opacity' in effect ? effect.opacity : 1;

      tmpCtx.save();

      switch (effect.effect) {
        case 'fill-color':
          {
            tmpCtx.fillStyle = effect.color;
            break;
          }

        case 'fill-lineargradient':
          {
            var _ret = function () {
              var gradient = tmpCtx.createLinearGradient(effect.fromX, effect.fromY, effect.toX, effect.toY);
              effect.colors.forEach(function (_ref) {
                var offset = _ref.offset,
                    color = _ref.color;
                return gradient.addColorStop(offset, color);
              });
              tmpCtx.fillStyle = gradient;
              return 'break';
            }();

            if (_ret === 'break') break;
          }

        case 'fill-radialgradient':
          {
            var _ret2 = function () {
              var gradient = tmpCtx.createRadialGradient(effect.centerX, effect.centerY, 0, effect.centerX, effect.centerY, effect.radius);
              effect.colors.forEach(function (_ref2) {
                var offset = _ref2.offset,
                    color = _ref2.color;
                return gradient.addColorStop(offset, color);
              });
              tmpCtx.fillStyle = gradient;
              return 'break';
            }();

            if (_ret2 === 'break') break;
          }
      }

      tmpCtx.fillRect(0, 0, size.w, size.h);
      tmpCtx.restore();
    }

    bufferCtx.save();
    bufferCtx.globalAlpha = fillOpacity;
    bufferCtx.drawImage(tmpCtx.canvas, 0, 0);
    bufferCtx.restore();

    // Render inner effects
    padLeft = padTop = padRight = padBottom = 0;
    innerEffects.forEach(function (effect) {
      padLeft = Math.max(padLeft, (effect.blur || 0) + Math.max(0, effect.translateX || 0));
      padTop = Math.max(padTop, (effect.blur || 0) + Math.max(0, effect.translateY || 0));
      padRight = Math.max(padRight, (effect.blur || 0) + Math.max(0, -(effect.translateX || 0)));
      padBottom = Math.max(padBottom, (effect.blur || 0) + Math.max(0, -(effect.translateY || 0)));
    });

    paddedSize = {
      w: size.w + padLeft + padRight,
      h: size.h + padTop + padBottom
    };

    tmpCtx = _drawing.Drawing.context(paddedSize);

    innerEffects.forEach(function (effect) {
      switch (effect.effect) {
        case 'inner-shadow':
          tmpCtx.save();
          tmpCtx.clearRect(0, 0, paddedSize.w, paddedSize.h);
          if (supportsCanvasFilters_()) {
            tmpCtx.filter = 'blur(' + (effect.blur || 0) + 'px)';
            tmpCtx.drawImage(bufferCtx.canvas, padLeft + (effect.translateX || 0), padTop + (effect.translateY || 0));
          } else {
            tmpCtx.shadowOffsetX = paddedSize.w;
            tmpCtx.shadowOffsetY = 0;
            tmpCtx.shadowColor = '#000'; // color doesn't matter
            tmpCtx.shadowBlur = canvasShadowBlurForRadius_(effect.blur || 0);
            tmpCtx.drawImage(bufferCtx.canvas, padLeft + (effect.translateX || 0) - paddedSize.w, padTop + (effect.translateY || 0));
          }
          tmpCtx.globalCompositeOperation = 'source-out';
          tmpCtx.fillStyle = effect.color;
          tmpCtx.fillRect(0, 0, paddedSize.w, paddedSize.h);
          tmpCtx.restore();

          bufferCtx.save();
          bufferCtx.globalCompositeOperation = 'source-atop';
          bufferCtx.drawImage(tmpCtx.canvas, -padLeft, -padTop);
          bufferCtx.restore();
          break;
      }
    });

    // Draw buffer (source, fill, inner effects) on top of outer effects
    dstCtx.drawImage(bufferCtx.canvas, 0, 0);
  }
};

function renderCastShadow_(ctx, w, h) {
  var tmpCtx = _drawing.Drawing.context({ w: w, h: h });
  // render the cast shadow
  for (var o = 1; o < Math.max(w, h); o++) {
    tmpCtx.drawImage(ctx.canvas, o, o);
  }
  tmpCtx.globalCompositeOperation = 'source-in';
  tmpCtx.fillStyle = '#000';
  tmpCtx.fillRect(0, 0, w, h);
  var gradient = tmpCtx.createLinearGradient(0, 0, w, h);
  gradient.addColorStop(0, 'rgba(0, 0, 0, .2)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  tmpCtx.fillStyle = gradient;
  tmpCtx.fillRect(0, 0, w, h);
  ctx.clearRect(0, 0, w, h);
  ctx.drawImage(tmpCtx.canvas, 0, 0);
}

function supportsCanvasFilters_() {
  if (!supportsCanvasFilters_.hasOwnProperty('cached')) {
    supportsCanvasFilters_.cached = document.createElement('canvas').getContext('2d').filter == 'none';
  }

  return supportsCanvasFilters_.cached;
}

// determined empirically: http://codepen.io/anon/pen/ggLOqJ
var BLUR_MULTIPLIER = [{ re: /chrome/i, mult: 2.7 }, { re: /safari/i, mult: 1.8 }, { re: /firefox/i, mult: 1.7 }, { re: /./i, mult: 1.7 }].find(function (x) {
  return x.re.test(navigator.userAgent);
}).mult;

function canvasShadowBlurForRadius_(radius) {
  return radius * BLUR_MULTIPLIER;
}

},{"./drawing":3}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.imagelib = undefined;

var _effects = require('./effects');

var _drawing = require('./drawing');

var _analysis = require('./analysis');

var imagelib = exports.imagelib = {
  Drawing: _drawing.Drawing,
  Effects: _effects.Effects,
  Analysis: _analysis.Analysis
}; /*
    * Copyright 2016 Google Inc.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

},{"./analysis":2,"./drawing":3,"./effects":4}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActionBarIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _basegenerator = require('./basegenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 0, y: 0, w: 24, h: 24 };

var GRID_OVERLAY_SVG = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n        <g fill="none" fill-rule="evenodd">\n            <rect vector-effect="non-scaling-stroke" x="4" y="2" width="16" height="20" rx="2"/>\n            <rect vector-effect="non-scaling-stroke" x="3" y="3" width="18" height="18" rx="2"/>\n            <rect vector-effect="non-scaling-stroke" x="2" y="4" width="20" height="16" rx="2"/>\n            <circle vector-effect="non-scaling-stroke" cx="12" cy="12" r="5"/>\n            <circle vector-effect="non-scaling-stroke" cx="12" cy="12" r="10"/>\n            <path vector-effect="non-scaling-stroke" d="M0 24L24 0M0 0l24 24m-12 0V0M8 0v24m8-24v24m8-12H0m0 4h24M0 8h24"/>\n        </g>\n    </svg>';

var ActionBarIconGenerator = exports.ActionBarIconGenerator = function (_BaseGenerator) {
  _inherits(ActionBarIconGenerator, _BaseGenerator);

  function ActionBarIconGenerator() {
    _classCallCheck(this, ActionBarIconGenerator);

    return _possibleConstructorReturn(this, (ActionBarIconGenerator.__proto__ || Object.getPrototypeOf(ActionBarIconGenerator)).apply(this, arguments));
  }

  _createClass(ActionBarIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(ActionBarIconGenerator.prototype.__proto__ || Object.getPrototypeOf(ActionBarIconGenerator.prototype), 'setupForm', this).call(this);

      var nameField = void 0,
          customColorField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 128, h: 128 },
          clipartNoTrimPadding: true,
          defaultValueClipart: 'add_circle',
          dropTarget: document.body
        }), nameField = new _studio.studio.TextField('name', {
          newGroup: true,
          title: 'Name',
          helpText: 'Used when generating ZIP files.',
          defaultValue: 'ic_action_example'
        }), new _studio.studio.EnumField('theme', {
          title: 'Theme',
          buttons: true,
          options: [{ id: 'light', title: 'Light' }, { id: 'dark', title: 'Dark' }, { id: 'custom', title: 'Custom' }],
          defaultValue: 'light'
        }), customColorField = new _studio.studio.ColorField('color', {
          title: 'Color',
          defaultValue: 'rgba(33, 150, 243, .6)',
          alpha: true
        })]
      });
      this.form.onChange(function (field) {
        var values = _this2.form.getValues();
        if ((!field || field.id_ == 'source') && values.source && values.source.name) {
          var name = 'ic_action_' + _studio.studio.Util.sanitizeResourceName(values.source.name);
          if (name != nameField.getValue()) {
            nameField.setValue(name);
          }
        }

        $('.outputs-panel').attr('data-theme', values.theme);
        customColorField.setEnabled(values.theme == 'custom');
        _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, _studio.studio.Util.mult(TARGET_RECT, mult), { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        var color = values.color;
        if (values.theme == 'light') {
          color = tinycolor('rgba(0, 0, 0, .54)');
        } else if (values.theme == 'dark') {
          color = tinycolor('#fff');
        }

        var alpha = color.getAlpha();
        color.setAlpha(1);

        _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: color.toRgbString(), opacity: alpha }], outCtx, tmpCtx, iconSize);

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }, {
    key: 'gridOverlaySvg',
    get: function get() {
      return GRID_OVERLAY_SVG;
    }
  }]);

  return ActionBarIconGenerator;
}(_basegenerator.BaseGenerator);

},{"../imagelib":5,"../studio":24,"./basegenerator":8}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AppShortcutIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _basegenerator = require('./basegenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2017 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 48, h: 48 };
var TARGET_RECT = { x: 12, y: 12, w: 24, h: 24 };

var GRID_OVERLAY_SVG = '<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">\n        <g fill="none" fill-rule="evenodd">\n            <rect vector-effect="non-scaling-stroke" x="12" y="12" width="24" height="24"/>\n        </g>\n    </svg>';

var AppShortcutIconGenerator = exports.AppShortcutIconGenerator = function (_BaseGenerator) {
  _inherits(AppShortcutIconGenerator, _BaseGenerator);

  function AppShortcutIconGenerator() {
    _classCallCheck(this, AppShortcutIconGenerator);

    return _possibleConstructorReturn(this, (AppShortcutIconGenerator.__proto__ || Object.getPrototypeOf(AppShortcutIconGenerator)).apply(this, arguments));
  }

  _createClass(AppShortcutIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(AppShortcutIconGenerator.prototype.__proto__ || Object.getPrototypeOf(AppShortcutIconGenerator.prototype), 'setupForm', this).call(this);

      var nameField = void 0,
          customColorField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 128, h: 128 },
          clipartNoTrimPadding: true,
          defaultValueClipart: 'search',
          dropTarget: document.body
        }), nameField = new _studio.studio.TextField('name', {
          newGroup: true,
          title: 'Name',
          helpText: 'Used when generating ZIP files.',
          defaultValue: 'ic_shortcut_example'
        }), new _studio.studio.ColorField('foreColor', {
          title: 'Color',
          defaultValue: '#448aff'
        }), new _studio.studio.ColorField('backColor', {
          title: 'Background color',
          defaultValue: '#f5f5f5'
        })]
      });
      this.form.onChange(function (field) {
        var values = _this2.form.getValues();
        if ((!field || field.id_ == 'source') && values.source && values.source.name) {
          var name = 'ic_shortcut_' + _studio.studio.Util.sanitizeResourceName(values.source.name);
          if (name != nameField.getValue()) {
            nameField.setValue(name);
          }
        }

        $('.outputs-panel').attr('data-theme', values.theme);
        _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        outCtx.save();
        outCtx.beginPath();
        outCtx.arc(24 * mult, 24 * mult, 22 * mult, 0, Math.PI * 2);
        outCtx.closePath();
        values.backColor.setAlpha(1);
        outCtx.fillStyle = values.backColor.toRgbString();
        outCtx.fill();
        outCtx.restore();

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, _studio.studio.Util.mult(TARGET_RECT, mult), { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        values.foreColor.setAlpha(1);
        _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: values.foreColor.toRgbString() }], outCtx, tmpCtx, iconSize);

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }, {
    key: 'gridOverlaySvg',
    get: function get() {
      return GRID_OVERLAY_SVG;
    }
  }]);

  return AppShortcutIconGenerator;
}(_basegenerator.BaseGenerator);

},{"../imagelib":5,"../studio":24,"./basegenerator":8}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _studio = require('../studio');

var _imagelib = require('../imagelib');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DENSITIES = new Set(['xxxhdpi', 'xxhdpi', 'xhdpi', 'hdpi', 'mdpi']);
var REGENERATE_DEBOUNCE_TIME = 200;

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 0, y: 0, w: 24, h: 24 };

var BaseGenerator = exports.BaseGenerator = function () {
  function BaseGenerator() {
    var _this = this;

    _classCallCheck(this, BaseGenerator);

    this.regenerateDebounced_ = _studio.studio.Util.debounce(REGENERATE_DEBOUNCE_TIME, function () {
      return _this.regenerate();
    });

    this.setupZipper();
    this.setupOutputUi();
    this.setupOutputSlots();
    this.setupForm();
    _studio.studio.Hash.bindFormToDocumentHash(this.form);
    setTimeout(function () {
      return _this.regenerate();
    }, 0);
  }

  _createClass(BaseGenerator, [{
    key: 'setupZipper',
    value: function setupZipper() {
      this.zipper = _studio.studio.Zip.createDownloadifyZipButton($('#download-zip-button'));
    }
  }, {
    key: 'setupOutputUi',
    value: function setupOutputUi() {
      // grid toggle
      if (this.gridOverlaySvg) {
        var defaultChecked = 'assetStudioShowGrid' in localStorage ? localStorage.assetStudioShowGrid === 'true' : true;
        $('#grid-toggle').prop('checked', defaultChecked);
        $('.outputs-panel').toggleClass('show-grid', defaultChecked);

        $('#grid-toggle').click(function (ev) {
          var checked = $(ev.currentTarget).is(':checked');
          localStorage.assetStudioShowGrid = String(checked);
          $('.outputs-panel').toggleClass('show-grid', checked);
        });
      } else {
        $('#grid-toggle-container').hide();
      }

      // additional slots toggle
      $('.outputs-additional-toggle').click(function () {
        return $('.outputs-panel').toggleClass('is-showing-all');
      });
    }
  }, {
    key: 'setupOutputSlots',
    value: function setupOutputSlots() {
      var _this2 = this;

      this.densities.forEach(function (density) {
        _this2.createImageOutputSlot_({
          container: density == 'xxxhdpi' ? $('.outputs-main') : $('.outputs-additional'),
          id: density,
          label: density
        });
      });
    }
  }, {
    key: 'createImageOutputSlot_',
    value: function createImageOutputSlot_(params) {
      var $imageContainer = $('<div>').addClass('outputs-image-container').append($('<img>').addClass('outputs-image').attr('data-id', 'out-icon-' + params.id));

      if (this.gridOverlaySvg) {
        $('<div>').addClass('outputs-image-overlay').html(this.gridOverlaySvg).appendTo($imageContainer);
      }

      var $block = $('<div>').addClass('outputs-image-block').append($('<div>').addClass('outputs-label').text(params.label)).append($imageContainer).appendTo(params.container);

      return $block;
    }
  }, {
    key: 'setImageForSlot_',
    value: function setImageForSlot_(id, url) {
      _studio.studio.Util.loadImageFromUri(url).then(function (img) {
        return $('[data-id="out-icon-' + id + '"]').attr('src', img.src);
      });
    }
  }, {
    key: 'setupForm',
    value: function setupForm() {}
  }, {
    key: 'regenerate',
    value: function regenerate() {}
  }, {
    key: 'densities',
    get: function get() {
      return DENSITIES;
    }
  }]);

  return BaseGenerator;
}();

},{"../imagelib":5,"../studio":24}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _basegenerator = require('./basegenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 1, y: 1, w: 22, h: 22 };

var GenericIconGenerator = exports.GenericIconGenerator = function (_BaseGenerator) {
  _inherits(GenericIconGenerator, _BaseGenerator);

  function GenericIconGenerator() {
    _classCallCheck(this, GenericIconGenerator);

    return _possibleConstructorReturn(this, (GenericIconGenerator.__proto__ || Object.getPrototypeOf(GenericIconGenerator)).apply(this, arguments));
  }

  _createClass(GenericIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(GenericIconGenerator.prototype.__proto__ || Object.getPrototypeOf(GenericIconGenerator.prototype), 'setupForm', this).call(this);

      var nameField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 720, h: 720 }, // max render size, for SVGs
          defaultValueClipart: 'ac_unit',
          dropTarget: document.body
        }), new _studio.studio.RangeField('size', {
          newGroup: true,
          title: 'Asset size',
          helpText: 'Size of the final asset',
          min: 4,
          max: 200,
          defaultValue: 32,
          textFn: function textFn(d) {
            return d + 'dp';
          }
        }), new _studio.studio.RangeField('padding', {
          title: 'Asset padding',
          helpText: 'Padding around the icon asset',
          defaultValue: 8,
          textFn: function textFn(d) {
            return d + 'dp';
          }
        }), new _studio.studio.ColorField('color', {
          title: 'Color',
          helpText: 'Flat foreground color',
          defaultValue: 'rgba(0, 0, 0, 0.54)',
          alpha: true
        }), nameField = new _studio.studio.TextField('name', {
          title: 'Name',
          helpText: 'Used when generating ZIP files as the resource name.',
          defaultValue: 'ic_example'
        })]
      });
      this.form.onChange(function (field) {
        var values = _this2.form.getValues();
        if ((!field || field.id_ == 'source') && values.source && values.source.name) {
          var name = 'ic_' + _studio.studio.Util.sanitizeResourceName(values.source.name);
          if (name != nameField.getValue()) {
            nameField.setValue(name);
          }
        }

        _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var totalSize = values.size;
        var padding = Math.min(values.size / 2, values.padding);
        var iconSize = _studio.studio.Util.multRound({ w: totalSize, h: totalSize }, mult);
        var targetRect = _studio.studio.Util.multRound({ x: padding, y: padding, w: totalSize - padding * 2, h: totalSize - padding * 2 }, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, targetRect, { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        var color = values.color;
        var alpha = color.getAlpha();
        color.setAlpha(1);

        _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: color.toRgbString(), opacity: alpha }], outCtx, tmpCtx, iconSize);

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }]);

  return GenericIconGenerator;
}(_basegenerator.BaseGenerator);

},{"../imagelib":5,"../studio":24,"./basegenerator":8}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pages = undefined;

var _launchericons = require('./launchericons');

var _appshortcuticons = require('./appshortcuticons');

var _actionbaricons = require('./actionbaricons');

var _notificationicons = require('./notificationicons');

var _genericicons = require('./genericicons');

var _ninepatches = require('./ninepatch/ninepatches');

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var pages = exports.pages = {
  LauncherIconGenerator: _launchericons.LauncherIconGenerator,
  AppShortcutIconGenerator: _appshortcuticons.AppShortcutIconGenerator,
  ActionBarIconGenerator: _actionbaricons.ActionBarIconGenerator,
  NotificationIconGenerator: _notificationicons.NotificationIconGenerator,
  GenericIconGenerator: _genericicons.GenericIconGenerator,
  NinePatchGenerator: _ninepatches.NinePatchGenerator
};

},{"./actionbaricons":6,"./appshortcuticons":7,"./genericicons":9,"./launchericons":11,"./ninepatch/ninepatches":12,"./notificationicons":18}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LauncherIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _basegenerator = require('./basegenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 48, h: 48 };

var TARGET_RECTS_BY_SHAPE = {
  none: { x: 3, y: 3, w: 42, h: 42 },
  circle: { x: 2, y: 2, w: 44, h: 44 },
  square: { x: 5, y: 5, w: 38, h: 38 },
  vrect: { x: 8, y: 2, w: 32, h: 44 },
  hrect: { x: 2, y: 8, w: 44, h: 32 }
};

var GRID_OVERLAY_SVG = '<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">\n        <g fill="none" fill-rule="evenodd">\n            <rect vector-effect="non-scaling-stroke" x="8" y="2" width="32" height="44" rx="3"/>\n            <rect vector-effect="non-scaling-stroke" x="5" y="5" width="38" height="38" rx="3"/>\n            <rect vector-effect="non-scaling-stroke" x="2" y="8" width="44" height="32" rx="3"/>\n            <circle vector-effect="non-scaling-stroke" cx="24" cy="24" r="10"/>\n            <circle vector-effect="non-scaling-stroke" cx="24" cy="24" r="22"/>\n            <path vector-effect="non-scaling-stroke" d="M0 48L48 0M0 0l48 48M24 48V0M17 0v48M31 0v48M48 24H0M0 31h48M0 17h48"/>\n        </g>\n    </svg>';

var LauncherIconGenerator = exports.LauncherIconGenerator = function (_BaseGenerator) {
  _inherits(LauncherIconGenerator, _BaseGenerator);

  function LauncherIconGenerator() {
    _classCallCheck(this, LauncherIconGenerator);

    return _possibleConstructorReturn(this, (LauncherIconGenerator.__proto__ || Object.getPrototypeOf(LauncherIconGenerator)).apply(this, arguments));
  }

  _createClass(LauncherIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      var backColorField = void 0,
          effectsField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('foreground', {
          title: 'Foreground',
          maxFinalSize: { w: 720, h: 720 }, // max render size, for SVGs
          defaultValueTrim: 1,
          defaultValuePadding: .25,
          defaultValueClipart: 'android',
          dropTarget: document.body
        }), new _studio.studio.ColorField('foreColor', {
          newGroup: true,
          title: 'Color',
          helpText: 'Set to transparent to use original colors',
          alpha: true,
          defaultValue: 'rgba(96, 125, 139, 0)'
        }), backColorField = new _studio.studio.ColorField('backColor', {
          title: 'Background color',
          defaultValue: '#448aff'
        }), new _studio.studio.BooleanField('crop', {
          title: 'Scaling',
          defaultValue: false,
          offText: 'Center',
          onText: 'Crop'
        }), new _studio.studio.EnumField('backgroundShape', {
          title: 'Shape',
          options: [{ id: 'none', title: 'None' }, { id: 'square', title: 'Square' }, { id: 'circle', title: 'Circle' }, { id: 'vrect', title: 'Tall rect' }, { id: 'hrect', title: 'Wide rect' }],
          defaultValue: 'square'
        }), effectsField = new _studio.studio.EnumField('effects', {
          title: 'Effect',
          buttons: true,
          options: [{ id: 'none', title: 'None' }, { id: 'elevate', title: 'Elevate' }, { id: 'shadow', title: 'Cast shadow' }, { id: 'score', title: 'Score' }],
          defaultValue: 'none'
        })]
      });
      this.form.onChange(function (field) {
        backColorField.setEnabled(_this2.form.getValues().backgroundShape != 'none');
        effectsField.setEnabled(_this2.form.getValues().backgroundShape != 'none');
        _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var iconName = 'ic_launcher';

      this.zipper.clear();
      this.zipper.setZipFilename(iconName + '.zip');

      var xxxhdpiCtx = null;

      this.densities.forEach(function (density) {
        var ctx = void 0;
        if (density == 'xxxhdpi' || density == 'web') {
          ctx = _this3.regenerateRawAtDensity_(density);
          if (density == 'xxxhdpi') {
            xxxhdpiCtx = ctx;
          }
        } else {
          // just scale down xxxhdpi
          var mult = _studio.studio.Util.getMultBaseMdpi(density);
          var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);
          ctx = _imagelib.imagelib.Drawing.context(iconSize);
          _imagelib.imagelib.Drawing.drawImageScaled(ctx, xxxhdpiCtx, 0, 0, 192, 192, 0, 0, iconSize.w, iconSize.h);
        }

        _this3.zipper.add({
          name: density == 'web' ? 'web_hi_res_512.png' : 'res/mipmap-' + density + '/' + iconName + '.png',
          canvas: ctx.canvas
        });

        _this3.setImageForSlot_(density, ctx.canvas.toDataURL());
      });
    }
  }, {
    key: 'regenerateRawAtDensity_',
    value: function regenerateRawAtDensity_(density) {
      var values = this.form.getValues();
      var foreSrcCtx = values.foreground ? values.foreground.ctx : null;
      var mult = _studio.studio.Util.getMultBaseMdpi(density);
      if (density == 'web') {
        mult = 512 / 48;
      }

      var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);
      var targetRect = TARGET_RECTS_BY_SHAPE[values.backgroundShape];

      var outCtx = _imagelib.imagelib.Drawing.context(iconSize);

      var roundRectPath_ = function roundRectPath_(ctx, _ref, r) {
        var x = _ref.x,
            y = _ref.y,
            w = _ref.w,
            h = _ref.h;

        ctx.beginPath();
        ctx.moveTo(x + w - r, y);
        ctx.arcTo(x + w, y, x + w, y + r, r);
        ctx.lineTo(x + w, y + h - r);
        ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
        ctx.lineTo(x + r, y + h);
        ctx.arcTo(x, y + h, x, y + h - r, r);
        ctx.lineTo(x, y + r);
        ctx.arcTo(x, y, x + r, y, r);
        ctx.closePath();
      };

      var backgroundLayer = {
        // background layer
        draw: function draw(ctx) {
          ctx.scale(mult, mult);
          values.backColor.setAlpha(1);
          ctx.fillStyle = values.backColor.toRgbString();

          var targetRect = TARGET_RECTS_BY_SHAPE[values.backgroundShape];
          switch (values.backgroundShape) {
            case 'square':
            case 'vrect':
            case 'hrect':
              roundRectPath_(ctx, targetRect, 3);
              ctx.fill();
              break;

            case 'circle':
              ctx.beginPath();
              ctx.arc(targetRect.x + targetRect.w / 2, targetRect.y + targetRect.h / 2, targetRect.w / 2, 0, 2 * Math.PI, false);
              ctx.closePath();
              ctx.fill();
              break;
          }
        },
        mask: true
      };

      var foregroundLayer = {
        // foreground content layer
        draw: function draw(ctx) {
          if (!foreSrcCtx) {
            return;
          }

          var drawFn_ = _imagelib.imagelib.Drawing[values.crop ? 'drawCenterCrop' : 'drawCenterInside'];
          drawFn_(ctx, foreSrcCtx, _studio.studio.Util.mult(targetRect, mult), { x: 0, y: 0, w: foreSrcCtx.canvas.width, h: foreSrcCtx.canvas.height });
        },
        effects: []
      };

      if (values.backgroundShape != 'none' && values.effects == 'shadow') {
        foregroundLayer.effects.push({ effect: 'cast-shadow' });
      }

      if (values.foreColor.getAlpha()) {
        foregroundLayer.effects.push({
          effect: 'fill-color',
          color: values.foreColor.toRgbString()
        });
      }

      if (values.backgroundShape != 'none' && (values.effects == 'elevate' || values.effects == 'shadow')) {
        foregroundLayer.effects = foregroundLayer.effects.concat([{
          effect: 'outer-shadow',
          color: 'rgba(0, 0, 0, 0.2)',
          translateY: .25 * mult
        }, {
          effect: 'outer-shadow',
          color: 'rgba(0, 0, 0, 0.2)',
          blur: 1 * mult,
          translateY: 1 * mult
        }]);
      }

      var scoreLayer = {
        draw: function draw(ctx) {
          ctx.fillStyle = 'rgba(0, 0, 0, .1)';
          ctx.fillRect(0, 0, iconSize.w, iconSize.h / 2);
        }
      };

      _imagelib.imagelib.Drawing.drawLayers(outCtx, iconSize, {
        children: [values.backgroundShape != 'none' ? backgroundLayer : null, foregroundLayer, values.backgroundShape != 'none' && values.effects == 'score' ? scoreLayer : null],
        effects: [{
          effect: 'inner-shadow',
          color: 'rgba(255, 255, 255, 0.2)',
          translateY: .25 * mult
        }, {
          effect: 'inner-shadow',
          color: 'rgba(0, 0, 0, 0.2)',
          translateY: -.25 * mult
        }, {
          effect: 'fill-radialgradient',
          centerX: 0,
          centerY: 0,
          radius: iconSize.w,
          colors: [{ offset: 0, color: 'rgba(255,255,255,.1)' }, { offset: 1.0, color: 'rgba(255,255,255,0)' }]
        }, {
          effect: 'outer-shadow',
          color: 'rgba(0, 0, 0, 0.3)',
          blur: .7 * mult,
          translateY: .7 * mult
        }]
      });

      return outCtx;
    }
  }, {
    key: 'densities',
    get: function get() {
      return new Set(['xxxhdpi' /* must be first */, 'web', 'xxhdpi', 'xhdpi', 'hdpi', 'mdpi']);
    }
  }, {
    key: 'gridOverlaySvg',
    get: function get() {
      return GRID_OVERLAY_SVG;
    }
  }]);

  return LauncherIconGenerator;
}(_basegenerator.BaseGenerator);

},{"../imagelib":5,"../studio":24,"./basegenerator":8}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../../studio');

var _imagelib = require('../../imagelib');

var _basegenerator = require('../basegenerator');

var _ninepatchstage = require('./ninepatchstage');

var _ninepatchpreview = require('./ninepatchpreview');

var _ninepatchloader = require('./ninepatchloader');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var DENSITIES = new Set(['xxxhdpi', 'xxhdpi', 'xhdpi', 'hdpi', 'mdpi']);
var SOURCE_DENSITY_OPTIONS = [{ id: '160', title: 'mdpi<br><small>(160)</small>' }, { id: '240', title: 'hdpi<br><small>(240)</small>' }, { id: '320', title: 'xhdpi<br><small>(320)</small>' }, { id: '480', title: 'xxhdpi<br><small>(480)</small>' }, { id: '640', title: 'xxxhdpi<br><small>(640)</small>' }];

if (document.location.search.indexOf('extradensities') >= 0) {
  DENSITIES.add('ldpi');
  DENSITIES.add('tvdpi');
  // SOURCE_DENSITY_OPTIONS.push({ id: '120', title:   'ldpi<br><small>(120)</small>' });
  // SOURCE_DENSITY_OPTIONS.push({ id: '213', title:  'tvdpi<br><small>(213)</small>' });
}

var NinePatchGenerator = exports.NinePatchGenerator = function (_BaseGenerator) {
  _inherits(NinePatchGenerator, _BaseGenerator);

  function NinePatchGenerator() {
    _classCallCheck(this, NinePatchGenerator);

    var _this = _possibleConstructorReturn(this, (NinePatchGenerator.__proto__ || Object.getPrototypeOf(NinePatchGenerator)).call(this));

    _this.stage = new _ninepatchstage.NinePatchStage();
    _this.preview = new _ninepatchpreview.NinePatchPreview(_this.stage);

    _this.stage.onChange(function () {
      _this.regenerate();
      _this.preview.redraw();
    });

    _this.setupOutputsPreviewTabs();
    return _this;
  }

  _createClass(NinePatchGenerator, [{
    key: 'setupOutputsPreviewTabs',
    value: function setupOutputsPreviewTabs() {
      $('.outputs-preview-tabs input').on('change', function (ev) {
        $('.outputs-preview-sidebar').attr('data-view', $(ev.currentTarget).val());
        $('.outputs-preview-tabs input').prop('checked', false);
        $(ev.currentTarget).prop('checked', true);
      });
    }
  }, {
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(NinePatchGenerator.prototype.__proto__ || Object.getPrototypeOf(NinePatchGenerator.prototype), 'setupForm', this).call(this);
      var nameField = void 0;
      this.form = new _studio.studio.Form({
        id: 'ninepatchform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source graphic',
          imageOnly: true,
          noTrimForm: true,
          noPreview: true,
          dropTarget: document.body
        }), new _studio.studio.EnumField('sourceDensity', {
          title: 'Source density',
          buttons: true,
          options: SOURCE_DENSITY_OPTIONS,
          defaultValue: '320'
        }), nameField = new _studio.studio.TextField('name', {
          title: 'Drawable name',
          helpText: 'Used when generating ZIP files. Becomes <code>&lt;name&gt;.9.png</code>.',
          defaultValue: 'example'
        })]
      });
      this.form.onChange(function (field) {
        var values = _this2.form.getValues();
        if (!field || field.id_ == 'source') {
          if (values.source) {
            if (!values.source.ctx) {
              return;
            }
            var src = values.source;
            var size = { w: src.ctx.canvas.width, h: src.ctx.canvas.height };
            _this2.stage.name = src.name + '-' + size.w + 'x' + size.h;
            // let isSvg = !!src.name.match(/\.svg$/i);
            if (src.name && src.name.match(/\.9\.png$/i)) {
              _ninepatchloader.NinePatchLoader.loadNinePatchIntoStage(src.ctx, _this2.stage);
            } else {
              _this2.stage.loadSourceImage(src.ctx);
            }
            if (src.name) {
              var name = _studio.studio.Util.sanitizeResourceName(src.name);
              if (name != nameField.getValue()) {
                nameField.setValue(name);
              }
            }
          } else {
            _this2.stage.loadSourceImage(null);
          }
        } else {
          _this2.regenerate();
        }
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      // this.preview.update();

      if (!this.stage.srcCtx) {
        return;
      }

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.9.zip');

      this.densities.forEach(function (density) {
        var dpi = _studio.studio.Util.getDpiForDensity(density);

        // scale source graphic
        // TODO: support better-smoothing option
        var scale = dpi / values.sourceDensity;
        var outSize = {
          w: Math.ceil(_this3.stage.srcSize.w * scale) + 2,
          h: Math.ceil(_this3.stage.srcSize.h * scale) + 2
        };
        var outCtx = _imagelib.imagelib.Drawing.context(outSize);
        _imagelib.imagelib.Drawing.drawImageScaled(outCtx, _this3.stage.srcCtx, 0, 0, _this3.stage.srcSize.w, _this3.stage.srcSize.h, 1, 1, outSize.w - 2, outSize.h - 2);

        // draw Android 4.3 optical bounds
        outCtx.strokeStyle = '#f00';
        outCtx.lineWidth = 1;
        outCtx.beginPath();

        outCtx.moveTo(1, outSize.h - 0.5);
        outCtx.lineTo(1 + Math.floor(scale * _this3.stage.opticalBoundsRect.x), outSize.h - 0.5);
        outCtx.stroke();

        outCtx.moveTo(Math.ceil(scale * (_this3.stage.opticalBoundsRect.x + _this3.stage.opticalBoundsRect.w)) + 1, outSize.h - 0.5);
        outCtx.lineTo(outSize.w - 1, outSize.h - 0.5);
        outCtx.stroke();

        outCtx.moveTo(outSize.w - 0.5, 1);
        outCtx.lineTo(outSize.w - 0.5, 1 + Math.floor(scale * _this3.stage.opticalBoundsRect.y));
        outCtx.stroke();

        outCtx.moveTo(outSize.w - 0.5, Math.ceil(scale * (_this3.stage.opticalBoundsRect.y + _this3.stage.opticalBoundsRect.h)) + 1);
        outCtx.lineTo(outSize.w - 0.5, outSize.h - 1);
        outCtx.stroke();

        outCtx.closePath();

        // draw nine-patch tick marks
        outCtx.strokeStyle = '#000';
        outCtx.beginPath();

        outCtx.moveTo(1 + Math.floor(scale * _this3.stage.stretchRect.x), 0.5);
        outCtx.lineTo(1 + Math.ceil(scale * (_this3.stage.stretchRect.x + _this3.stage.stretchRect.w)), 0.5);
        outCtx.stroke();

        outCtx.moveTo(0.5, 1 + Math.floor(scale * _this3.stage.stretchRect.y));
        outCtx.lineTo(0.5, 1 + Math.ceil(scale * (_this3.stage.stretchRect.y + _this3.stage.stretchRect.h)));
        outCtx.stroke();

        outCtx.moveTo(1 + Math.floor(scale * _this3.stage.contentRect.x), outSize.h - 0.5);
        outCtx.lineTo(1 + Math.ceil(scale * (_this3.stage.contentRect.x + _this3.stage.contentRect.w)), outSize.h - 0.5);
        outCtx.stroke();

        outCtx.moveTo(outSize.w - 0.5, 1 + Math.floor(scale * _this3.stage.contentRect.y));
        outCtx.lineTo(outSize.w - 0.5, 1 + Math.ceil(scale * (_this3.stage.contentRect.y + _this3.stage.contentRect.h)));
        outCtx.stroke();

        outCtx.closePath();

        // add to zip and show preview

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.9.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }, {
    key: 'densities',
    get: function get() {
      return DENSITIES;
    }
  }]);

  return NinePatchGenerator;
}(_basegenerator.BaseGenerator);

},{"../../imagelib":5,"../../studio":24,"../basegenerator":8,"./ninepatchloader":13,"./ninepatchpreview":14,"./ninepatchstage":15}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchLoader = undefined;

var _imagelib = require('../../imagelib');

var numberForRGBA = function numberForRGBA(r, g, b, a) {
  return (r << 16) + (g << 8) + (b << 0) + (a << 24);
}; /*
    * Copyright 2016 Google Inc.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

var BLACK = numberForRGBA(0, 0, 0, 255);
var RED = numberForRGBA(255, 0, 0, 255);

var NinePatchLoader = exports.NinePatchLoader = {
  loadNinePatchIntoStage: function loadNinePatchIntoStage(ctx, stage) {
    var srcSize = { w: ctx.canvas.width, h: ctx.canvas.height };
    var imgData = ctx.getImageData(0, 0, srcSize.w, srcSize.h);
    var size = { w: srcSize.w - 2, h: srcSize.h - 2 };
    var rects = {
      contentRect: { x: 0, y: 0, w: size.w, h: size.h },
      stretchRect: { x: 0, y: 0, w: size.w, h: size.h },
      opticalBoundsRect: { x: 0, y: 0, w: size.w, h: size.h }
    };

    function _getPixel(x, y) {
      return (imgData.data[(y * srcSize.w + x) * 4 + 0] << 16) + ( // r
      imgData.data[(y * srcSize.w + x) * 4 + 1] << 8) // g
      + (imgData.data[(y * srcSize.w + x) * 4 + 2] << 0) // b
      + (imgData.data[(y * srcSize.w + x) * 4 + 3] << 24); // a
    }

    var inRegion = void 0;

    // Read stretch rect
    inRegion = false;
    for (var x = 0; x < size.w; x++) {
      var p = _getPixel(x + 1, 0);
      if (!inRegion && p == BLACK) {
        rects.stretchRect.x = x;
        inRegion = true;
      } else if (inRegion && p != BLACK) {
        rects.stretchRect.w = x - rects.stretchRect.x;
        inRegion = false;
      }
    }

    inRegion = false;
    for (var y = 0; y < size.h; y++) {
      var _p = _getPixel(0, y + 1);
      if (!inRegion && _p == BLACK) {
        rects.stretchRect.y = y;
        inRegion = true;
      } else if (inRegion && _p != BLACK) {
        rects.stretchRect.h = y - rects.stretchRect.y;
        inRegion = false;
      }
    }

    // Read content rect
    inRegion = false;
    for (var _x = 0; _x < size.w; _x++) {
      var _p2 = _getPixel(_x + 1, srcSize.h - 1);
      if (!inRegion && _p2 == BLACK) {
        rects.contentRect.x = _x;
        inRegion = true;
      } else if (inRegion && _p2 != BLACK) {
        rects.contentRect.w = _x - rects.contentRect.x;
        inRegion = false;
      }
    }

    inRegion = false;
    for (var _y = 0; _y < size.h; _y++) {
      var _p3 = _getPixel(srcSize.w - 1, _y + 1);
      if (!inRegion && _p3 == BLACK) {
        rects.contentRect.y = _y;
        inRegion = true;
      } else if (inRegion && _p3 != BLACK) {
        rects.contentRect.h = _y - rects.contentRect.y;
        inRegion = false;
      }
    }

    // Read optical bounds rect
    inRegion = false;
    for (var _x2 = 0; _x2 < size.w; _x2++) {
      var _p4 = _getPixel(_x2 + 1, srcSize.h - 1);
      if (!inRegion && _p4 != RED) {
        rects.opticalBoundsRect.x = _x2;
        inRegion = true;
      } else if (inRegion && _p4 == RED) {
        rects.opticalBoundsRect.w = _x2 - rects.opticalBoundsRect.x;
        inRegion = false;
      }
    }
    for (var _y2 = 0; _y2 < size.h; _y2++) {
      var _p5 = _getPixel(srcSize.w - 1, _y2 + 1);
      if (!inRegion && _p5 != RED) {
        rects.opticalBoundsRect.y = _y2;
        inRegion = true;
      } else if (inRegion && _p5 == RED) {
        rects.opticalBoundsRect.h = _y2 - rects.opticalBoundsRect.y;
        inRegion = false;
      }
    }

    // Inset the context
    var newCtx = _imagelib.imagelib.Drawing.context(size);
    newCtx.drawImage(ctx.canvas, 1, 1, size.w, size.h, 0, 0, size.w, size.h);
    stage.loadSourceImage(newCtx, rects);
  }
};

},{"../../imagelib":5}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var NinePatchPreview = exports.NinePatchPreview = function () {
  function NinePatchPreview(stage) {
    _classCallCheck(this, NinePatchPreview);

    this.stage = stage;
    this.size = { w: 200, h: 200 };
    this.setupUi();
    this.redraw();
  }

  _createClass(NinePatchPreview, [{
    key: 'setupUi',
    value: function setupUi() {
      var _this = this;

      var startWidth = void 0,
          startHeight = void 0,
          startX = void 0,
          startY = void 0;

      var mouseMoveHandler_ = function mouseMoveHandler_(ev) {
        _this.size.w = Math.max(1, startWidth + (ev.pageX - startX) * 2);
        _this.size.h = Math.max(1, startHeight + (ev.pageY - startY) * 2);
        _this.redraw();
      };

      var mouseUpHandler_ = function mouseUpHandler_(ev) {
        $(window).off('mousemove', mouseMoveHandler_).off('mouseup', mouseUpHandler_);
      };

      $('.preview-area').on('mousedown', function (ev) {
        startWidth = _this.size.w;
        startHeight = _this.size.h;
        startX = ev.pageX;
        startY = ev.pageY;

        $(window).on('mousemove', mouseMoveHandler_).on('mouseup', mouseUpHandler_);
      });

      $('#preview-with-content').click(function (ev) {
        return $('.text-preview').toggle($(ev.currentTarget).is(':checked'));
      });
    }
  }, {
    key: 'redraw',
    value: function redraw() {
      var canvas = $('.preview-area canvas').get(0);
      canvas.width = this.size.w;
      canvas.height = this.size.h;

      if (this.stage.srcCtx) {
        var ctx = canvas.getContext('2d');

        var fixed = {
          l: this.stage.stretchRect.x,
          t: this.stage.stretchRect.y,
          r: this.stage.srcSize.w - this.stage.stretchRect.x - this.stage.stretchRect.w,
          b: this.stage.srcSize.h - this.stage.stretchRect.y - this.stage.stretchRect.h
        };

        // TL
        if (fixed.l && fixed.t) ctx.drawImage(this.stage.srcCtx.canvas, 0, 0, fixed.l, fixed.t, 0, 0, fixed.l, fixed.t);

        // BL
        if (fixed.l && fixed.b) ctx.drawImage(this.stage.srcCtx.canvas, 0, this.stage.srcSize.h - fixed.b, fixed.l, fixed.b, 0, this.size.h - fixed.b, fixed.l, fixed.b);

        // TR
        if (fixed.r && fixed.t) ctx.drawImage(this.stage.srcCtx.canvas, this.stage.srcSize.w - fixed.r, 0, fixed.r, fixed.t, this.size.w - fixed.r, 0, fixed.r, fixed.t);

        // BR
        if (fixed.r && fixed.b) ctx.drawImage(this.stage.srcCtx.canvas, this.stage.srcSize.w - fixed.r, this.stage.srcSize.h - fixed.b, fixed.r, fixed.b, this.size.w - fixed.r, this.size.h - fixed.b, fixed.r, fixed.b);

        // Top
        if (fixed.t) ctx.drawImage(this.stage.srcCtx.canvas, fixed.l, 0, this.stage.stretchRect.w, fixed.t, fixed.l, 0, this.size.w - fixed.l - fixed.r, fixed.t);

        // Left
        if (fixed.l) ctx.drawImage(this.stage.srcCtx.canvas, 0, fixed.t, fixed.l, this.stage.stretchRect.h, 0, fixed.t, fixed.l, this.size.h - fixed.t - fixed.b);

        // Right
        if (fixed.r) ctx.drawImage(this.stage.srcCtx.canvas, this.stage.srcSize.w - fixed.r, fixed.t, fixed.r, this.stage.stretchRect.h, this.size.w - fixed.r, fixed.t, fixed.r, this.size.h - fixed.t - fixed.b);

        // Bottom
        if (fixed.b) ctx.drawImage(this.stage.srcCtx.canvas, fixed.l, this.stage.srcSize.h - fixed.b, this.stage.stretchRect.w, fixed.b, fixed.l, this.size.h - fixed.b, this.size.w - fixed.l - fixed.r, fixed.b);

        // Middle
        ctx.drawImage(this.stage.srcCtx.canvas, fixed.l, fixed.t, this.stage.stretchRect.w, this.stage.stretchRect.h, fixed.l, fixed.t, this.size.w - fixed.l - fixed.r, this.size.h - fixed.t - fixed.b);

        // preview content
        $('.preview-area .text-preview').css({
          left: this.stage.contentRect.x + "px",
          top: this.stage.contentRect.y + "px",
          width: this.size.w - this.stage.srcSize.w + this.stage.contentRect.w + "px",
          height: this.size.h - this.stage.srcSize.h + this.stage.contentRect.h + "px"
        });
      }
    }
  }]);

  return NinePatchPreview;
}();

},{}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchStage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _imagelib = require('../../imagelib');

var _ninepatchtrimming = require('./ninepatchtrimming');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EMPTY_RECT = { x: 0, y: 0, w: 0, h: 0 };

var SLOP_PIXELS = 10;

var NinePatchStage = exports.NinePatchStage = function () {
  function NinePatchStage() {
    var _this = this;

    _classCallCheck(this, NinePatchStage);

    this.zoom = 1;
    this.matteColor = 'light';
    this.editMode = 'stretch';
    this.stretchRect = Object.assign({}, EMPTY_RECT);
    this.contentRect = Object.assign({}, EMPTY_RECT);
    this.opticalBoundsRect = Object.assign({}, EMPTY_RECT);
    this.name = 'default';
    this.changeListeners_ = [];

    this.$stage = $('.nine-patch-stage');
    this.$canvasContainer = $('.stage-canvas-container');

    this.setupUi();
    this.setupDragging();

    $(window).on('resize', function () {
      _this.relayout();
      _this.redrawOverlay();
    });
  }

  _createClass(NinePatchStage, [{
    key: 'onChange',
    value: function onChange(listener) {
      this.changeListeners_.push(listener);
    }
  }, {
    key: 'notifyChange_',
    value: function notifyChange_() {
      this.changeListeners_.forEach(function (fn) {
        return fn();
      });
    }
  }, {
    key: 'setupUi',
    value: function setupUi() {
      var _this2 = this;

      // Stage code
      this.$topLabel = $('<div>').addClass('canvas-label label-vertical').hide().appendTo('body');
      this.$leftLabel = $('<div>').addClass('canvas-label label-horizontal').hide().appendTo('body');
      this.$rightLabel = $('<div>').addClass('canvas-label label-horizontal').hide().appendTo('body');
      this.$bottomLabel = $('<div>').addClass('canvas-label label-vertical').hide().appendTo('body');

      $('.stage-which input').on('change', function (ev) {
        _this2.editMode = $(ev.currentTarget).val();
        $('.trim-button').toggle(_this2.editMode == 'stretch');
        $('.find-region-button').text({
          stretch: 'Auto-stretch',
          padding: 'Auto-padding',
          opticalbounds: 'Auto-bounds'
        }[_this2.editMode]);
        $('.stage-which input').prop('checked', false);
        $(ev.currentTarget).prop('checked', true);
        _this2.redrawOverlay();
      });

      $('.stage-matte-color input').on('change', function (ev) {
        _this2.matteColor = $(ev.currentTarget).val();
        $(document.body).attr('data-theme', _this2.matteColor);
        $('.stage-matte-color input').prop('checked', false);
        $(ev.currentTarget).prop('checked', true);
        _this2.redrawImage();
      });

      $('.trim-edge-button').click(function () {
        return _ninepatchtrimming.NinePatchTrimming.trimEdges(_this2);
      });
      $('.trim-stretch-button').click(function () {
        return _ninepatchtrimming.NinePatchTrimming.trimStretchRegion(_this2);
      });
      $('.find-region-button').click(function () {
        var rect = _ninepatchtrimming.NinePatchTrimming.detectRegion(_this2, _this2.editMode);
        if (!rect) {
          return;
        }

        if (_this2.editMode == 'stretch') {
          _this2.stretchRect = rect;
        } else if (_this2.editMode == 'opticalbounds') {
          _this2.opticalBoundsRect = rect;
        } else if (_this2.editMode == 'padding') {
          _this2.contentRect = rect;
        }

        _this2.saveRects();
        _this2.redrawOverlay();
        _this2.notifyChange_();
      });
    }
  }, {
    key: 'setupDragging',
    value: function setupDragging() {
      var _this3 = this;

      var _mouseUpHandler_ = void 0,
          draggingMouseMoveHandler_ = void 0;

      var getEditRect_ = function getEditRect_() {
        return {
          stretch: _this3.stretchRect,
          padding: _this3.contentRect,
          opticalbounds: _this3.opticalBoundsRect
        }[_this3.editMode];
      };

      this.$canvasContainer.on('mousedown', function (ev) {
        _this3.dragging = true;
        _this3.redrawOverlay();
        $(window).on('mouseup', _mouseUpHandler_).on('mousemove', draggingMouseMoveHandler_);
      }).on('mousemove', function (ev) {
        if (!_this3.$imageCanvas) {
          return;
        }

        if (_this3.dragging) {
          return; // handled by other mousemove handler
        }

        var editRect = getEditRect_();
        var offs = _this3.$canvasContainer.offset();
        var offsetX = ev.pageX - offs.left;
        var offsetY = ev.pageY - offs.top;

        _this3.editLeft = _this3.editRight = _this3.editTop = _this3.editBottom = false;

        if (offsetX >= editRect.x * _this3.zoom - SLOP_PIXELS && offsetX <= editRect.x * _this3.zoom + SLOP_PIXELS) {
          _this3.editLeft = true;
        } else if (offsetX >= (editRect.x + editRect.w) * _this3.zoom - SLOP_PIXELS && offsetX <= (editRect.x + editRect.w) * _this3.zoom + SLOP_PIXELS) {
          _this3.editRight = true;
        }

        if (offsetY >= editRect.y * _this3.zoom - SLOP_PIXELS && offsetY <= editRect.y * _this3.zoom + SLOP_PIXELS) {
          _this3.editTop = true;
        } else if (offsetY >= (editRect.y + editRect.h) * _this3.zoom - SLOP_PIXELS && offsetY <= (editRect.y + editRect.h) * _this3.zoom + SLOP_PIXELS) {
          _this3.editBottom = true;
        }

        var cursor = 'default';
        if (_this3.editLeft) {
          if (_this3.editTop) {
            cursor = 'nw-resize';
          } else if (_this3.editBottom) {
            cursor = 'sw-resize';
          } else {
            cursor = 'w-resize';
          }
        } else if (_this3.editRight) {
          if (_this3.editTop) {
            cursor = 'ne-resize';
          } else if (_this3.editBottom) {
            cursor = 'se-resize';
          } else {
            cursor = 'e-resize';
          }
        } else if (_this3.editTop) {
          cursor = 'n-resize';
        } else if (_this3.editBottom) {
          cursor = 's-resize';
        }
        _this3.$canvasContainer.css('cursor', cursor);
      });

      _mouseUpHandler_ = function mouseUpHandler_(ev) {
        if (_this3.dragging) {
          _this3.dragging = false;
          _this3.redrawOverlay();
          _this3.saveRects();
        }

        $(window).off('mousemove', draggingMouseMoveHandler_).off('mouseup', _mouseUpHandler_);
      };

      draggingMouseMoveHandler_ = function draggingMouseMoveHandler_(ev) {
        ev.preventDefault();
        ev.stopPropagation();

        var editRect = getEditRect_();
        var offs = _this3.$canvasContainer.offset();
        var offsetX = ev.pageX - offs.left;
        var offsetY = ev.pageY - offs.top;

        if (_this3.editLeft) {
          var newX = Math.max(0, Math.min(editRect.x + editRect.w - 1, Math.round(offsetX / _this3.zoom)));
          editRect.w = editRect.w + editRect.x - newX;
          editRect.x = newX;
        }
        if (_this3.editTop) {
          var newY = Math.max(0, Math.min(editRect.y + editRect.h - 1, Math.round(offsetY / _this3.zoom)));
          editRect.h = editRect.h + editRect.y - newY;
          editRect.y = newY;
        }
        if (_this3.editRight) {
          editRect.w = Math.min(_this3.srcSize.w - editRect.x, Math.max(1, Math.round(offsetX / _this3.zoom) - editRect.x));
        }
        if (_this3.editBottom) {
          editRect.h = Math.min(_this3.srcSize.h - editRect.y, Math.max(1, Math.round(offsetY / _this3.zoom) - editRect.y));
        }

        _this3.redrawOverlay();
        _this3.notifyChange_();
      };
    }
  }, {
    key: 'loadSourceImage',
    value: function loadSourceImage(srcCtx) {
      var initRects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.$canvasContainer.empty();
      $('.editor-button').attr('disabled', srcCtx ? null : 'disabled');

      if (!srcCtx) {
        return;
      }

      this.srcCtx = srcCtx;

      // Update the stage source size
      var srcSizeChanged = false;
      var newSrcSize = { w: this.srcCtx.canvas.width, h: this.srcCtx.canvas.height };
      srcSizeChanged = !this.srcSize || this.srcSize.w != newSrcSize.w || this.srcSize.h != newSrcSize.h;
      this.srcSize = newSrcSize;

      // Reset the stretch, padding/content, and optical bounds regions
      if (srcSizeChanged) {
        this.stretchRect = initRects.stretchRect || {
          x: Math.floor(this.srcSize.w / 3),
          y: Math.floor(this.srcSize.h / 3),
          w: Math.ceil(this.srcSize.w / 3),
          h: Math.ceil(this.srcSize.h / 3)
        };

        this.contentRect = initRects.contentRect || { x: 0, y: 0, w: this.srcSize.w, h: this.srcSize.h };
        this.opticalBoundsRect = initRects.opticalBoundsRect || { x: 0, y: 0, w: this.srcSize.w, h: this.srcSize.h };
      }

      if (!initRects.stretchRect) {
        this.loadLastRects();
      }

      // Create the stage canvas
      this.$imageCanvas = $('<canvas>').attr({
        width: this.srcSize.w,
        height: this.srcSize.h
      }).appendTo(this.$canvasContainer);

      this.$overlayCanvas = $('<canvas>').addClass('overlay').appendTo(this.$canvasContainer);

      this.relayout();
      this.redrawImage();
      this.redrawOverlay();
      this.notifyChange_();
    }
  }, {
    key: 'relayout',
    value: function relayout() {
      if (!this.$imageCanvas) {
        return;
      }

      // Compute a zoom level that'll show the stage as large as possible
      var horizMaxZoom = Math.floor(this.$stage.width() / this.srcSize.w);
      var vertMaxZoom = Math.floor(this.$stage.height() / this.srcSize.h);
      this.zoom = Math.max(1, Math.min(horizMaxZoom, vertMaxZoom));
      this.zoomedSize = {
        w: this.srcSize.w * this.zoom,
        h: this.srcSize.h * this.zoom
      };

      this.$imageCanvas.css({
        width: this.zoomedSize.w,
        height: this.zoomedSize.h
      });
      this.$overlayCanvas.attr({
        width: this.zoomedSize.w,
        height: this.zoomedSize.h
      });
    }
  }, {
    key: 'redrawImage',
    value: function redrawImage() {
      if (!this.$imageCanvas) {
        return;
      }

      var imgCtx = this.$imageCanvas.get(0).getContext('2d');
      imgCtx.fillStyle = this.matteColor == 'light' ? '#eee' : '#555';
      imgCtx.fillRect(0, 0, this.srcSize.w, this.srcSize.h);

      // draw source graphic
      imgCtx.drawImage(this.srcCtx.canvas, 0, 0);
    }
  }, {
    key: 'redrawOverlay',
    value: function redrawOverlay() {
      if (!this.srcCtx) {
        return;
      }

      var editRect = {
        stretch: this.stretchRect,
        padding: this.contentRect,
        opticalbounds: this.opticalBoundsRect
      }[this.editMode];

      var ctx = this.$overlayCanvas.get(0).getContext('2d');
      ctx.clearRect(0, 0, this.zoomedSize.w, this.zoomedSize.h);
      ctx.save();

      // draw current edit region
      if (editRect === this.stretchRect) {
        ctx.beginPath();

        ctx.moveTo(0, editRect.y * this.zoom + .5);
        ctx.lineTo(this.zoomedSize.w, editRect.y * this.zoom + .5);

        ctx.moveTo(0, (editRect.y + editRect.h) * this.zoom - .5);
        ctx.lineTo(this.zoomedSize.w, (editRect.y + editRect.h) * this.zoom - .5);

        ctx.moveTo(editRect.x * this.zoom + .5, 0);
        ctx.lineTo(editRect.x * this.zoom + .5, this.zoomedSize.h);

        ctx.moveTo((editRect.x + editRect.w) * this.zoom - .5, 0);
        ctx.lineTo((editRect.x + editRect.w) * this.zoom - .5, this.zoomedSize.h);
      } else {
        ctx.beginPath();
        ctx.rect(editRect.x * this.zoom + .5, editRect.y * this.zoom + .5, editRect.w * this.zoom - 1, editRect.h * this.zoom - 1);
        ctx.closePath();
      }

      if (this.dragging) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255, 23, 68, 1)';
        ctx.lineWidth = 1;
        ctx.stroke();
      } else {
        ctx.strokeStyle = 'rgba(255, 255, 255, .5)';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.strokeStyle = 'rgba(0, 0, 0, .5)';
        ctx.setLineDash([3, 3]);
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      ctx.restore();

      // draw distance labels
      if (this.dragging) {
        var stageOffset = this.$canvasContainer.offset();

        this.$leftLabel.text(editRect.x).css({
          left: stageOffset.left,
          width: editRect.x * this.zoom,
          top: stageOffset.top + (editRect.y + editRect.h / 2) * this.zoom
        }).show();

        this.$rightLabel.text(this.srcSize.w - editRect.x - editRect.w).css({
          left: stageOffset.left + (editRect.x + editRect.w) * this.zoom,
          width: (this.srcSize.w - editRect.x - editRect.w) * this.zoom,
          top: stageOffset.top + (editRect.y + editRect.h / 2) * this.zoom
        }).show();

        this.$topLabel.text(editRect.y).css({
          top: stageOffset.top,
          height: editRect.y * this.zoom,
          left: stageOffset.left + (editRect.x + editRect.w / 2) * this.zoom
        }).show();

        this.$bottomLabel.text(this.srcSize.h - editRect.y - editRect.h).css({
          top: stageOffset.top + (editRect.y + editRect.h) * this.zoom,
          height: (this.srcSize.h - editRect.y - editRect.h) * this.zoom,
          left: stageOffset.left + (editRect.x + editRect.w / 2) * this.zoom
        }).show();
      } else {
        this.$topLabel.hide();
        this.$leftLabel.hide();
        this.$rightLabel.hide();
        this.$bottomLabel.hide();
      }
    }
  }, {
    key: 'saveRects',
    value: function saveRects() {
      localStorage[this.localStorageKey] = JSON.stringify({
        stretchRect: this.stretchRect,
        contentRect: this.contentRect,
        opticalBoundsRect: this.opticalBoundsRect
      });
    }
  }, {
    key: 'loadLastRects',
    value: function loadLastRects() {
      try {
        var store = JSON.parse(localStorage[this.localStorageKey]);
        if (store.stretchRect && store.contentRect && store.opticalBoundsRect) {
          this.stretchRect = fitRect_(store.stretchRect, this.srcSize);
          this.contentRect = fitRect_(store.contentRect, this.srcSize);
          this.opticalBoundsRect = fitRect_(store.opticalBoundsRect, this.srcSize);
        }
      } catch (e) {}
    }
  }, {
    key: 'localStorageKey',
    get: function get() {
      return 'assetStudioNinePatchStage-' + this.name;
    }
  }]);

  return NinePatchStage;
}();

function fitRect_(rect, size) {
  var newRect = {};
  newRect.x = Math.max(0, rect.x);
  newRect.y = Math.max(0, rect.y);
  newRect.w = Math.min(size.w - rect.x, rect.w);
  newRect.h = Math.min(size.h - rect.y, rect.h);
  return newRect;
}

},{"../../imagelib":5,"./ninepatchtrimming":16}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchTrimming = undefined;

var _imagelib = require('../../imagelib');

var _summer = require('./summer');

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var NinePatchTrimming = exports.NinePatchTrimming = {
  /**
   * Trims excess edges of the nine patch... any pixels that are the same
   * as the top-left most pixel color. Same as Photoshop's Trim feature.
   */
  trimEdges: function trimEdges(stage) {
    if (!stage.srcCtx) {
      return;
    }

    var srcData = stage.srcCtx.getImageData(0, 0, stage.srcSize.w, stage.srcSize.h);

    // Always trim by top-left pixel color
    var trimPixel = getPixel_(stage, srcData, 0, 0);

    var insetRect = { l: 0, t: 0, r: 0, b: 0 };
    var x = void 0,
        y = void 0;

    // Trim top
    trimTop: for (y = 0; y < stage.srcSize.h; y++) {
      for (x = 0; x < stage.srcSize.w; x++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimTop;
        }
      }
    }
    insetRect.t = y;
    // Trim left
    trimLeft: for (x = 0; x < stage.srcSize.w; x++) {
      for (y = 0; y < stage.srcSize.h; y++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimLeft;
        }
      }
    }
    insetRect.l = x;
    // Trim bottom
    trimBottom: for (y = stage.srcSize.h - 1; y >= 0; y--) {
      for (x = 0; x < stage.srcSize.w; x++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimBottom;
        }
      }
    }
    insetRect.b = stage.srcSize.h - y - 1;
    // Trim right
    trimRight: for (x = stage.srcSize.w - 1; x >= 0; x--) {
      for (y = 0; y < stage.srcSize.h; y++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimRight;
        }
      }
    }
    insetRect.r = stage.srcSize.w - x - 1;

    if (insetRect.l <= 0 && insetRect.t <= 0 && insetRect.r <= 0 && insetRect.b <= 0) {
      // No-op
      return;
    }

    // Build a new stage with inset values
    var size = {
      w: stage.srcSize.w - insetRect.l - insetRect.r,
      h: stage.srcSize.h - insetRect.t - insetRect.b
    };

    var rects = {
      contentRect: constrain_(size, {
        x: stage.contentRect.x - insetRect.l,
        y: stage.contentRect.y - insetRect.t,
        w: stage.contentRect.w,
        h: stage.contentRect.h
      }),
      stretchRect: constrain_(size, {
        x: stage.stretchRect.x - insetRect.l,
        y: stage.stretchRect.y - insetRect.t,
        w: stage.stretchRect.w,
        h: stage.stretchRect.h
      }),
      opticalBoundsRect: constrain_(size, {
        x: stage.opticalBoundsRect.x - insetRect.l,
        y: stage.opticalBoundsRect.y - insetRect.t,
        w: stage.opticalBoundsRect.w,
        h: stage.opticalBoundsRect.h
      })
    };

    stage.name = stage.name + '-EDGES_TRIMMED';
    var newCtx = _imagelib.imagelib.Drawing.context(size);
    newCtx.drawImage(stage.srcCtx.canvas, insetRect.l, insetRect.t, size.w, size.h, 0, 0, size.w, size.h);
    stage.loadSourceImage(newCtx, rects);
  },


  /**
   * Trims excess rows and columns from the stretch region of the given
   * nine patch stage.
   */
  trimStretchRegion: function trimStretchRegion(stage) {
    if (!stage.srcCtx) {
      return;
    }

    var srcData = stage.srcCtx.getImageData(0, 0, stage.srcSize.w, stage.srcSize.h);

    var collapseX = stage.stretchRect.w > 4; // generally going to start as true
    var collapseY = stage.stretchRect.h > 4; // generally going to start as true
    var x = void 0,
        y = void 0;

    // See if collapse is possible in either direction by comparing row/column sums.
    var summer = new _summer.Summer();

    // See if can be horizontally collapsed.
    var first = true;
    var firstSum = -1;
    for (x = stage.stretchRect.x; x < stage.stretchRect.x + stage.stretchRect.w; x++) {
      // Compute column
      summer.reset();
      for (y = 0; y < stage.srcSize.h; y++) {
        summer.addNext(getPixel_(stage, srcData, x, y));
      }
      if (first) {
        firstSum = summer.compute();
        first = false;
      } else if (summer.compute() != firstSum) {
        collapseX = false;
        break;
      }
    }

    first = true;
    for (y = stage.stretchRect.y; y < stage.stretchRect.y + stage.stretchRect.h; y++) {
      // Compute row
      summer.reset();
      for (x = 0; x < stage.srcSize.w; x++) {
        summer.addNext(getPixel_(stage, srcData, x, y));
      }
      if (first) {
        firstSum = summer.compute();
        first = false;
      } else if (summer.compute() != firstSum) {
        collapseY = false;
        break;
      }
    }

    if (!collapseX && !collapseY) {
      // No-op
      return;
    }

    var fixed = {
      l: stage.stretchRect.x,
      t: stage.stretchRect.y,
      r: stage.srcSize.w - stage.stretchRect.x - stage.stretchRect.w,
      b: stage.srcSize.h - stage.stretchRect.y - stage.stretchRect.h
    };

    var middle = {
      w: collapseX ? 4 : stage.stretchRect.w,
      h: collapseY ? 4 : stage.stretchRect.h
    };

    var size = {
      w: fixed.l + middle.w + fixed.r,
      h: fixed.t + middle.h + fixed.b
    };

    // Redraw components
    var ctx = _imagelib.imagelib.Drawing.context(size);

    // TL
    if (fixed.l && fixed.t) ctx.drawImage(stage.srcCtx.canvas, 0, 0, fixed.l, fixed.t, 0, 0, fixed.l, fixed.t);

    // BL
    if (fixed.l && fixed.b) ctx.drawImage(stage.srcCtx.canvas, 0, stage.srcSize.h - fixed.b, fixed.l, fixed.b, 0, size.h - fixed.b, fixed.l, fixed.b);

    // TR
    if (fixed.r && fixed.t) ctx.drawImage(stage.srcCtx.canvas, stage.srcSize.w - fixed.r, 0, fixed.r, fixed.t, size.w - fixed.r, 0, fixed.r, fixed.t);

    // BR
    if (fixed.r && fixed.b) ctx.drawImage(stage.srcCtx.canvas, stage.srcSize.w - fixed.r, stage.srcSize.h - fixed.b, fixed.r, fixed.b, size.w - fixed.r, size.h - fixed.b, fixed.r, fixed.b);

    // Top
    if (fixed.t) ctx.drawImage(stage.srcCtx.canvas, fixed.l, 0, stage.stretchRect.w, fixed.t, fixed.l, 0, size.w - fixed.l - fixed.r, fixed.t);

    // Left
    if (fixed.l) ctx.drawImage(stage.srcCtx.canvas, 0, fixed.t, fixed.l, stage.stretchRect.h, 0, fixed.t, fixed.l, size.h - fixed.t - fixed.b);

    // Right
    if (fixed.r) ctx.drawImage(stage.srcCtx.canvas, stage.srcSize.w - fixed.r, fixed.t, fixed.r, stage.stretchRect.h, size.w - fixed.r, fixed.t, fixed.r, size.h - fixed.t - fixed.b);

    // Bottom
    if (fixed.b) ctx.drawImage(stage.srcCtx.canvas, fixed.l, stage.srcSize.h - fixed.b, stage.stretchRect.w, fixed.b, fixed.l, size.h - fixed.b, size.w - fixed.l - fixed.r, fixed.b);

    // Middle
    ctx.drawImage(stage.srcCtx.canvas, fixed.l, fixed.t, stage.stretchRect.w, stage.stretchRect.h, fixed.l, fixed.t, size.w - fixed.l - fixed.r, size.h - fixed.t - fixed.b);

    var rects = {
      stretchRect: {
        x: stage.stretchRect.x,
        y: stage.stretchRect.y,
        w: middle.w,
        h: middle.h
      },
      contentRect: {
        x: stage.contentRect.x,
        y: stage.contentRect.y,
        w: stage.contentRect.w + middle.w - stage.stretchRect.w,
        h: stage.contentRect.h + middle.h - stage.stretchRect.h
      },
      opticalBoundsRect: {
        x: stage.opticalBoundsRect.x,
        y: stage.opticalBoundsRect.y,
        w: stage.opticalBoundsRect.w + middle.w - stage.stretchRect.w,
        h: stage.opticalBoundsRect.h + middle.h - stage.stretchRect.h
      }
    };

    stage.name = stage.name + '-STRETCH_TRIMMED';
    stage.loadSourceImage(ctx, rects);
  },


  /**
   * Tries to automatically detect the given region.
   *
   * Region should be one of 'stretch', 'padding', or 'opticalbounds'
   */
  detectRegion: function detectRegion(stage, regionToFind) {
    if (!stage.srcCtx) {
      return null;
    }

    var srcData = stage.srcCtx.getImageData(0, 0, stage.srcSize.w, stage.srcSize.h);

    var x = void 0,
        y = void 0;

    // First find optical bounds
    // This works by taking an alpha value histogram and finding two maxima to determine
    // low and high alphas.
    var alphaHistogram = [];
    for (x = 0; x < stage.srcSize.w; x++) {
      for (y = 0; y < stage.srcSize.h; y++) {
        var _alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        alphaHistogram[_alpha] = alphaHistogram[_alpha] ? alphaHistogram[_alpha] + 1 : 1;
      }
    }

    var max1 = 0,
        max1Freq = 0,
        max2 = 0,
        max2Freq = 0;
    for (var i = 0; i < 256; i++) {
      if (alphaHistogram[i] > max1Freq) {
        max2 = max1;
        max2Freq = max1Freq;
        max1 = i;
        max1Freq = alphaHistogram[i];
      } else if (alphaHistogram[i] > max2Freq) {
        max2 = i;
        max2Freq = alphaHistogram[i];
      }
    }

    var alphaMin = max1 < max2 ? max1 : max2;
    var alphaMax = max1 > max2 ? max1 : max2;

    var ALPHA_THRESHOLD = 5;

    var opticalBoundsRect = { l: -1, r: -1, t: -1, b: -1 };

    // Find left optical bound
    obrLeft: for (x = 0; x < stage.srcSize.w; x++) {
      for (y = 0; y < stage.srcSize.h; y++) {
        var alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (alpha >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.l = x;
          break obrLeft;
        }
      }
    }
    // Find right optical bound
    obrRight: for (x = stage.srcSize.w - 1; x >= 0; x--) {
      for (y = 0; y < stage.srcSize.h; y++) {
        var alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (alpha >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.r = x;
          break obrRight;
        }
      }
    }
    // Find top optical bound
    obrTop: for (y = 0; y < stage.srcSize.h; y++) {
      for (x = 0; x < stage.srcSize.w; x++) {
        var alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (alpha >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.t = y;
          break obrTop;
        }
      }
    }
    // Find bottom optical bound
    obrBottom: for (y = stage.srcSize.h - 1; y >= 0; y--) {
      for (x = 0; x < stage.srcSize.w; x++) {
        var _alpha2 = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (_alpha2 >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.b = y;
          break obrBottom;
        }
      }
    }

    var returnRect = void 0;

    if (opticalBoundsRect.l >= 0 && opticalBoundsRect.r > opticalBoundsRect.l && opticalBoundsRect.t >= 0 && opticalBoundsRect.b > opticalBoundsRect.t) {
      var rect = {
        x: opticalBoundsRect.l,
        y: opticalBoundsRect.t,
        w: opticalBoundsRect.r - opticalBoundsRect.l + 1,
        h: opticalBoundsRect.b - opticalBoundsRect.t + 1
      };

      if (regionToFind == 'opticalbounds' || regionToFind == 'padding') {
        return rect;
      }
    }

    // Next find stretch regions. Only use them if they're within the optical bounds
    if (regionToFind == 'stretch') {
      var newStretchRect = Object.assign({}, stage.stretchRect);

      var summer = new _summer.Summer();
      var sums = [];
      for (y = 0; y < stage.srcSize.h; y++) {
        // Compute row
        summer.reset();
        for (var _x = 0; _x < stage.srcSize.w; _x++) {
          summer.addNext(getPixel_(stage, srcData, _x, y));
        }
        sums.push(summer.compute());
      }

      var ranges = getEqualRanges_(sums);
      for (var _i = 0; _i < ranges.length; _i++) {
        var range = ranges[_i];
        var passesThreshold = false;
        // Check if this row has a minimum alpha
        for (x = 0; x < stage.srcSize.w; x++) {
          var _alpha3 = srcData.data[(range.start * stage.srcSize.w + x) * 4 + 3];
          if (_alpha3 >= alphaMax - ALPHA_THRESHOLD) {
            passesThreshold = true;
            break;
          }
        }
        if (passesThreshold) {
          newStretchRect.y = range.start;
          newStretchRect.h = range.length;
          if (range.length >= 4) {
            // inset a bit to prevent scaling artifacts
            newStretchRect.y++;
            newStretchRect.h -= 2;
          }
          break;
        }
      }

      summer.reset();
      sums = [];
      for (x = 0; x < stage.srcSize.w; x++) {
        // Compute column
        summer.reset();
        for (y = 0; y < stage.srcSize.h; y++) {
          summer.addNext(getPixel_(stage, srcData, x, y));
        }
        sums.push(summer.compute());
      }

      ranges = getEqualRanges_(sums);
      for (var _i2 = 0; _i2 < ranges.length; _i2++) {
        var _range = ranges[_i2];
        var _passesThreshold = false;
        // Check if this column has a minimum alpha
        for (y = 0; y < stage.srcSize.h; y++) {
          var _alpha4 = srcData.data[(y * stage.srcSize.w + _range.start) * 4 + 3];
          if (_alpha4 >= alphaMax - ALPHA_THRESHOLD) {
            _passesThreshold = true;
            break;
          }
        }

        if (_passesThreshold) {
          newStretchRect.x = _range.start;
          newStretchRect.w = _range.length;
          if (_range.length >= 4) {
            // inset a bit to prevent scaling artifacts
            newStretchRect.x++;
            newStretchRect.w -= 2;
          }
          break;
        }
      }

      return newStretchRect;
    }

    return null;
  }
};

function getPixel_(stage, srcData, x, y) {
  return (srcData.data[(y * stage.srcSize.w + x) * 4 + 0] << 16) + ( // r
  srcData.data[(y * stage.srcSize.w + x) * 4 + 1] << 8) // g
  + (srcData.data[(y * stage.srcSize.w + x) * 4 + 2] << 0) // b
  + (srcData.data[(y * stage.srcSize.w + x) * 4 + 3] << 24); // a
}

function constrain_(size, rect) {
  if (rect.x < 0) {
    rect.w += rect.x;
    rect.x += -rect.x;
  }
  if (rect.x + rect.w > size.w) {
    rect.w = size.w - rect.x;
  }
  if (rect.y < 0) {
    rect.h += rect.y;
    rect.y += -rect.y;
  }
  if (rect.y + rect.h > size.h) {
    rect.h = size.h - rect.y;
  }
  return rect;
}

// Finds ranges of equal values within an array
function getEqualRanges_(arr) {
  var equalRanges = [];
  var start = -1;
  var startVal = 0;
  for (var i = 0; i < arr.length; i++) {
    if (start < 0) {
      start = i;
      startVal = arr[i];
    } else if (arr[i] != startVal) {
      if (start != i - 1) {
        equalRanges.push({ start: start, length: i - start });
      }

      start = i;
      startVal = arr[i];
    }
  }
  if (start != arr.length - 1) {
    equalRanges.push({ start: start, length: arr.length - start });
  }
  return equalRanges.sort(function (x, y) {
    return y.length - x.length;
  });
}

},{"../../imagelib":5,"./summer":17}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// http://en.wikipedia.org/wiki/Adler32
var MOD_ADLER = 65521;

var Adler32 = function () {
  function Adler32() {
    _classCallCheck(this, Adler32);

    this.reset();
  }

  _createClass(Adler32, [{
    key: "reset",
    value: function reset() {
      this._a = 1;
      this._b = 0;
      this._index = 0;
    }
  }, {
    key: "addNext",
    value: function addNext(value) {
      this._a = (this._a + value) % MOD_ADLER;
      this._b = (this._b + this._a) % MOD_ADLER;
    }
  }, {
    key: "compute",
    value: function compute() {
      return this._b << 16 | this._a;
    }
  }]);

  return Adler32;
}();

var Summer = exports.Summer = Adler32;

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotificationIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _basegenerator = require('./basegenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 1, y: 1, w: 22, h: 22 };

var NotificationIconGenerator = exports.NotificationIconGenerator = function (_BaseGenerator) {
  _inherits(NotificationIconGenerator, _BaseGenerator);

  function NotificationIconGenerator() {
    _classCallCheck(this, NotificationIconGenerator);

    return _possibleConstructorReturn(this, (NotificationIconGenerator.__proto__ || Object.getPrototypeOf(NotificationIconGenerator)).apply(this, arguments));
  }

  _createClass(NotificationIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(NotificationIconGenerator.prototype.__proto__ || Object.getPrototypeOf(NotificationIconGenerator.prototype), 'setupForm', this).call(this);
      $('.outputs-panel').attr('data-theme', 'dark');

      var nameField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 128, h: 128 },
          defaultValueClipart: 'ac_unit',
          dropTarget: document.body
        }), nameField = new _studio.studio.TextField('name', {
          newGroup: true,
          title: 'Name',
          helpText: 'Used when generating ZIP files.',
          defaultValue: 'ic_stat_example'
        })]
      });
      this.form.onChange(function (field) {
        var values = _this2.form.getValues();
        if ((!field || field.id_ == 'source') && values.source && values.source.name) {
          var name = 'ic_stat_' + _studio.studio.Util.sanitizeResourceName(values.source.name);
          if (name != nameField.getValue()) {
            nameField.setValue(name);
          }
        }

        _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, _studio.studio.Util.mult(TARGET_RECT, mult), { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: '#fff' }], outCtx, tmpCtx, iconSize);

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }]);

  return NotificationIconGenerator;
}(_basegenerator.BaseGenerator);

},{"../imagelib":5,"../studio":24,"./basegenerator":8}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RangeField = exports.BooleanField = exports.EnumField = exports.ColorField = exports.AutocompleteTextField = exports.TextField = exports.Field = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _tinycolor = require('tinycolor2');

var _tinycolor2 = _interopRequireDefault(_tinycolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents a form field and its associated UI elements. This should be
 * broken out into a more MVC-like architecture in the future.
 */
var Field = exports.Field = function () {
  /**
   * Instantiates a new field with the given ID and parameters.
   * @constructor
   */
  function Field(id, params) {
    _classCallCheck(this, Field);

    this.id_ = id;
    this.params_ = params;
    this.enabled_ = true;
  }

  /**
   * Sets the form owner of the field. Internally called by
   * {@link studio.forms.Form}.
   * @private
   * @param {studio.forms.Form} form The owner form.
   */


  _createClass(Field, [{
    key: 'setForm_',
    value: function setForm_(form) {
      this.form_ = form;
    }

    /**
     * Returns a complete ID.
     * @type String
     */

  }, {
    key: 'getLongId',
    value: function getLongId() {
      return this.form_.id_ + '-' + this.id_;
    }

    /**
     * Returns the ID for the form's UI element (or container).
     * @type String
     */

  }, {
    key: 'getHtmlId',
    value: function getHtmlId() {
      return '_frm-' + this.getLongId();
    }

    /**
     * Generates the UI elements for a form field container. Not very portable
     * outside the Asset Studio UI. Intended to be overriden by descendents.
     * @private
     * @param {HTMLElement} container The destination element to contain the
     * field.
     */

  }, {
    key: 'createUi',
    value: function createUi(container) {
      container = $(container);
      this.baseEl_ = $('<div>').addClass('form-field-outer').addClass(this.params_.newGroup ? 'is-new-group' : '').append($('<label>').attr('for', this.getHtmlId()).text(this.params_.title).append($('<div>').addClass('form-field-help-text').css('display', this.params_.helpText ? '' : 'none').html(this.params_.helpText))).append($('<div>').addClass('form-field-container')).appendTo(container);
      return this.baseEl_;
    }
  }, {
    key: 'getEnabled',
    value: function getEnabled() {
      return this.enabled_;
    }

    /**
     * Enables or disables the form field.
     */

  }, {
    key: 'setEnabled',
    value: function setEnabled(enabled) {
      this.enabled_ = enabled;
      if (this.baseEl_) {
        if (enabled) {
          this.baseEl_.removeAttr('disabled');
        } else {
          this.baseEl_.attr('disabled', 'disabled');
        }
      }
    }
  }]);

  return Field;
}();

var TextField = exports.TextField = function (_Field) {
  _inherits(TextField, _Field);

  function TextField() {
    _classCallCheck(this, TextField);

    return _possibleConstructorReturn(this, (TextField.__proto__ || Object.getPrototypeOf(TextField)).apply(this, arguments));
  }

  _createClass(TextField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldContainer = $('.form-field-container', _get(TextField.prototype.__proto__ || Object.getPrototypeOf(TextField.prototype), 'createUi', this).call(this, container));

      this.el_ = $('<input>').attr('type', 'text').attr('placeholder', this.params_.placeholder).addClass('form-field-text').val(this.getValue()).on('input', function (ev) {
        var oldVal = _this2.getValue();
        var newVal = $(ev.currentTarget).val();
        if (oldVal != newVal) {
          _this2.setValue(newVal, true);
        }
      }).appendTo(fieldContainer);
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = this.value_;
      if (typeof value != 'string') {
        value = this.params_.defaultValue || '';
      }
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      this.value_ = val;
      if (!pauseUi) {
        this.el_.val(val);
      }
      this.form_.notifyChanged_(this);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s);
    }
  }]);

  return TextField;
}(Field);

var AutocompleteTextField = exports.AutocompleteTextField = function (_Field2) {
  _inherits(AutocompleteTextField, _Field2);

  function AutocompleteTextField() {
    _classCallCheck(this, AutocompleteTextField);

    return _possibleConstructorReturn(this, (AutocompleteTextField.__proto__ || Object.getPrototypeOf(AutocompleteTextField)).apply(this, arguments));
  }

  _createClass(AutocompleteTextField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this4 = this;

      var fieldContainer = $('.form-field-container', _get(AutocompleteTextField.prototype.__proto__ || Object.getPrototypeOf(AutocompleteTextField.prototype), 'createUi', this).call(this, container));

      var datalistId = this.getHtmlId() + '-datalist';

      this.el_ = $('<input>').attr('type', 'text').attr('placeholder', this.params_.placeholder).addClass('form-field-text').attr('list', datalistId).val(this.getValue()).on('input', function (ev) {
        return _this4.setValue($(ev.currentTarget).val(), true);
      }).appendTo(fieldContainer);

      this.datalistEl_ = $('<datalist>').attr('id', datalistId).appendTo(fieldContainer);

      this.setOptions(this.params_.options);
    }
  }, {
    key: 'setOptions',
    value: function setOptions() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      this.datalistEl_.empty();
      options.forEach(function (option) {
        return _this5.datalistEl_.append($('<option>').attr('value', option));
      });
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = this.value_;
      if (typeof value != 'string') {
        value = this.params_.defaultValue || '';
      }
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      this.value_ = val;
      if (!pauseUi) {
        $(this.el_).val(val);
      }
      this.form_.notifyChanged_(this);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s);
    }
  }]);

  return AutocompleteTextField;
}(Field);

var ColorField = exports.ColorField = function (_Field3) {
  _inherits(ColorField, _Field3);

  function ColorField() {
    _classCallCheck(this, ColorField);

    return _possibleConstructorReturn(this, (ColorField.__proto__ || Object.getPrototypeOf(ColorField)).apply(this, arguments));
  }

  _createClass(ColorField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this7 = this;

      var fieldContainer = $('.form-field-container', _get(ColorField.prototype.__proto__ || Object.getPrototypeOf(ColorField.prototype), 'createUi', this).call(this, container));

      this.el_ = $('<input>').attr('type', 'text').attr('id', this.getHtmlId()).appendTo(fieldContainer);

      var update_ = function update_(color) {
        return _this7.setValue(color, true);
      };

      this.el_.spectrum({
        color: this.getValue().toRgbString(),
        showInput: true,
        showPalette: true,
        showAlpha: this.params_.alpha,
        preferredFormat: 'hex',
        palette: [['#ffffff', '#000000'], ['#f44336', '#e91e63'], ['#9c27b0', '#673ab7'], ['#3f51b5', '#2196f3'], ['#03a9f4', '#00bcd4'], ['#009688', '#4caf50'], ['#8bc34a', '#cddc39'], ['#ffeb3b', '#ffc107'], ['#ff9800', '#ff5722'], ['#9e9e9e', '#607d8b']],
        localStorageKey: 'recentcolors',
        showInitial: true,
        showButtons: false,
        change: update_,
        move: update_
      });
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.value_ || (0, _tinycolor2.default)(this.params_.defaultValue || '#000');
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      this.value_ = val.hasOwnProperty('_r') ? val : (0, _tinycolor2.default)(val || this.params_.defaultValue || '#000');
      if (!pauseUi) {
        this.el_.spectrum('set', this.value_.toRgbString());
      }
      this.form_.notifyChanged_(this);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue().toRgbString();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s);
    }
  }]);

  return ColorField;
}(Field);

var EnumField = exports.EnumField = function (_Field4) {
  _inherits(EnumField, _Field4);

  function EnumField() {
    _classCallCheck(this, EnumField);

    return _possibleConstructorReturn(this, (EnumField.__proto__ || Object.getPrototypeOf(EnumField)).apply(this, arguments));
  }

  _createClass(EnumField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this9 = this;

      var fieldContainer = $('.form-field-container', _get(EnumField.prototype.__proto__ || Object.getPrototypeOf(EnumField.prototype), 'createUi', this).call(this, container));

      if (this.params_.buttons) {
        this.el_ = $('<div>').attr('id', this.getHtmlId()).addClass('form-field-buttonset').appendTo(fieldContainer);
      } else {
        this.el_ = $('<div>').addClass('form-field-select').attr('id', this.getHtmlId()).appendTo(fieldContainer);

        this.selectEl_ = $('<select>').attr('id', this.getHtmlId()).on('input', function (ev) {
          return _this9.setValueInternal_($(ev.currentTarget).val(), true);
        }).appendTo(this.el_);
      }

      this.setOptions(this.params_.options);
    }
  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var _this10 = this;

      options = (options || []).map(function (option) {
        return typeof option == 'string' ? { id: option, title: String(option) } : option;
      });

      if (this.params_.buttons) {
        this.el_.empty();
        (options || []).forEach(function (option) {
          $('<input>').attr({
            type: 'radio',
            name: _this10.getHtmlId(),
            id: _this10.getHtmlId() + '-' + option.id,
            value: option.id
          }).on('change', function (ev) {
            return _this10.setValueInternal_($(ev.currentTarget).val(), false);
          }).appendTo(_this10.el_);
          $('<label>').attr('for', _this10.getHtmlId() + '-' + option.id).attr('tabindex', 0).html(option.title).appendTo(_this10.el_);
        });
      } else {
        this.selectEl_.empty();
        (options || []).forEach(function (option) {
          return $('<option>').attr('value', option.id).text(option.title).appendTo(_this10.selectEl_);
        });
      }

      this.setValueInternal_(this.getValue());
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = this.value_;
      if (value === undefined) {
        value = this.params_.defaultValue;
        if (value === undefined && this.params_.options && this.params_.options.length) {
          var firstOption = this.params_.options[0];
          value = 'id' in firstOption ? firstOption.id : String(firstOption);
        }
      }
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      this.setValueInternal_(val, pauseUi);
    }
  }, {
    key: 'setValueInternal_',
    value: function setValueInternal_(val, pauseUi) {
      // Note, this needs to be its own function because setValue gets
      // overridden in BooleanField and we need access to this method
      // from createUi.
      this.value_ = val;
      if (!pauseUi) {
        if (this.params_.buttons) {
          this.el_.find('input').each(function (i, el) {
            return $(el).prop('checked', $(el).val() == val);
          });
        } else {
          this.selectEl_.val(val);
        }
      }
      this.form_.notifyChanged_(this);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s);
    }
  }]);

  return EnumField;
}(Field);

var BooleanField = exports.BooleanField = function (_EnumField) {
  _inherits(BooleanField, _EnumField);

  function BooleanField(id, params) {
    _classCallCheck(this, BooleanField);

    var _this11 = _possibleConstructorReturn(this, (BooleanField.__proto__ || Object.getPrototypeOf(BooleanField)).call(this, id, params));

    params.options = [{ id: '1', title: params.onText || 'Yes' }, { id: '0', title: params.offText || 'No' }];
    params.defaultValue = params.defaultValue ? '1' : '0';
    params.buttons = true;
    return _this11;
  }

  _createClass(BooleanField, [{
    key: 'getValue',
    value: function getValue() {
      return _get(BooleanField.prototype.__proto__ || Object.getPrototypeOf(BooleanField.prototype), 'getValue', this).call(this) == '1';
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      _get(BooleanField.prototype.__proto__ || Object.getPrototypeOf(BooleanField.prototype), 'setValue', this).call(this, val ? '1' : '0', pauseUi);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue() ? '1' : '0';
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s == '1');
    }
  }]);

  return BooleanField;
}(EnumField);

var RangeField = exports.RangeField = function (_Field5) {
  _inherits(RangeField, _Field5);

  function RangeField() {
    _classCallCheck(this, RangeField);

    return _possibleConstructorReturn(this, (RangeField.__proto__ || Object.getPrototypeOf(RangeField)).apply(this, arguments));
  }

  _createClass(RangeField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this13 = this;

      var fieldContainer = $('.form-field-container', _get(RangeField.prototype.__proto__ || Object.getPrototypeOf(RangeField.prototype), 'createUi', this).call(this, container));
      var me = this;

      this.el_ = $('<div>').addClass('form-field-range').attr('id', this.getHtmlId()).appendTo(fieldContainer);

      this.rangeEl_ = $('<input>').attr('type', 'range').attr('min', this.params_.min || 0).attr('max', this.params_.max || 100).attr('step', this.params_.step || 1).on('input', function () {
        return _this13.setValue(Number(_this13.rangeEl_.val()) || 0, true);
      }).val(this.getValue()).appendTo(this.el_);

      if (this.params_.textFn || this.params_.showText) {
        this.params_.textFn = this.params_.textFn || function (d) {
          return d;
        };
        this.textEl_ = $('<div>').addClass('form-field-range-text').text(this.params_.textFn(this.getValue())).appendTo(this.el_);
      }
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = this.value_;
      if (typeof value != 'number') {
        value = this.params_.defaultValue;
        if (typeof value != 'number') value = 0;
      }
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      this.value_ = val;
      if (!pauseUi) {
        this.rangeEl_.val(val);
      }
      if (this.textEl_) {
        this.textEl_.text(this.params_.textFn(val));
      }
      this.form_.notifyChanged_(this);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(Number(s)); // don't use parseInt nor parseFloat
    }
  }]);

  return RangeField;
}(Field);

},{"tinycolor2":29}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Class defining a data entry form for use in the Asset Studio.
 */
var Form = exports.Form = function () {
  /**
   * Creates a new form with the given parameters.
   * @constructor
   * @param {Array} [params.inputs] A list of inputs
   */
  function Form(params) {
    var _this = this;

    _classCallCheck(this, Form);

    this.id_ = params.id;
    this.params_ = params;
    this.fields_ = params.fields;
    this.fields_.forEach(function (field) {
      return field.setForm_(_this);
    });
    this.fields_.forEach(function (field) {
      return field.createUi(params.container);
    });
  }

  /**
   * Adds an onchange listener.
   */


  _createClass(Form, [{
    key: "onChange",
    value: function onChange(listener) {
      this.changeListeners_ = (this.changeListeners_ || []).concat([listener]);
    }

    /**
     * Notifies that the form contents have changed;
     * @private
     */

  }, {
    key: "notifyChanged_",
    value: function notifyChanged_(field) {
      if (this.pauseNotify_) {
        return;
      }
      (this.changeListeners_ || []).forEach(function (listener) {
        return listener(field);
      });
    }

    /**
     * Returns the current values of the form fields, as an object.
     * @type Object
     */

  }, {
    key: "getValues",
    value: function getValues() {
      var values = {};
      this.fields_.forEach(function (field) {
        return values[field.id_] = field.getValue();
      });
      return values;
    }

    /**
     * Returns all available serialized values of the form fields, as an object.
     * All values in the returned object are either strings or objects.
     * @type Object
     */

  }, {
    key: "getValuesSerialized",
    value: function getValuesSerialized() {
      var values = {};
      this.fields_.forEach(function (field) {
        var value = field.serializeValue ? field.serializeValue() : undefined;
        if (value !== undefined) {
          values[field.id_] = field.serializeValue();
        }
      });

      return values;
    }

    /**
     * Sets the form field values for the key/value pairs in the given object.
     * Values must be serialized forms of the form values. The form must be
     * initialized before calling this method.
     */

  }, {
    key: "setValuesSerialized",
    value: function setValuesSerialized(serializedValues) {
      this.pauseNotify_ = true;
      this.fields_.filter(function (field) {
        return field.id_ in serializedValues && field.deserializeValue;
      }).forEach(function (field) {
        return field.deserializeValue(serializedValues[field.id_]);
      });
      this.pauseNotify_ = false;
      this.notifyChanged_(null);
    }
  }]);

  return Form;
}();

},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hash = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

var _util = require('./util');

var Hash = exports.Hash = {
  bindFormToDocumentHash: function bindFormToDocumentHash(form) {
    var _this = this;

    if (this.boundForm_) {
      console.error('already bound to a form');
      return;
    }

    this.boundForm_ = form;

    form.onChange(_util.Util.debounce(100, function () {
      _this.currentHash_ = paramsToHash_(form.getValuesSerialized());
      window.history.replaceState({}, '', '#' + _this.currentHash_);
    }));

    var maybeUpdateHash_ = function maybeUpdateHash_() {
      // Don't use document.location.hash because it automatically
      // resolves URI-escaped entities.
      var newHash = paramsToHash_(hashToParams_((document.location.href.match(/#.*/) || [''])[0]));
      if (newHash != _this.currentHash_) {
        form.setValuesSerialized(hashToParams_(newHash));
        _this.currentHash_ = newHash;
      }
    };

    $(window).on('hashchange', maybeUpdateHash_);

    maybeUpdateHash_();
  }
};

function hashToParams_(hash) {
  var params = {};
  hash = hash.replace(/^[?#]/, '');

  hash.split('&').forEach(function (entry) {
    var _entry$split = entry.split('=', 2),
        _entry$split2 = _slicedToArray(_entry$split, 2),
        path = _entry$split2[0],
        val = _entry$split2[1];

    path = decodeURIComponent(path || '');
    val = decodeURIComponent(val || '');

    // Most of the time path == key, but for objects like a.b=1, we need to
    // descend into the hierachy.
    var pathArr = path.split('.');
    var obj = params;
    pathArr.slice(0, -1).forEach(function (pathPart) {
      obj[pathPart] = obj[pathPart] || {};
      obj = obj[pathPart];
    });
    var key = pathArr[pathArr.length - 1];
    if (key in obj) {
      // Handle array values.
      if (Array.isArray(obj[key])) {
        obj[key].push(val);
      } else {
        obj[key] = [obj[key], val];
      }
    } else {
      obj[key] = val;
    }
  });

  return params;
}

function paramsToHash_(params, prefix) {
  var hashArr = [];
  var keyPath_ = function keyPath_(k) {
    return encodeURIComponent((prefix ? prefix + '.' : '') + k);
  };
  var pushKeyValue_ = function pushKeyValue_(k, v) {
    if (v === false) v = 0;
    if (v === true) v = 1;
    hashArr.push(keyPath_(k) + '=' + encodeURIComponent(v.toString()));
  };

  var _loop = function _loop(key) {
    var val = params[key];
    if (val === undefined || val === null) {
      return 'continue';
    }

    if (Array.isArray(val)) {
      val.forEach(function (v) {
        return pushKeyValue_(key, v);
      });
    } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object') {
      hashArr.push(paramsToHash_(val, keyPath_(key)));
    } else {
      pushKeyValue_(key, val);
    }
  };

  for (var key in params) {
    var _ret = _loop(key);

    if (_ret === 'continue') continue;
  }

  return hashArr.join('&');
}

},{"./util":25}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var clipartNames = exports.clipartNames = ['3d_rotation', 'ac_unit', 'access_alarm', 'access_alarms', 'access_time', 'accessibility', 'accessible', 'account_balance', 'account_balance_wallet', 'account_box', 'account_circle', 'adb', 'add', 'add_a_photo', 'add_alarm', 'add_alert', 'add_box', 'add_circle', 'add_circle_outline', 'add_location', 'add_shopping_cart', 'add_to_photos', 'add_to_queue', 'adjust', 'airline_seat_flat', 'airline_seat_flat_angled', 'airline_seat_individual_suite', 'airline_seat_legroom_extra', 'airline_seat_legroom_normal', 'airline_seat_legroom_reduced', 'airline_seat_recline_extra', 'airline_seat_recline_normal', 'airplanemode_active', 'airplanemode_inactive', 'airplay', 'airport_shuttle', 'alarm', 'alarm_add', 'alarm_off', 'alarm_on', 'album', 'all_inclusive', 'all_out', 'android', 'announcement', 'apps', 'archive', 'arrow_back', 'arrow_downward', 'arrow_drop_down', 'arrow_drop_down_circle', 'arrow_drop_up', 'arrow_forward', 'arrow_upward', 'art_track', 'aspect_ratio', 'assessment', 'assignment', 'assignment_ind', 'assignment_late', 'assignment_return', 'assignment_returned', 'assignment_turned_in', 'assistant', 'assistant_photo', 'attach_file', 'attach_money', 'attachment', 'audiotrack', 'autorenew', 'av_timer', 'backspace', 'backup', 'battery_alert', 'battery_charging_full', 'battery_full', 'battery_std', 'battery_unknown', 'beach_access', 'beenhere', 'block', 'bluetooth', 'bluetooth_audio', 'bluetooth_connected', 'bluetooth_disabled', 'bluetooth_searching', 'blur_circular', 'blur_linear', 'blur_off', 'blur_on', 'book', 'bookmark', 'bookmark_border', 'border_all', 'border_bottom', 'border_clear', 'border_color', 'border_horizontal', 'border_inner', 'border_left', 'border_outer', 'border_right', 'border_style', 'border_top', 'border_vertical', 'branding_watermark', 'brightness_1', 'brightness_2', 'brightness_3', 'brightness_4', 'brightness_5', 'brightness_6', 'brightness_7', 'brightness_auto', 'brightness_high', 'brightness_low', 'brightness_medium', 'broken_image', 'brush', 'bubble_chart', 'bug_report', 'build', 'burst_mode', 'business', 'business_center', 'cached', 'cake', 'call', 'call_end', 'call_made', 'call_merge', 'call_missed', 'call_missed_outgoing', 'call_received', 'call_split', 'call_to_action', 'camera', 'camera_alt', 'camera_enhance', 'camera_front', 'camera_rear', 'camera_roll', 'cancel', 'card_giftcard', 'card_membership', 'card_travel', 'casino', 'cast', 'cast_connected', 'center_focus_strong', 'center_focus_weak', 'change_history', 'chat', 'chat_bubble', 'chat_bubble_outline', 'check', 'check_box', 'check_box_outline_blank', 'check_circle', 'chevron_left', 'chevron_right', 'child_care', 'child_friendly', 'chrome_reader_mode', 'class', 'clear', 'clear_all', 'close', 'closed_caption', 'cloud', 'cloud_circle', 'cloud_done', 'cloud_download', 'cloud_off', 'cloud_queue', 'cloud_upload', 'code', 'collections', 'collections_bookmark', 'color_lens', 'colorize', 'comment', 'compare', 'compare_arrows', 'computer', 'confirmation_number', 'contact_mail', 'contact_phone', 'contacts', 'content_copy', 'content_cut', 'content_paste', 'control_point', 'control_point_duplicate', 'copyright', 'create', 'create_new_folder', 'credit_card', 'crop', 'crop_16_9', 'crop_3_2', 'crop_5_4', 'crop_7_5', 'crop_din', 'crop_free', 'crop_landscape', 'crop_original', 'crop_portrait', 'crop_rotate', 'crop_square', 'dashboard', 'data_usage', 'date_range', 'dehaze', 'delete', 'delete_forever', 'delete_sweep', 'description', 'desktop_mac', 'desktop_windows', 'details', 'developer_board', 'developer_mode', 'device_hub', 'devices', 'devices_other', 'dialer_sip', 'dialpad', 'directions', 'directions_bike', 'directions_boat', 'directions_bus', 'directions_car', 'directions_railway', 'directions_run', 'directions_subway', 'directions_transit', 'directions_walk', 'disc_full', 'dns', 'do_not_disturb', 'do_not_disturb_alt', 'do_not_disturb_off', 'do_not_disturb_on', 'dock', 'domain', 'done', 'done_all', 'donut_large', 'donut_small', 'drafts', 'drag_handle', 'drive_eta', 'dvr', 'edit', 'edit_location', 'eject', 'email', 'enhanced_encryption', 'equalizer', 'error', 'error_outline', 'euro_symbol', 'ev_station', 'event', 'event_available', 'event_busy', 'event_note', 'event_seat', 'exit_to_app', 'expand_less', 'expand_more', 'explicit', 'explore', 'exposure', 'exposure_neg_1', 'exposure_neg_2', 'exposure_plus_1', 'exposure_plus_2', 'exposure_zero', 'extension', 'face', 'fast_forward', 'fast_rewind', 'favorite', 'favorite_border', 'featured_play_list', 'featured_video', 'feedback', 'fiber_dvr', 'fiber_manual_record', 'fiber_new', 'fiber_pin', 'fiber_smart_record', 'file_download', 'file_upload', 'filter', 'filter_1', 'filter_2', 'filter_3', 'filter_4', 'filter_5', 'filter_6', 'filter_7', 'filter_8', 'filter_9', 'filter_9_plus', 'filter_b_and_w', 'filter_center_focus', 'filter_drama', 'filter_frames', 'filter_hdr', 'filter_list', 'filter_none', 'filter_tilt_shift', 'filter_vintage', 'find_in_page', 'find_replace', 'fingerprint', 'first_page', 'fitness_center', 'flag', 'flare', 'flash_auto', 'flash_off', 'flash_on', 'flight', 'flight_land', 'flight_takeoff', 'flip', 'flip_to_back', 'flip_to_front', 'folder', 'folder_open', 'folder_shared', 'folder_special', 'font_download', 'format_align_center', 'format_align_justify', 'format_align_left', 'format_align_right', 'format_bold', 'format_clear', 'format_color_fill', 'format_color_reset', 'format_color_text', 'format_indent_decrease', 'format_indent_increase', 'format_line_spacing', 'format_list_bulleted', 'format_list_numbered', 'format_paint', 'format_quote', 'format_shapes', 'format_size', 'format_strikethrough', 'format_textdirection_l_to_r', 'format_textdirection_r_to_l', 'format_underlined', 'forum', 'forward', 'forward_10', 'forward_30', 'forward_5', 'free_breakfast', 'fullscreen', 'fullscreen_exit', 'functions', 'g_translate', 'gamepad', 'games', 'gavel', 'gesture', 'get_app', 'gif', 'golf_course', 'gps_fixed', 'gps_not_fixed', 'gps_off', 'grade', 'gradient', 'grain', 'grid_off', 'grid_on', 'group', 'group_add', 'group_work', 'hd', 'hdr_off', 'hdr_on', 'hdr_strong', 'hdr_weak', 'headset', 'healing', 'hearing', 'help', 'help_outline', 'high_quality', 'highlight', 'highlight_off', 'history', 'home', 'hot_tub', 'hotel', 'hourglass_empty', 'hourglass_full', 'http', 'https', 'image', 'image_aspect_ratio', 'import_contacts', 'import_export', 'important_devices', 'inbox', 'indeterminate_check_box', 'info', 'info_outline', 'input', 'insert_chart', 'insert_comment', 'insert_drive_file', 'insert_emoticon', 'insert_invitation', 'insert_link', 'insert_photo', 'invert_colors', 'invert_colors_off', 'iso', 'keyboard', 'keyboard_arrow_down', 'keyboard_arrow_left', 'keyboard_arrow_right', 'keyboard_arrow_up', 'keyboard_backspace', 'keyboard_capslock', 'keyboard_hide', 'keyboard_return', 'keyboard_tab', 'keyboard_voice', 'kitchen', 'label', 'label_outline', 'landscape', 'language', 'laptop', 'laptop_chromebook', 'laptop_mac', 'laptop_windows', 'last_page', 'launch', 'layers', 'layers_clear', 'leak_add', 'leak_remove', 'lens', 'library_add', 'library_books', 'lightbulb_outline', 'line_style', 'line_weight', 'linear_scale', 'link', 'linked_camera', 'list', 'live_help', 'live_tv', 'local_activity', 'local_airport', 'local_atm', 'local_bar', 'local_cafe', 'local_car_wash', 'local_convenience_store', 'local_dining', 'local_drink', 'local_florist', 'local_gas_station', 'local_grocery_store', 'local_hospital', 'local_hotel', 'local_laundry_service', 'local_library', 'local_mall', 'local_movies', 'local_offer', 'local_parking', 'local_pharmacy', 'local_phone', 'local_pizza', 'local_play', 'local_post_office', 'local_printshop', 'local_see', 'local_shipping', 'local_taxi', 'location_city', 'location_disabled', 'location_off', 'location_on', 'location_searching', 'lock', 'lock_open', 'lock_outline', 'looks', 'looks_3', 'looks_4', 'looks_5', 'looks_6', 'looks_one', 'looks_two', 'loop', 'loupe', 'low_priority', 'loyalty', 'mail', 'mail_outline', 'map', 'markunread', 'markunread_mailbox', 'memory', 'menu', 'merge_type', 'message', 'mms', 'mode_comment', 'mode_edit', 'monetization_on', 'money_off', 'monochrome_photos', 'mood', 'mood_bad', 'more', 'more_horiz', 'more_vert', 'motorcycle', 'mouse', 'move_to_inbox', 'movie', 'movie_creation', 'movie_filter', 'multiline_chart', 'my_location', 'nature', 'nature_people', 'navigate_before', 'navigate_next', 'navigation', 'near_me', 'network_cell', 'network_check', 'network_locked', 'network_wifi', 'new_releases', 'next_week', 'nfc', 'no_encryption', 'no_sim', 'not_interested', 'note', 'note', 'note_add', 'notifications', 'notifications_active', 'notifications_none', 'notifications_off', 'notifications_paused', 'offline_pin', 'ondemand_video', 'opacity', 'open_in_browser', 'open_in_new', 'open_with', 'pages', 'pageview', 'palette', 'pan_tool', 'panorama', 'panorama_fish_eye', 'panorama_horizontal', 'panorama_vertical', 'panorama_wide_angle', 'party_mode', 'pause', 'pause_circle_filled', 'pause_circle_outline', 'payment', 'people', 'people_outline', 'perm_contact_calendar', 'perm_data_setting', 'perm_device_information', 'perm_identity', 'perm_media', 'perm_phone_msg', 'perm_scan_wifi', 'person', 'person_add', 'person_outline', 'person_pin', 'person_pin_circle', 'personal_video', 'pets', 'phone', 'phone_android', 'phone_bluetooth_speaker', 'phone_forwarded', 'phone_in_talk', 'phone_iphone', 'phone_locked', 'phone_missed', 'phone_paused', 'phonelink', 'phonelink_erase', 'phonelink_lock', 'phonelink_off', 'phonelink_ring', 'phonelink_setup', 'photo', 'photo_album', 'photo_camera', 'photo_filter', 'photo_library', 'photo_size_select_actual', 'photo_size_select_large', 'photo_size_select_small', 'picture_as_pdf', 'picture_in_picture', 'picture_in_picture_alt', 'pie_chart', 'pie_chart_outlined', 'pin_drop', 'place', 'play_arrow', 'play_circle_filled', 'play_circle_outline', 'play_for_work', 'playlist_add', 'playlist_add_check', 'playlist_play', 'plus_one', 'poll', 'polymer', 'pool', 'portable_wifi_off', 'portrait', 'power', 'power_input', 'power_settings_new', 'pregnant_woman', 'present_to_all', 'print', 'priority_high', 'publish', 'query_builder', 'question_answer', 'queue', 'queue_play_next', 'radio', 'radio_button_checked', 'radio_button_unchecked', 'rate_review', 'receipt', 'recent_actors', 'record_voice_over', 'redeem', 'redo', 'refresh', 'remove', 'remove_circle', 'remove_circle_outline', 'remove_from_queue', 'remove_red_eye', 'remove_shopping_cart', 'reorder', 'repeat', 'repeat_one', 'replay', 'replay_10', 'replay_30', 'replay_5', 'reply', 'reply_all', 'report', 'report_problem', 'restaurant', 'restaurant_menu', 'restore', 'restore_page', 'ring_volume', 'room', 'room_service', 'rotate_90_degrees_ccw', 'rotate_left', 'rotate_right', 'rounded_corner', 'router', 'rowing', 'rss_feed', 'rv_hookup', 'rv_hookup', 'satellite', 'save', 'scanner', 'schedule', 'school', 'screen_lock_landscape', 'screen_lock_portrait', 'screen_lock_rotation', 'screen_rotation', 'screen_share', 'sd_card', 'sd_storage', 'search', 'security', 'select_all', 'send', 'sentiment_dissatisfied', 'sentiment_neutral', 'sentiment_satisfied', 'sentiment_very_dissatisfied', 'sentiment_very_satisfied', 'settings', 'settings_applications', 'settings_backup_restore', 'settings_bluetooth', 'settings_brightness', 'settings_cell', 'settings_ethernet', 'settings_input_antenna', 'settings_input_component', 'settings_input_composite', 'settings_input_hdmi', 'settings_input_svideo', 'settings_overscan', 'settings_phone', 'settings_power', 'settings_remote', 'settings_system_daydream', 'settings_voice', 'share', 'shop', 'shop_two', 'shopping_basket', 'shopping_cart', 'short_text', 'show_chart', 'shuffle', 'signal_cellular_4_bar', 'signal_cellular_connected_no_internet_4_bar', 'signal_cellular_no_sim', 'signal_cellular_null', 'signal_cellular_off', 'signal_wifi_4_bar', 'signal_wifi_4_bar_lock', 'signal_wifi_off', 'sim_card', 'sim_card_alert', 'skip_next', 'skip_previous', 'slideshow', 'slow_motion_video', 'smartphone', 'smoke_free', 'smoking_rooms', 'sms', 'sms_failed', 'snooze', 'sort', 'sort_by_alpha', 'spa', 'space_bar', 'speaker', 'speaker_group', 'speaker_notes', 'speaker_notes_off', 'speaker_phone', 'spellcheck', 'star', 'star_border', 'star_half', 'stars', 'stay_current_landscape', 'stay_current_portrait', 'stay_primary_landscape', 'stay_primary_portrait', 'stop', 'stop_screen_share', 'storage', 'store', 'store_mall_directory', 'straighten', 'streetview', 'strikethrough_s', 'style', 'subdirectory_arrow_left', 'subdirectory_arrow_right', 'subject', 'subscriptions', 'subtitles', 'subway', 'supervisor_account', 'surround_sound', 'swap_calls', 'swap_horiz', 'swap_vert', 'swap_vertical_circle', 'switch_camera', 'switch_video', 'sync', 'sync_disabled', 'sync_problem', 'system_update', 'system_update_alt', 'tab', 'tab_unselected', 'tablet', 'tablet_android', 'tablet_mac', 'tag_faces', 'tap_and_play', 'terrain', 'text_fields', 'text_format', 'textsms', 'texture', 'theaters', 'thumb_down', 'thumb_up', 'thumbs_up_down', 'time_to_leave', 'timelapse', 'timeline', 'timer', 'timer_10', 'timer_3', 'timer_off', 'title', 'toc', 'today', 'toll', 'tonality', 'touch_app', 'toys', 'track_changes', 'train', 'tram', 'transfer_within_a_station', 'transform', 'translate', 'trending_down', 'trending_flat', 'trending_up', 'tune', 'turned_in', 'turned_in_not', 'tv', 'unarchive', 'undo', 'unfold_less', 'unfold_more', 'update', 'usb', 'verified_user', 'vertical_align_bottom', 'vertical_align_center', 'vertical_align_top', 'vibration', 'video_call', 'video_label', 'video_library', 'videocam', 'videocam_off', 'videogame_asset', 'view_agenda', 'view_array', 'view_carousel', 'view_column', 'view_comfy', 'view_compact', 'view_day', 'view_headline', 'view_list', 'view_module', 'view_quilt', 'view_stream', 'view_week', 'vignette', 'visibility', 'visibility_off', 'voice_chat', 'voicemail', 'volume_down', 'volume_mute', 'volume_off', 'volume_up', 'vpn_key', 'vpn_lock', 'wallpaper', 'warning', 'watch', 'watch_later', 'wb_auto', 'wb_cloudy', 'wb_incandescent', 'wb_iridescent', 'wb_sunny', 'wc', 'web', 'web_asset', 'weekend', 'whatshot', 'widgets', 'wifi', 'wifi_lock', 'wifi_tethering', 'work', 'wrap_text', 'youtube_searched_for', 'zoom_in', 'zoom_out', 'zoom_out_map'];

},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageField = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _webfontloader = require('webfontloader');

var _webfontloader2 = _interopRequireDefault(_webfontloader);

var _fields = require('./fields');

var _forms = require('./forms');

var _util = require('./util');

var _imagelib = require('../imagelib');

var _imagefieldClipart = require('./imagefield-clipart');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise; /*
                                                                                           * Copyright 2016 Google Inc.
                                                                                           *
                                                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                           * you may not use this file except in compliance with the License.
                                                                                           * You may obtain a copy of the License at
                                                                                           *
                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                           *
                                                                                           * Unless required by applicable law or agreed to in writing, software
                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                           * See the License for the specific language governing permissions and
                                                                                           * limitations under the License.
                                                                                           */

var WEB_FONTS_API_KEY = 'AIzaSyAtSe8wlXPCUaLQ4LTyPKpbzBBPJAzEXmU';
var WEB_FONTS_API_URL = 'https://www.googleapis.com/webfonts/v1/webfonts?key=' + WEB_FONTS_API_KEY + '&fields=items(family)';
var WEB_FONTS_CACHE_TIME = 60 * 60 * 1000; // 1 hour


/**
 * Represents a form field for image values.
 */

var ImageField = exports.ImageField = function (_Field) {
  _inherits(ImageField, _Field);

  function ImageField(id, params) {
    _classCallCheck(this, ImageField);

    var _this = _possibleConstructorReturn(this, (ImageField.__proto__ || Object.getPrototypeOf(ImageField)).call(this, id, params));

    _this.valueType_ = null;
    _this.textParams_ = {};
    _this.imageParams_ = {};
    _this.spaceFormValues_ = {}; // cache
    return _this;
  }

  _createClass(ImageField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldUI = _get(ImageField.prototype.__proto__ || Object.getPrototypeOf(ImageField.prototype), 'createUi', this).call(this, container);
      var fieldContainer = $('.form-field-container', fieldUI);

      // Set up drag+drop on the entire field container
      fieldUI.addClass('form-field-image');
      this.setupDropTarget_(fieldUI);

      // Create radio buttons
      this.el_ = $('<div>').attr('id', this.getHtmlId()).addClass('form-field-buttonset').appendTo(fieldContainer);

      var types;
      if (this.params_.imageOnly) {
        types = [['image', 'Select image']];
      } else {
        types = [['image', 'Image'], ['clipart', 'Clipart'], ['text', 'Text']];
      }

      var typeEls = {};

      types.forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            id = _ref2[0],
            label = _ref2[1];

        $('<input>').attr({
          type: 'radio',
          name: _this2.getHtmlId(),
          id: _this2.getHtmlId() + '-' + id,
          value: id
        }).appendTo(_this2.el_);
        typeEls[id] = $('<label>').attr('for', _this2.getHtmlId() + '-' + id).attr('tabindex', 0).text(label).appendTo(_this2.el_);
      });

      // Prepare UI for the 'image' type
      this.fileEl_ = $('<input>').addClass('form-image-hidden-file-field').attr({
        id: this.getHtmlId(),
        type: 'file',
        accept: 'image/*'
      }).on('change', function () {
        ImageField.loadImageFromFileList(_this2.fileEl_.get(0).files).then(function (ret) {
          if (!ret) {
            return;
          }

          _this2.setValueType_('image');
          _this2.imageParams_ = ret;
          _this2.valueFilename_ = ret.name.replace(/\.[^.]+?$/, ''); // basename
          _this2.renderValueAndNotifyChanged_();
        });
      }).appendTo(this.el_);

      typeEls.image.click(function (evt) {
        _this2.fileEl_.trigger('click');
        _this2.setValueType_(null);
        _this2.renderValueAndNotifyChanged_();
        evt.preventDefault();
        return false;
      });

      // Prepare UI for the 'clipart' type
      if (!this.params_.imageOnly) {
        var clipartAttributionEl;
        var textParamsEl;

        (function () {
          var clipartParamsEl = $('<div>').addClass('form-image-type-params form-image-type-params-clipart is-hidden').appendTo(fieldContainer);

          var clipartListEl = $('<div>').addClass('form-image-clipart-list').addClass('cancel-parent-scroll').appendTo(clipartParamsEl);

          _imagefieldClipart.clipartNames.forEach(function (clipartSrc) {
            $('<div>').addClass('form-image-clipart-item').attr('data-name', clipartSrc).attr('title', clipartSrc).text(clipartSrc).click(function () {
              return _this2.loadClipart_(clipartSrc);
            }).appendTo(clipartListEl);
          });

          _this2.$clipartItems = clipartListEl.find('.form-image-clipart-item');

          var clipartFilterEl = $('<input>').addClass('form-image-clipart-filter').attr('placeholder', 'Find clipart').on('input', function (ev) {
            var $filter = $(ev.currentTarget);
            var val = $filter.val().toLowerCase().replace(/[^\w]+/g, '');
            if (!val) {
              _this2.$clipartItems.show();
            } else {
              _this2.$clipartItems.each(function (_, item) {
                $(item).toggle($(item).attr('title').indexOf(val) >= 0);
              });
            }
          }).prependTo(clipartParamsEl);

          clipartAttributionEl = $('<div>').addClass('form-image-clipart-attribution').html('\n              For clipart sources, visit\n              <a target="_blank"\n                 class="external-link"\n                 href="https://github.com/google/material-design-icons">\n              Material Design Icons on GitHub</a>\n              ').appendTo(clipartParamsEl);


          typeEls.clipart.click(function (evt) {
            _this2.setValueType_('clipart');
            _this2.renderValueAndNotifyChanged_();
          });

          // Prepare UI for the 'text' type
          textParamsEl = $('<div>').addClass('form-subform form-image-type-params form-image-type-params-text is-hidden').appendTo(fieldContainer);


          var fontFamilyField = void 0;
          _this2.textForm_ = new _forms.Form({
            id: _this2.form_.id_ + '-' + _this2.id_ + '-textform',
            container: textParamsEl,
            fields: [new _fields.TextField('text', {
              title: 'Text'
            }), fontFamilyField = new _fields.EnumField('font', {
              title: 'Font',
              helpText: 'From fonts.google.com'
            })]
          });
          _this2.loadGoogleWebFontsList_().then(function (fonts) {
            return fontFamilyField.setOptions([''].concat(fonts));
          });

          var tryLoadWebFontDebounced_ = _util.Util.debounce(500, function () {
            return _this2.tryLoadWebFont_();
          });
          _this2.textForm_.onChange(function () {
            var values = _this2.textForm_.getValues();
            _this2.textParams_.text = values['text'];
            _this2.textParams_.fontStack = values['font'] ? values['font'] : 'Roboto, sans-serif';
            _this2.valueFilename_ = values['text'];
            tryLoadWebFontDebounced_();
            _this2.renderValueAndNotifyChanged_();
          });

          typeEls.text.click(function (evt) {
            _this2.setValueType_('text');
            _this2.renderValueAndNotifyChanged_();
          });
        })();
      }

      // Create spacing subform
      if (!this.params_.noTrimForm) {
        var spaceFormContainer = $('<div>').addClass('form-subform').appendTo(fieldContainer);
        this.spaceFormValues_ = {};
        this.spaceForm_ = new _forms.Form({
          id: this.form_.id_ + '-' + this.id_ + '-spaceform',
          container: spaceFormContainer,
          fields: [this.spaceFormTrimField_ = new _fields.BooleanField('trim', {
            title: 'Trim whitespace',
            defaultValue: true,
            offText: 'Don\'t trim',
            onText: 'Trim'
          }), this.spaceFormPaddingField_ = new _fields.RangeField('pad', {
            title: 'Padding',
            defaultValue: this.params_.defaultValuePadding || 0,
            min: -0.1,
            max: 0.5, // 1/2 of min(width, height)
            step: 0.05,
            textFn: function textFn(v) {
              return (v * 100).toFixed(0) + '%';
            }
          })]
        });
        this.spaceForm_.onChange(function () {
          _this2.spaceFormValues_ = _this2.spaceForm_.getValues();
          _this2.renderValueAndNotifyChanged_();
        });
        this.spaceFormValues_ = this.spaceForm_.getValues();
      } else {
        this.spaceFormValues_ = {};
      }

      // Create image preview element
      if (!this.params_.noPreview) {
        this.imagePreview_ = $('<canvas>').addClass('form-image-preview').hide().appendTo(fieldContainer.parent());
      }

      if (this.params_.defaultValueClipart) {
        setTimeout(function () {
          if (!_this2.valueType_) {
            _this2.loadClipart_(_this2.params_.defaultValueClipart);
          }
        }, 0);
      }
    }
  }, {
    key: 'setupDropTarget_',
    value: function setupDropTarget_(el) {
      var _this3 = this;

      var $el = this.params_.dropTarget ? $(this.params_.dropTarget) : $(el);
      var enterLeaveTimeout = void 0;

      $el.addClass('form-field-drop-target').on('dragenter', function (ev) {
        ev.preventDefault();
        if (enterLeaveTimeout) {
          clearTimeout(enterLeaveTimeout);
          enterLeaveTimeout = null;
        }
        $el.addClass('drag-hover');
      }).on('dragleave', function (ev) {
        ev.preventDefault();
        if (enterLeaveTimeout) {
          clearTimeout(enterLeaveTimeout);
        }
        enterLeaveTimeout = setTimeout(function () {
          return $el.removeClass('drag-hover');
        }, 100);
      }).on('dragover', function (ev) {
        ev.preventDefault();
        if (enterLeaveTimeout) {
          clearTimeout(enterLeaveTimeout);
          enterLeaveTimeout = null;
        }
        ev.originalEvent.dataTransfer.dropEffect = 'copy';
      }).on('drop', function (ev) {
        $el.removeClass('drag-hover');
        ev.stopPropagation();
        ev.preventDefault();
        ImageField.loadImageFromFileList(ev.originalEvent.dataTransfer.files).then(function (ret) {
          if (!ret) {
            return;
          }

          _this3.setValueType_('image');
          _this3.imageParams_ = ret;
          _this3.valueFilename_ = ret.name;
          _this3.renderValueAndNotifyChanged_();
        });
      });
    }
  }, {
    key: 'loadGoogleWebFontsList_',
    value: function loadGoogleWebFontsList_() {
      return new _Promise(function (resolve, reject) {
        if ('assetStudioWebFontsCache' in localStorage) {
          var _JSON$parse = JSON.parse(localStorage.assetStudioWebFontsCache),
              fetchTime = _JSON$parse.fetchTime,
              fonts = _JSON$parse.fonts;

          if (Number(new Date()) - fetchTime < WEB_FONTS_CACHE_TIME) {
            // use cache
            resolve(fonts);
            return;
          }
        }

        $.ajax({
          url: WEB_FONTS_API_URL,
          dataType: 'json'
        }).then(function (data) {
          var fonts = data.items.map(function (item) {
            return item.family;
          });
          localStorage.assetStudioWebFontsCache = JSON.stringify({
            fetchTime: Number(new Date()),
            fonts: fonts
          });
          resolve(fonts);
        }, function (e) {
          return reject(e);
        });
      });
    }
  }, {
    key: 'tryLoadWebFont_',
    value: function tryLoadWebFont_() {
      var _this4 = this;

      var desiredFont = this.textForm_.getValues().font;
      if (this.loadedWebFont_ == desiredFont || !desiredFont) {
        return;
      }

      _webfontloader2.default.load({
        google: {
          families: [desiredFont]
        },
        active: function active() {
          _this4.loadedWebFont_ = desiredFont;
          _this4.renderValueAndNotifyChanged_();
        }
      });
    }
  }, {
    key: 'setValueType_',
    value: function setValueType_(type) {
      this.valueType_ = type;
      $('input', this.el_).prop('checked', false);
      $('.form-image-type-params', this.el_.parent()).addClass('is-hidden');
      if (type) {
        $('#' + this.getHtmlId() + '-' + type).prop('checked', true);
        $('.form-image-type-params-' + type, this.el_.parent()).removeClass('is-hidden');
      }

      if (this.spaceForm_) {
        this.spaceFormTrimField_.setEnabled(true);
        this.spaceFormPaddingField_.setEnabled(true);
        if (type == 'clipart') {
          if (this.params_.clipartNoTrimPadding) {
            this.spaceFormTrimField_.setEnabled(false);
            this.spaceFormTrimField_.setValue(false);
            this.spaceFormPaddingField_.setEnabled(false);
            this.spaceFormPaddingField_.setValue(0);
          }
        } else if (type == 'text') {
          this.spaceFormTrimField_.setEnabled(false);
          this.spaceFormTrimField_.setValue(true);
        }
      }
    }
  }, {
    key: 'loadClipart_',
    value: function loadClipart_(clipartSrc) {
      this.$clipartItems.removeClass('is-selected');
      this.$clipartItems.filter('[data-name="' + clipartSrc + '"]').addClass('is-selected');

      this.setValueType_('clipart');
      this.clipartSrc_ = clipartSrc;
      this.valueFilename_ = clipartSrc;
      this.renderValueAndNotifyChanged_();
    }
  }, {
    key: 'clearValue',
    value: function clearValue() {
      this.valueType_ = null;
      this.valueFilename_ = null;
      this.valueCtx_ = null;
      this.valueOrigImg_ = null;
      this.fileEl_.val('');
      if (this.imagePreview_) {
        this.imagePreview_.hide();
      }
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return {
        ctx: this.valueCtx_,
        origImg: this.valueOrigImg_,
        type: this.valueType_,
        name: this.valueFilename_
      };
    }

    // this function is asynchronous

  }, {
    key: 'renderValueAndNotifyChanged_',
    value: function renderValueAndNotifyChanged_() {
      var _this5 = this;

      if (!this.valueType_) {
        this.valueCtx_ = null;
        this.valueOrigImg_ = null;
        return;
      }

      if (this.renderTimeout_) {
        clearTimeout(this.renderTimeout_);
        this.renderTimeout_ = null;
      }

      if (this.rendering_) {
        this.renderTimeout_ = setTimeout(function () {
          return _this5.renderValueAndNotifyChanged_();
        }, 100);
        return;
      }

      this.rendering_ = true;

      this.renderSource_().then(function (_ref3) {
        var ctx = _ref3.ctx,
            size = _ref3.size;

        _this5.computeTrimRect_(ctx, size).then(function (trimRect) {
          var pad = _this5.spaceFormValues_.pad || 0;
          var padPx = Math.round(pad * Math.min(trimRect.w, trimRect.h));
          _this5.valueCtx_ = _imagelib.imagelib.Drawing.context({
            w: trimRect.w + padPx * 2,
            h: trimRect.h + padPx * 2
          });
          _this5.valueCtx_.drawImage(ctx.canvas, trimRect.x, trimRect.y, trimRect.w, trimRect.h, padPx, padPx, trimRect.w, trimRect.h);

          if (_this5.imagePreview_) {
            _this5.imagePreview_.attr({
              width: _this5.valueCtx_.canvas.width,
              height: _this5.valueCtx_.canvas.height
            });

            var previewCtx = _this5.imagePreview_.get(0).getContext('2d');
            previewCtx.drawImage(_this5.valueCtx_.canvas, 0, 0);
            _this5.imagePreview_.show();
          }

          _this5.rendering_ = false;
          _this5.form_.notifyChanged_(_this5);
        });
      }).catch(function (e) {
        console.error('Error: ' + e);
        _this5.rendering_ = false;
      });
    }
  }, {
    key: 'renderSource_',
    value: function renderSource_() {
      var _this6 = this;

      return new _Promise(function (resolve, reject) {
        // Render the base image (text, clipart, or image)
        switch (_this6.valueType_) {
          case 'image':
            // case 'clipart':
            if (_this6.imageParams_.uri) {
              _util.Util.loadImageFromUri(_this6.imageParams_.uri).then(function (img) {
                _this6.valueOrigImg_ = img;
                var size = {
                  w: img.naturalWidth,
                  h: img.naturalHeight
                };
                if (_this6.imageParams_.isSvg && _this6.params_.maxFinalSize) {
                  size = {
                    w: _this6.params_.maxFinalSize.w,
                    h: _this6.params_.maxFinalSize.h
                  };
                }
                var ctx = _imagelib.imagelib.Drawing.context(size);
                _imagelib.imagelib.Drawing.copy(ctx, img, size);
                resolve({ ctx: ctx, size: size });
              });
            } else {
              reject('no uri');
            }
            break;

          case 'clipart':
            var size = { w: 1536, h: 1536 };
            var ctx = _imagelib.imagelib.Drawing.context(size);
            var text = _this6.clipartSrc_;

            ctx.fillStyle = '#000';
            ctx.font = size.h + 'px/' + size.h + 'px \'Material Icons\'';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(text, 0, size.h);

            resolve({ ctx: ctx, size: size });
            break;

          case 'text':
            var size = { w: 6144, h: 1536 };
            var textHeight = size.h * 0.75;
            var ctx = _imagelib.imagelib.Drawing.context(size);
            var text = _this6.textParams_.text || '';
            text = ' ' + text + ' ';

            ctx.fillStyle = '#000';
            ctx.font = 'bold ' + textHeight + 'px/' + size.h + 'px ' + _this6.textParams_.fontStack;
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(text, 0, textHeight);
            size.w = Math.ceil(Math.min(ctx.measureText(text).width, size.w) || size.w);

            resolve({ ctx: ctx, size: size });
            break;

          default:
            reject('No value type');
        }
      });
    }
  }, {
    key: 'computeTrimRect_',
    value: function computeTrimRect_(ctx, size) {
      var _this7 = this;

      return new _Promise(function (resolve, reject) {
        if (_this7.spaceFormValues_.trim) {
          if (_this7.trimPromise_ && _this7.trimPromise_.worker) {
            _this7.trimPromise_.worker.terminate();
          }

          _this7.trimPromise_ = _imagelib.imagelib.Analysis.getTrimRect(ctx, size, 1).then(function (trimRect) {
            var pad = Math.min(size.w, size.h) * .01;
            // pad a little bit to avoid edge artifacts
            Object.assign(trimRect, {
              x: Math.max(Math.floor(trimRect.x - pad), 0),
              y: Math.max(Math.floor(trimRect.y - pad), 0),
              w: Math.ceil(trimRect.w + pad * 2),
              h: Math.ceil(trimRect.h + pad * 2)
            });
            trimRect.w = Math.min(trimRect.w, size.w - trimRect.x);
            trimRect.h = Math.min(trimRect.h, size.h - trimRect.y);
            resolve(trimRect);
          }).catch(reject);
        } else {
          resolve({ x: 0, y: 0, w: size.w, h: size.h });
        }
      });
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      var vals = {
        type: this.valueType_,
        clipart: this.valueType_ == 'clipart' ? this.clipartSrc_ : null,
        text: this.valueType_ == 'text' ? this.textForm_.getValuesSerialized() : null
      };

      if (this.spaceForm_) {
        vals.space = this.spaceForm_.getValuesSerialized();
      }

      return vals;
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(o) {
      if (o.type) {
        this.setValueType_(o.type);
      }
      if (o.space) {
        this.spaceForm_.setValuesSerialized(o.space);
        this.spaceFormValues_ = this.spaceForm_.getValues();
      }
      if (o.clipart && this.valueType_ == 'clipart') {
        this.loadClipart_(o.clipart);
      }
      if (o.text && this.valueType_ == 'text') {
        this.textForm_.setValuesSerialized(o.text);
        this.tryLoadWebFont_();
      }
    }
  }]);

  return ImageField;
}(_fields.Field);

/**
 * Loads the first valid image from a FileList (e.g. drag + drop source), as a data URI. This method
 * will throw an alert() in case of errors and call back with null.
 * @param {FileList} fileList The FileList to load.
 * @return Returns a promise, with object containing 'uri' field representing
 *      the loaded image. There will also be a 'name' field indicating the file name, if one
 *      is available.
 */


ImageField.loadImageFromFileList = function (fileList) {
  return new _Promise(function (resolve, reject) {
    fileList = fileList || [];

    var file = Array.from(fileList).find(function (file) {
      return ImageField.isValidFile_(file);
    });

    if (!file) {
      alert('Please choose a valid image file (PNG, JPG, GIF, SVG, etc.)');
      resolve(null);
      return;
    }

    var isSvg = file.type == 'image/svg+xml';

    var fileReader = new FileReader();

    // Closure to capture the file information.
    fileReader.onload = function (e) {
      return resolve({
        isSvg: isSvg,
        uri: e.target.result,
        name: file.name
      });
    };

    fileReader.onerror = function (e) {
      switch (e.target.error.code) {
        case e.target.error.NOT_FOUND_ERR:
          alert('File not found!');
          break;

        case e.target.error.NOT_READABLE_ERR:
          alert('File is not readable');
          break;

        case e.target.error.ABORT_ERR:
          break; // noop

        default:
          alert('An error occurred reading this file.');
      }

      resolve(null);
    };

    fileReader.onabort = function (e) {
      alert('File read cancelled');
      resolve(null);
    };

    fileReader.readAsDataURL(file);
  });
};

ImageField.isValidFile_ = function (file) {
  return !!file.type.toLowerCase().match(/^image\//);
};

// Prevent scrolling for clipart per http://stackoverflow.com/questions/7600454
$(document).ready(function () {
  $('.cancel-parent-scroll').on('mousewheel DOMMouseScroll', function (e) {
    var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail;
    e.currentTarget.scrollTop -= delta;
    e.preventDefault();
  });
});

},{"../imagelib":5,"./fields":19,"./forms":20,"./imagefield-clipart":22,"./util":25,"es6-promise":27,"webfontloader":30}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.studio = undefined;

var _forms = require('./forms');

var _fields = require('./fields');

var _imagefield = require('./imagefield');

var _hash = require('./hash');

var _util = require('./util');

var _zip = require('./zip');

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var studio = exports.studio = {
  AutocompleteTextField: _fields.AutocompleteTextField,
  BooleanField: _fields.BooleanField,
  ColorField: _fields.ColorField,
  EnumField: _fields.EnumField,
  Field: _fields.Field,
  Form: _forms.Form,
  Hash: _hash.Hash,
  ImageField: _imagefield.ImageField,
  RangeField: _fields.RangeField,
  TextField: _fields.TextField,
  Util: _util.Util,
  Zip: _zip.Zip
};

},{"./fields":19,"./forms":20,"./hash":21,"./imagefield":23,"./util":25,"./zip":26}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = exports.Util = {
  getMultBaseMdpi: function getMultBaseMdpi(density) {
    switch (density) {
      case 'xxxhdpi':
        return 4.00;
      case 'xxhdpi':
        return 3.00;
      case 'xhdpi':
        return 2.00;
      case 'hdpi':
        return 1.50;
      case 'tvdpi':
        return 1.33125;
      case 'mdpi':
        return 1.00;
      case 'ldpi':
        return 0.75;
    }
    return 1.0;
  },
  getDpiForDensity: function getDpiForDensity(density) {
    switch (density) {
      case 'xxxhdpi':
        return 640;
      case 'xxhdpi':
        return 480;
      case 'xhdpi':
        return 320;
      case 'hdpi':
        return 240;
      case 'tvdpi':
        return 213;
      case 'mdpi':
        return 160;
      case 'ldpi':
        return 120;
    }
    return 160;
  },
  mult: function mult(s, _mult) {
    var d = {};
    for (var k in s) {
      d[k] = s[k] * _mult;
    }
    return d;
  },
  multRound: function multRound(s, mult) {
    var d = {};
    for (var k in s) {
      d[k] = Math.round(s[k] * mult);
    }
    return d;
  },
  sanitizeResourceName: function sanitizeResourceName(s) {
    return s.toLowerCase().replace(/[\s-\.]/g, '_').replace(/[^\w_]/g, '');
  },


  // TODO: support Safari
  downloadFile: function downloadFile(content, filename) {
    var anchor = $('<a>').hide().appendTo(document.body);
    var blob = content;
    if (!(content instanceof Blob)) {
      blob = new Blob([content], { type: 'application/octet-stream' });
    }
    var url = window.URL.createObjectURL(blob);
    anchor.attr({
      href: url,
      download: filename
    });
    anchor.get(0).click();
    setTimeout(function () {
      anchor.remove();
      window.URL.revokeObjectURL(url);
    }, 5000);
  },
  loadImageFromUri: function loadImageFromUri(uri) {
    return new _Promise(function (resolve, reject) {
      var img = document.createElement('img');
      img.onload = function () {
        return resolve(img);
      };
      img.onerror = function () {
        return reject();
      };
      img.src = uri;
    });
  },
  debugCtx: function debugCtx(ctx) {
    if (Util.debugCtx.$lastEl) {
      Util.debugCtx.$lastEl.remove();
    }

    Util.debugCtx.$lastEl = $('<img>').css({
      position: 'fixed',
      top: 0,
      right: 0,
      zIndex: 100,
      backgroundColor: 'rgba(255, 0, 0, 0.5)',
      pointerEvents: 'none'
    }).attr('src', ctx.canvas.toDataURL()).appendTo(document.body);
  },
  debounce: function debounce(delay, fn) {
    var timeout = void 0;

    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(function () {
        fn.apply(undefined, args);
        timeout = null;
      }, delay);
    };
  }
};

},{"es6-promise":27}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Zip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _zipjsBrowserify = require('zipjs-browserify');

var _zipjsBrowserify2 = _interopRequireDefault(_zipjsBrowserify);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var URL = window.URL || window.webkitURL || window.mozURL;

var Zip = exports.Zip = {
  createDownloadifyZipButton: function createDownloadifyZipButton(element, options) {
    return new DownloadZipButton(element, options);
  }
};

var DownloadZipButton = function () {
  function DownloadZipButton(element, options) {
    var _this = this;

    _classCallCheck(this, DownloadZipButton);

    this.fileSpecs_ = [];
    this.el_ = element;
    this.el_.click(function () {
      return _this.generateAndDownloadZipFile_();
    });
    this.updateUI_();
  }

  _createClass(DownloadZipButton, [{
    key: 'setZipFilename',
    value: function setZipFilename(zipFilename) {
      this.zipFilename_ = zipFilename;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.fileSpecs_ = [];
      this.updateUI_();
    }
  }, {
    key: 'add',
    value: function add(spec) {
      this.fileSpecs_.push(spec);
      this.updateUI_();
    }
  }, {
    key: 'updateUI_',
    value: function updateUI_() {
      if (this.fileSpecs_.length && !this.generating_) {
        this.el_.removeAttr('disabled');
      } else {
        this.el_.attr('disabled', 'disabled');
      }
    }
  }, {
    key: 'generateAndDownloadZipFile_',
    value: function generateAndDownloadZipFile_() {
      var _this2 = this;

      var filename = this.zipFilename_ || 'output.zip';
      if (!this.fileSpecs_.length) {
        return;
      }

      this.isGenerating_ = true;
      this.updateUI_();

      _zipjsBrowserify2.default.createWriter(new _zipjsBrowserify2.default.BlobWriter(), function (writer) {
        var i = -1;
        var nextFile_ = function nextFile_() {
          ++i;
          if (i >= _this2.fileSpecs_.length) {
            // close
            writer.close(function (blob) {
              return _util.Util.downloadFile(blob, filename);
            });
            _this2.isGenerating_ = false;
            _this2.updateUI_();
          } else {
            // add next file
            var fileSpec = _this2.fileSpecs_[i];
            writer.add(fileSpec.name, fileSpec.canvas ? new _zipjsBrowserify2.default.Data64URIReader(fileSpec.canvas.toDataURL()) : new _zipjsBrowserify2.default.TextReader(fileSpec.textData), nextFile_);
          }
        };
        nextFile_();
      }, function (error) {
        console.error(error);
        _this2.isGenerating_ = false;
        _this2.updateUI_();
      });
    }
  }]);

  return DownloadZipButton;
}();

},{"./util":25,"zipjs-browserify":31}],27:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.0.5
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":28}],28:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],29:[function(require,module,exports){
// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);

},{}],30:[function(require,module,exports){
/* Web Font Loader v1.6.27 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.m=b||a;this.c=this.m.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function z(a){if("string"===typeof a.f)return a.f;var b=a.m.location.protocol;"about:"==b&&(b=a.a.location.protocol);return"https:"==b?"https:":"http:"}function ea(a){return a.m.location.hostname||a.a.location.hostname}
function A(a,b,c){function d(){k&&e&&f&&(k(g),k=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,k=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function B(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function C(){this.a=0;this.c=null}function D(a){a.a++;return function(){a.a--;E(a)}}function F(a,b){a.c=b;E(a)}function E(a){0==a.a&&a.c&&(a.c(),a.c=null)};function G(a){this.a=a||"-"}G.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function H(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return I(a)+" "+(a.f+"00")+" 300px "+J(a.c)}function J(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function K(a){return a.a+a.f}function I(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.m.document.documentElement;this.h=b;this.a=new G("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);L(a,"loading")}function M(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}L(a,"inactive")}function L(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,K(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function N(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function O(a){u(a.c,"body",a.a)}function P(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+J(a.c)+";"+("font-style:"+I(a)+";font-weight:"+(a.f+"00")+";")};function Q(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}Q.prototype.start=function(){var a=this.c.m.document,b=this,c=q(),d=new Promise(function(d,e){function k(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(k,25)},function(){e()})}k()}),e=new Promise(function(a,d){setTimeout(d,b.f)});Promise.race([e,d]).then(function(){b.g(b.a)},function(){b.j(b.a)})};function R(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.o=this.j=this.h=this.g=null;this.g=new N(this.c,this.s);this.h=new N(this.c,this.s);this.j=new N(this.c,this.s);this.o=new N(this.c,this.s);a=new H(this.a.c+",serif",K(this.a));a=P(a);this.g.a.style.cssText=a;a=new H(this.a.c+",sans-serif",K(this.a));a=P(a);this.h.a.style.cssText=a;a=new H("serif",K(this.a));a=P(a);this.j.a.style.cssText=a;a=new H("sans-serif",K(this.a));a=
P(a);this.o.a.style.cssText=a;O(this.g);O(this.h);O(this.j);O(this.o)}var S={D:"serif",C:"sans-serif"},T=null;function U(){if(null===T){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);T=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return T}R.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.o.a.offsetWidth;this.A=q();la(this)};
function ma(a,b,c){for(var d in S)if(S.hasOwnProperty(d)&&b===a.f[S[d]]&&c===a.f[S[d]])return!0;return!1}function la(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=U()&&ma(a,b,c));d?q()-a.A>=a.w?U()&&ma(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):na(a):V(a,a.v)}function na(a){setTimeout(p(function(){la(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.o.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.o=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,K(a).toString(),"active")],[b.a.c("wf",a.c,K(a).toString(),"loading"),b.a.c("wf",a.c,K(a).toString(),"inactive")]);L(b,"fontactive",a);this.o=!0;oa(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,K(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,K(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,K(a).toString(),"inactive"));w(b.f,d,e)}L(b,"fontinactive",a);oa(this)};function oa(a){0==--a.f&&a.j&&(a.o?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),L(a,"active")):M(a.a))};function pa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}pa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;qa(this,new ha(this.c,a),a)};
function ra(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,k=d||null||{};if(0===c.length&&f)M(b.a);else{b.f+=c.length;f&&(b.j=f);var h,m=[];for(h=0;h<c.length;h++){var l=c[h],n=k[l.c],r=b.a,x=l;r.g&&w(r.f,[r.a.c("wf",x.c,K(x).toString(),"loading")]);L(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),ya=/OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);
X=x?42<parseInt(x[1],10):ya?!1:!0}else X=!1;X?r=new Q(p(b.g,b),p(b.h,b),b.c,l,b.s,n):r=new R(p(b.g,b),p(b.h,b),b.c,l,b.s,a,n);m.push(r)}for(h=0;h<m.length;h++)m[h].start()}},0)}function qa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){ra(a,f,b,d,c)})};function sa(a,b){this.c=a;this.a=b}function ta(a,b,c){var d=z(a.c);a=(a.a.api||"fast.fonts.net/jsapi").replace(/^.*http(s?):(\/\/)?/,"");return d+"//"+a+"/"+b+".js"+(c?"?v="+c:"")}
sa.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var m=0;m<c.length;m++){var l=c[m].fontfamily;void 0!=c[m].fontStyle&&void 0!=c[m].fontWeight?(h=c[m].fontStyle+c[m].fontWeight,e.push(new H(l,h))):e.push(new H(l))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.m;B(this.c,ta(c,d,e),function(e){e?a([]):(f["__MonotypeConfiguration__"+d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+
d}else a([])};function ua(a,b){this.c=a;this.a=b}ua.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new C;b=0;for(c=d.length;b<c;b++)A(this.c,d[b],D(g));var k=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),m=0;m<h.length;m+=1)k.push(new H(d[0],h[m]));else k.push(new H(d[0]));F(g,function(){a(k,f)})};function va(a,b,c){a?this.c=a:this.c=b+wa;this.a=[];this.f=[];this.g=c||""}var wa="//fonts.googleapis.com/css";function xa(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function za(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function Aa(a){this.f=a;this.a=[];this.c={}}
var Ba={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Ca={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Da={i:"i",italic:"i",n:"n",normal:"n"},
Ea=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Fa(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var k=d[1];g=[];if(k)for(var k=k.split(","),h=k.length,m=0;m<h;m++){var l;l=k[m];if(l.match(/^[\w-]+$/)){var n=Ea.exec(l.toLowerCase());if(null==n)l="";else{l=n[2];l=null==l||""==l?"n":Da[l];n=n[1];if(null==n||""==n)n="4";else var r=Ca[n],n=r?r:isNaN(n)?"4":n.substr(0,1);l=[l,n].join("")}}else l="";l&&g.push(l)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=Ba[d[0]])&&(a.c[e]=d))}a.c[e]||(d=Ba[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new H(e,f[d]))}};function Ga(a,b){this.c=a;this.a=b}var Ha={Arimo:!0,Cousine:!0,Tinos:!0};Ga.prototype.load=function(a){var b=new C,c=this.c,d=new va(this.a.api,z(c),this.a.text),e=this.a.families;xa(d,e);var f=new Aa(e);Fa(f);A(c,za(d),D(b));F(b,function(){a(f.a,f.c,Ha)})};function Ia(a,b){this.c=a;this.a=b}Ia.prototype.load=function(a){var b=this.a.id,c=this.c.m;b?B(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],k=b[f+1],h=0;h<k.length;h++)e.push(new H(g,k[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(m){}a(e)}},2E3):a([])};function Ja(a,b){this.c=a;this.f=b;this.a=[]}Ja.prototype.load=function(a){var b=this.f.id,c=this.c.m,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,k=c.fonts.length;g<k;++g){var h=c.fonts[g];d.a.push(new H(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},B(this.c,z(this.c)+(this.f.api||"//f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new pa(window);Y.a.c.custom=function(a,b){return new ua(b,a)};Y.a.c.fontdeck=function(a,b){return new Ja(b,a)};Y.a.c.monotype=function(a,b){return new sa(b,a)};Y.a.c.typekit=function(a,b){return new Ia(b,a)};Y.a.c.google=function(a,b){return new Ga(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());

},{}],31:[function(require,module,exports){

var zip = require('zip');

function createUrl(src){
  var blob = new Blob([src], { type: 'application/javascript' });
  return URL.createObjectURL(blob);
}

var zWorker = createUrl("/* jshint worker:true */\n(function main(global) {\n\t\"use strict\";\n\n\tif (global.zWorkerInitialized)\n\t\tthrow new Error('z-worker.js should be run only once');\n\tglobal.zWorkerInitialized = true;\n\n\taddEventListener(\"message\", function(event) {\n\t\tvar message = event.data, type = message.type, sn = message.sn;\n\t\tvar handler = handlers[type];\n\t\tif (handler) {\n\t\t\ttry {\n\t\t\t\thandler(message);\n\t\t\t} catch (e) {\n\t\t\t\tonError(type, sn, e);\n\t\t\t}\n\t\t}\n\t\t//for debug\n\t\t//postMessage({type: 'echo', originalType: type, sn: sn});\n\t});\n\n\tvar handlers = {\n\t\timportScripts: doImportScripts,\n\t\tnewTask: newTask,\n\t\tappend: processData,\n\t\tflush: processData,\n\t};\n\n\t// deflater/inflater tasks indexed by serial numbers\n\tvar tasks = {};\n\n\tfunction doImportScripts(msg) {\n\t\tif (msg.scripts && msg.scripts.length > 0)\n\t\t\timportScripts.apply(undefined, msg.scripts);\n\t\tpostMessage({type: 'importScripts'});\n\t}\n\n\tfunction newTask(msg) {\n\t\tvar CodecClass = global[msg.codecClass];\n\t\tvar sn = msg.sn;\n\t\tif (tasks[sn])\n\t\t\tthrow Error('duplicated sn');\n\t\ttasks[sn] =  {\n\t\t\tcodec: new CodecClass(msg.options),\n\t\t\tcrcInput: msg.crcType === 'input',\n\t\t\tcrcOutput: msg.crcType === 'output',\n\t\t\tcrc: new Crc32(),\n\t\t};\n\t\tpostMessage({type: 'newTask', sn: sn});\n\t}\n\n\t// performance may not be supported\n\tvar now = global.performance ? global.performance.now.bind(global.performance) : Date.now;\n\n\tfunction processData(msg) {\n\t\tvar sn = msg.sn, type = msg.type, input = msg.data;\n\t\tvar task = tasks[sn];\n\t\t// allow creating codec on first append\n\t\tif (!task && msg.codecClass) {\n\t\t\tnewTask(msg);\n\t\t\ttask = tasks[sn];\n\t\t}\n\t\tvar isAppend = type === 'append';\n\t\tvar start = now();\n\t\tvar output;\n\t\tif (isAppend) {\n\t\t\ttry {\n\t\t\t\toutput = task.codec.append(input, function onprogress(loaded) {\n\t\t\t\t\tpostMessage({type: 'progress', sn: sn, loaded: loaded});\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tdelete tasks[sn];\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete tasks[sn];\n\t\t\toutput = task.codec.flush();\n\t\t}\n\t\tvar codecTime = now() - start;\n\n\t\tstart = now();\n\t\tif (input && task.crcInput)\n\t\t\ttask.crc.append(input);\n\t\tif (output && task.crcOutput)\n\t\t\ttask.crc.append(output);\n\t\tvar crcTime = now() - start;\n\n\t\tvar rmsg = {type: type, sn: sn, codecTime: codecTime, crcTime: crcTime};\n\t\tvar transferables = [];\n\t\tif (output) {\n\t\t\trmsg.data = output;\n\t\t\ttransferables.push(output.buffer);\n\t\t}\n\t\tif (!isAppend && (task.crcInput || task.crcOutput))\n\t\t\trmsg.crc = task.crc.get();\n\t\t\n\t\t// posting a message with transferables will fail on IE10\n\t\ttry {\n\t\t\tpostMessage(rmsg, transferables);\n\t\t} catch(ex) {\n\t\t\tpostMessage(rmsg); // retry without transferables\n\t\t}\n\t}\n\n\tfunction onError(type, sn, e) {\n\t\tvar msg = {\n\t\t\ttype: type,\n\t\t\tsn: sn,\n\t\t\terror: formatError(e)\n\t\t};\n\t\tpostMessage(msg);\n\t}\n\n\tfunction formatError(e) {\n\t\treturn { message: e.message, stack: e.stack };\n\t}\n\n\t// Crc32 code copied from file zip.js\n\tfunction Crc32() {\n\t\tthis.crc = -1;\n\t}\n\tCrc32.prototype.append = function append(data) {\n\t\tvar crc = this.crc | 0, table = this.table;\n\t\tfor (var offset = 0, len = data.length | 0; offset < len; offset++)\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\n\t\tthis.crc = crc;\n\t};\n\tCrc32.prototype.get = function get() {\n\t\treturn ~this.crc;\n\t};\n\tCrc32.prototype.table = (function() {\n\t\tvar i, j, t, table = []; // Uint32Array is actually slower than []\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tt = i;\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tif (t & 1)\n\t\t\t\t\tt = (t >>> 1) ^ 0xEDB88320;\n\t\t\t\telse\n\t\t\t\t\tt = t >>> 1;\n\t\t\ttable[i] = t;\n\t\t}\n\t\treturn table;\n\t})();\n\n\t// \"no-op\" codec\n\tfunction NOOP() {}\n\tglobal.NOOP = NOOP;\n\tNOOP.prototype.append = function append(bytes, onprogress) {\n\t\treturn bytes;\n\t};\n\tNOOP.prototype.flush = function flush() {};\n})(this);\n");
zip.workerScripts = {
  deflater: [zWorker, createUrl("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n\n(function(global) {\n\t\"use strict\";\n\n\t// Global\n\n\tvar MAX_BITS = 15;\n\tvar D_CODES = 30;\n\tvar BL_CODES = 19;\n\n\tvar LENGTH_CODES = 29;\n\tvar LITERALS = 256;\n\tvar L_CODES = (LITERALS + 1 + LENGTH_CODES);\n\tvar HEAP_SIZE = (2 * L_CODES + 1);\n\n\tvar END_BLOCK = 256;\n\n\t// Bit length codes must not exceed MAX_BL_BITS bits\n\tvar MAX_BL_BITS = 7;\n\n\t// repeat previous bit length 3-6 times (2 bits of repeat count)\n\tvar REP_3_6 = 16;\n\n\t// repeat a zero length 3-10 times (3 bits of repeat count)\n\tvar REPZ_3_10 = 17;\n\n\t// repeat a zero length 11-138 times (7 bits of repeat count)\n\tvar REPZ_11_138 = 18;\n\n\t// The lengths of the bit length codes are sent in order of decreasing\n\t// probability, to avoid transmitting the lengths for unused bit\n\t// length codes.\n\n\tvar Buf_size = 8 * 2;\n\n\t// JZlib version : \"1.0.2\"\n\tvar Z_DEFAULT_COMPRESSION = -1;\n\n\t// compression strategy\n\tvar Z_FILTERED = 1;\n\tvar Z_HUFFMAN_ONLY = 2;\n\tvar Z_DEFAULT_STRATEGY = 0;\n\n\tvar Z_NO_FLUSH = 0;\n\tvar Z_PARTIAL_FLUSH = 1;\n\tvar Z_FULL_FLUSH = 3;\n\tvar Z_FINISH = 4;\n\n\tvar Z_OK = 0;\n\tvar Z_STREAM_END = 1;\n\tvar Z_NEED_DICT = 2;\n\tvar Z_STREAM_ERROR = -2;\n\tvar Z_DATA_ERROR = -3;\n\tvar Z_BUF_ERROR = -5;\n\n\t// Tree\n\n\t// see definition of array dist_code below\n\tvar _dist_code = [ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t\t\t10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n\t\t\t12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n\t\t\t14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n\t\t\t14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n\t\t\t15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19,\n\t\t\t20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t\t24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n\t\t\t26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n\t\t\t27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n\t\t\t28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,\n\t\t\t29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n\t\t\t29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 ];\n\n\tfunction Tree() {\n\t\tvar that = this;\n\n\t\t// dyn_tree; // the dynamic tree\n\t\t// max_code; // largest code with non zero frequency\n\t\t// stat_desc; // the corresponding static tree\n\n\t\t// Compute the optimal bit lengths for a tree and update the total bit\n\t\t// length\n\t\t// for the current block.\n\t\t// IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t\t// above are the tree nodes sorted by increasing frequency.\n\t\t// OUT assertions: the field len is set to the optimal bit length, the\n\t\t// array bl_count contains the frequencies for each bit length.\n\t\t// The length opt_len is updated; static_len is also updated if stree is\n\t\t// not null.\n\t\tfunction gen_bitlen(s) {\n\t\t\tvar tree = that.dyn_tree;\n\t\t\tvar stree = that.stat_desc.static_tree;\n\t\t\tvar extra = that.stat_desc.extra_bits;\n\t\t\tvar base = that.stat_desc.extra_base;\n\t\t\tvar max_length = that.stat_desc.max_length;\n\t\t\tvar h; // heap index\n\t\t\tvar n, m; // iterate over the tree elements\n\t\t\tvar bits; // bit length\n\t\t\tvar xbits; // extra bits\n\t\t\tvar f; // frequency\n\t\t\tvar overflow = 0; // number of elements with bit length too large\n\n\t\t\tfor (bits = 0; bits <= MAX_BITS; bits++)\n\t\t\t\ts.bl_count[bits] = 0;\n\n\t\t\t// In a first pass, compute the optimal bit lengths (which may\n\t\t\t// overflow in the case of the bit length tree).\n\t\t\ttree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap\n\n\t\t\tfor (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n\t\t\t\tn = s.heap[h];\n\t\t\t\tbits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n\t\t\t\tif (bits > max_length) {\n\t\t\t\t\tbits = max_length;\n\t\t\t\t\toverflow++;\n\t\t\t\t}\n\t\t\t\ttree[n * 2 + 1] = bits;\n\t\t\t\t// We overwrite tree[n*2+1] which is no longer needed\n\n\t\t\t\tif (n > that.max_code)\n\t\t\t\t\tcontinue; // not a leaf node\n\n\t\t\t\ts.bl_count[bits]++;\n\t\t\t\txbits = 0;\n\t\t\t\tif (n >= base)\n\t\t\t\t\txbits = extra[n - base];\n\t\t\t\tf = tree[n * 2];\n\t\t\t\ts.opt_len += f * (bits + xbits);\n\t\t\t\tif (stree)\n\t\t\t\t\ts.static_len += f * (stree[n * 2 + 1] + xbits);\n\t\t\t}\n\t\t\tif (overflow === 0)\n\t\t\t\treturn;\n\n\t\t\t// This happens for example on obj2 and pic of the Calgary corpus\n\t\t\t// Find the first bit length which could increase:\n\t\t\tdo {\n\t\t\t\tbits = max_length - 1;\n\t\t\t\twhile (s.bl_count[bits] === 0)\n\t\t\t\t\tbits--;\n\t\t\t\ts.bl_count[bits]--; // move one leaf down the tree\n\t\t\t\ts.bl_count[bits + 1] += 2; // move one overflow item as its brother\n\t\t\t\ts.bl_count[max_length]--;\n\t\t\t\t// The brother of the overflow item also moves one step up,\n\t\t\t\t// but this does not affect bl_count[max_length]\n\t\t\t\toverflow -= 2;\n\t\t\t} while (overflow > 0);\n\n\t\t\tfor (bits = max_length; bits !== 0; bits--) {\n\t\t\t\tn = s.bl_count[bits];\n\t\t\t\twhile (n !== 0) {\n\t\t\t\t\tm = s.heap[--h];\n\t\t\t\t\tif (m > that.max_code)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (tree[m * 2 + 1] != bits) {\n\t\t\t\t\t\ts.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n\t\t\t\t\t\ttree[m * 2 + 1] = bits;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reverse the first len bits of a code, using straightforward code (a\n\t\t// faster\n\t\t// method would use a table)\n\t\t// IN assertion: 1 <= len <= 15\n\t\tfunction bi_reverse(code, // the value to invert\n\t\tlen // its bit length\n\t\t) {\n\t\t\tvar res = 0;\n\t\t\tdo {\n\t\t\t\tres |= code & 1;\n\t\t\t\tcode >>>= 1;\n\t\t\t\tres <<= 1;\n\t\t\t} while (--len > 0);\n\t\t\treturn res >>> 1;\n\t\t}\n\n\t\t// Generate the codes for a given tree and bit counts (which need not be\n\t\t// optimal).\n\t\t// IN assertion: the array bl_count contains the bit length statistics for\n\t\t// the given tree and the field len is set for all tree elements.\n\t\t// OUT assertion: the field code is set for all tree elements of non\n\t\t// zero code length.\n\t\tfunction gen_codes(tree, // the tree to decorate\n\t\tmax_code, // largest code with non zero frequency\n\t\tbl_count // number of codes at each bit length\n\t\t) {\n\t\t\tvar next_code = []; // next code value for each\n\t\t\t// bit length\n\t\t\tvar code = 0; // running code value\n\t\t\tvar bits; // bit index\n\t\t\tvar n; // code index\n\t\t\tvar len;\n\n\t\t\t// The distribution counts are first used to generate the code values\n\t\t\t// without bit reversal.\n\t\t\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\t\t\tnext_code[bits] = code = ((code + bl_count[bits - 1]) << 1);\n\t\t\t}\n\n\t\t\t// Check that the bit counts in bl_count are consistent. The last code\n\t\t\t// must be all ones.\n\t\t\t// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n\t\t\t// \"inconsistent bit counts\");\n\t\t\t// Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tlen = tree[n * 2 + 1];\n\t\t\t\tif (len === 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Now reverse the bits\n\t\t\t\ttree[n * 2] = bi_reverse(next_code[len]++, len);\n\t\t\t}\n\t\t}\n\n\t\t// Construct one Huffman tree and assigns the code bit strings and lengths.\n\t\t// Update the total bit length for the current block.\n\t\t// IN assertion: the field freq is set for all tree elements.\n\t\t// OUT assertions: the fields len and code are set to the optimal bit length\n\t\t// and corresponding code. The length opt_len is updated; static_len is\n\t\t// also updated if stree is not null. The field max_code is set.\n\t\tthat.build_tree = function(s) {\n\t\t\tvar tree = that.dyn_tree;\n\t\t\tvar stree = that.stat_desc.static_tree;\n\t\t\tvar elems = that.stat_desc.elems;\n\t\t\tvar n, m; // iterate over heap elements\n\t\t\tvar max_code = -1; // largest code with non zero frequency\n\t\t\tvar node; // new node being created\n\n\t\t\t// Construct the initial heap, with least frequent element in\n\t\t\t// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n\t\t\t// heap[0] is not used.\n\t\t\ts.heap_len = 0;\n\t\t\ts.heap_max = HEAP_SIZE;\n\n\t\t\tfor (n = 0; n < elems; n++) {\n\t\t\t\tif (tree[n * 2] !== 0) {\n\t\t\t\t\ts.heap[++s.heap_len] = max_code = n;\n\t\t\t\t\ts.depth[n] = 0;\n\t\t\t\t} else {\n\t\t\t\t\ttree[n * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The pkzip format requires that at least one distance code exists,\n\t\t\t// and that at least one bit should be sent even if there is only one\n\t\t\t// possible code. So to avoid special checks later on we force at least\n\t\t\t// two codes of non zero frequency.\n\t\t\twhile (s.heap_len < 2) {\n\t\t\t\tnode = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n\t\t\t\ttree[node * 2] = 1;\n\t\t\t\ts.depth[node] = 0;\n\t\t\t\ts.opt_len--;\n\t\t\t\tif (stree)\n\t\t\t\t\ts.static_len -= stree[node * 2 + 1];\n\t\t\t\t// node is 0 or 1 so it does not have extra bits\n\t\t\t}\n\t\t\tthat.max_code = max_code;\n\n\t\t\t// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n\t\t\t// establish sub-heaps of increasing lengths:\n\n\t\t\tfor (n = Math.floor(s.heap_len / 2); n >= 1; n--)\n\t\t\t\ts.pqdownheap(tree, n);\n\n\t\t\t// Construct the Huffman tree by repeatedly combining the least two\n\t\t\t// frequent nodes.\n\n\t\t\tnode = elems; // next internal node of the tree\n\t\t\tdo {\n\t\t\t\t// n = node of least frequency\n\t\t\t\tn = s.heap[1];\n\t\t\t\ts.heap[1] = s.heap[s.heap_len--];\n\t\t\t\ts.pqdownheap(tree, 1);\n\t\t\t\tm = s.heap[1]; // m = node of next least frequency\n\n\t\t\t\ts.heap[--s.heap_max] = n; // keep the nodes sorted by frequency\n\t\t\t\ts.heap[--s.heap_max] = m;\n\n\t\t\t\t// Create a new node father of n and m\n\t\t\t\ttree[node * 2] = (tree[n * 2] + tree[m * 2]);\n\t\t\t\ts.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;\n\t\t\t\ttree[n * 2 + 1] = tree[m * 2 + 1] = node;\n\n\t\t\t\t// and insert the new node in the heap\n\t\t\t\ts.heap[1] = node++;\n\t\t\t\ts.pqdownheap(tree, 1);\n\t\t\t} while (s.heap_len >= 2);\n\n\t\t\ts.heap[--s.heap_max] = s.heap[1];\n\n\t\t\t// At this point, the fields freq and dad are set. We can now\n\t\t\t// generate the bit lengths.\n\n\t\t\tgen_bitlen(s);\n\n\t\t\t// The field len is now set, we can generate the bit codes\n\t\t\tgen_codes(tree, that.max_code, s.bl_count);\n\t\t};\n\n\t}\n\n\tTree._length_code = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n\t\t\t16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\t\t\t20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t\t\t22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n\t\t\t25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n\t\t\t26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28 ];\n\n\tTree.base_length = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0 ];\n\n\tTree.base_dist = [ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,\n\t\t\t24576 ];\n\n\t// Mapping from a distance to a distance code. dist is the distance - 1 and\n\t// must not have side effects. _dist_code[256] and _dist_code[257] are never\n\t// used.\n\tTree.d_code = function(dist) {\n\t\treturn ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);\n\t};\n\n\t// extra bits for each length code\n\tTree.extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];\n\n\t// extra bits for each distance code\n\tTree.extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\n\n\t// extra bits for each bit length code\n\tTree.extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];\n\n\tTree.bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\t// StaticTree\n\n\tfunction StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {\n\t\tvar that = this;\n\t\tthat.static_tree = static_tree;\n\t\tthat.extra_bits = extra_bits;\n\t\tthat.extra_base = extra_base;\n\t\tthat.elems = elems;\n\t\tthat.max_length = max_length;\n\t}\n\n\tStaticTree.static_ltree = [ 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8,\n\t\t\t130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42,\n\t\t\t8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8,\n\t\t\t22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8,\n\t\t\t222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113,\n\t\t\t8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8,\n\t\t\t69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8,\n\t\t\t173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9,\n\t\t\t51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9,\n\t\t\t427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379,\n\t\t\t9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23,\n\t\t\t9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9,\n\t\t\t399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9,\n\t\t\t223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7,\n\t\t\t40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8,\n\t\t\t99, 8, 227, 8 ];\n\n\tStaticTree.static_dtree = [ 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5,\n\t\t\t25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5 ];\n\n\tStaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n\n\tStaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);\n\n\tStaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n\n\t// Deflate\n\n\tvar MAX_MEM_LEVEL = 9;\n\tvar DEF_MEM_LEVEL = 8;\n\n\tfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\t\tvar that = this;\n\t\tthat.good_length = good_length;\n\t\tthat.max_lazy = max_lazy;\n\t\tthat.nice_length = nice_length;\n\t\tthat.max_chain = max_chain;\n\t\tthat.func = func;\n\t}\n\n\tvar STORED = 0;\n\tvar FAST = 1;\n\tvar SLOW = 2;\n\tvar config_table = [ new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST),\n\t\t\tnew Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW),\n\t\t\tnew Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW) ];\n\n\tvar z_errmsg = [ \"need dictionary\", // Z_NEED_DICT\n\t// 2\n\t\"stream end\", // Z_STREAM_END 1\n\t\"\", // Z_OK 0\n\t\"\", // Z_ERRNO (-1)\n\t\"stream error\", // Z_STREAM_ERROR (-2)\n\t\"data error\", // Z_DATA_ERROR (-3)\n\t\"\", // Z_MEM_ERROR (-4)\n\t\"buffer error\", // Z_BUF_ERROR (-5)\n\t\"\",// Z_VERSION_ERROR (-6)\n\t\"\" ];\n\n\t// block not completed, need more input or more output\n\tvar NeedMore = 0;\n\n\t// block flush performed\n\tvar BlockDone = 1;\n\n\t// finish started, need only more output at next deflate\n\tvar FinishStarted = 2;\n\n\t// finish done, accept no more input or output\n\tvar FinishDone = 3;\n\n\t// preset dictionary flag in zlib header\n\tvar PRESET_DICT = 0x20;\n\n\tvar INIT_STATE = 42;\n\tvar BUSY_STATE = 113;\n\tvar FINISH_STATE = 666;\n\n\t// The deflate compression method\n\tvar Z_DEFLATED = 8;\n\n\tvar STORED_BLOCK = 0;\n\tvar STATIC_TREES = 1;\n\tvar DYN_TREES = 2;\n\n\tvar MIN_MATCH = 3;\n\tvar MAX_MATCH = 258;\n\tvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n\tfunction smaller(tree, n, m, depth) {\n\t\tvar tn2 = tree[n * 2];\n\t\tvar tm2 = tree[m * 2];\n\t\treturn (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));\n\t}\n\n\tfunction Deflate() {\n\n\t\tvar that = this;\n\t\tvar strm; // pointer back to this zlib stream\n\t\tvar status; // as the name implies\n\t\t// pending_buf; // output still pending\n\t\tvar pending_buf_size; // size of pending_buf\n\t\t// pending_out; // next pending byte to output to the stream\n\t\t// pending; // nb of bytes in the pending buffer\n\t\tvar method; // STORED (for zip only) or DEFLATED\n\t\tvar last_flush; // value of flush param for previous deflate call\n\n\t\tvar w_size; // LZ77 window size (32K by default)\n\t\tvar w_bits; // log2(w_size) (8..16)\n\t\tvar w_mask; // w_size - 1\n\n\t\tvar window;\n\t\t// Sliding window. Input bytes are read into the second half of the window,\n\t\t// and move to the first half later to keep a dictionary of at least wSize\n\t\t// bytes. With this organization, matches are limited to a distance of\n\t\t// wSize-MAX_MATCH bytes, but this ensures that IO is always\n\t\t// performed with a length multiple of the block size. Also, it limits\n\t\t// the window size to 64K, which is quite useful on MSDOS.\n\t\t// To do: use the user input buffer as sliding window.\n\n\t\tvar window_size;\n\t\t// Actual size of window: 2*wSize, except when the user input buffer\n\t\t// is directly used as sliding window.\n\n\t\tvar prev;\n\t\t// Link to older string with same hash index. To limit the size of this\n\t\t// array to 64K, this link is maintained only for the last 32K strings.\n\t\t// An index in this array is thus a window index modulo 32K.\n\n\t\tvar head; // Heads of the hash chains or NIL.\n\n\t\tvar ins_h; // hash index of string to be inserted\n\t\tvar hash_size; // number of elements in hash table\n\t\tvar hash_bits; // log2(hash_size)\n\t\tvar hash_mask; // hash_size-1\n\n\t\t// Number of bits by which ins_h must be shifted at each input\n\t\t// step. It must be such that after MIN_MATCH steps, the oldest\n\t\t// byte no longer takes part in the hash key, that is:\n\t\t// hash_shift * MIN_MATCH >= hash_bits\n\t\tvar hash_shift;\n\n\t\t// Window position at the beginning of the current output block. Gets\n\t\t// negative when the window is moved backwards.\n\n\t\tvar block_start;\n\n\t\tvar match_length; // length of best match\n\t\tvar prev_match; // previous match\n\t\tvar match_available; // set if previous match exists\n\t\tvar strstart; // start of string to insert\n\t\tvar match_start; // start of matching string\n\t\tvar lookahead; // number of valid bytes ahead in window\n\n\t\t// Length of the best match at previous step. Matches not greater than this\n\t\t// are discarded. This is used in the lazy match evaluation.\n\t\tvar prev_length;\n\n\t\t// To speed up deflation, hash chains are never searched beyond this\n\t\t// length. A higher limit improves compression ratio but degrades the speed.\n\t\tvar max_chain_length;\n\n\t\t// Attempt to find a better match only when the current match is strictly\n\t\t// smaller than this value. This mechanism is used only for compression\n\t\t// levels >= 4.\n\t\tvar max_lazy_match;\n\n\t\t// Insert new strings in the hash table only if the match length is not\n\t\t// greater than this length. This saves time but degrades compression.\n\t\t// max_insert_length is used only for compression levels <= 3.\n\n\t\tvar level; // compression level (1..9)\n\t\tvar strategy; // favor or force Huffman coding\n\n\t\t// Use a faster search when the previous match is longer than this\n\t\tvar good_match;\n\n\t\t// Stop searching when current match exceeds this\n\t\tvar nice_match;\n\n\t\tvar dyn_ltree; // literal and length tree\n\t\tvar dyn_dtree; // distance tree\n\t\tvar bl_tree; // Huffman tree for bit lengths\n\n\t\tvar l_desc = new Tree(); // desc for literal tree\n\t\tvar d_desc = new Tree(); // desc for distance tree\n\t\tvar bl_desc = new Tree(); // desc for bit length tree\n\n\t\t// that.heap_len; // number of elements in the heap\n\t\t// that.heap_max; // element of largest frequency\n\t\t// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n\t\t// The same heap array is used to build all trees.\n\n\t\t// Depth of each subtree used as tie breaker for trees of equal frequency\n\t\tthat.depth = [];\n\n\t\tvar l_buf; // index for literals or lengths */\n\n\t\t// Size of match buffer for literals/lengths. There are 4 reasons for\n\t\t// limiting lit_bufsize to 64K:\n\t\t// - frequencies can be kept in 16 bit counters\n\t\t// - if compression is not successful for the first block, all input\n\t\t// data is still in the window so we can still emit a stored block even\n\t\t// when input comes from standard input. (This can also be done for\n\t\t// all blocks if lit_bufsize is not greater than 32K.)\n\t\t// - if compression is not successful for a file smaller than 64K, we can\n\t\t// even emit a stored file instead of a stored block (saving 5 bytes).\n\t\t// This is applicable only for zip (not gzip or zlib).\n\t\t// - creating new Huffman trees less frequently may not provide fast\n\t\t// adaptation to changes in the input data statistics. (Take for\n\t\t// example a binary file with poorly compressible code followed by\n\t\t// a highly compressible string table.) Smaller buffer sizes give\n\t\t// fast adaptation but have of course the overhead of transmitting\n\t\t// trees more frequently.\n\t\t// - I can't count above 4\n\t\tvar lit_bufsize;\n\n\t\tvar last_lit; // running index in l_buf\n\n\t\t// Buffer for distances. To simplify the code, d_buf and l_buf have\n\t\t// the same number of elements. To use different lengths, an extra flag\n\t\t// array would be necessary.\n\n\t\tvar d_buf; // index of pendig_buf\n\n\t\t// that.opt_len; // bit length of current block with optimal trees\n\t\t// that.static_len; // bit length of current block with static trees\n\t\tvar matches; // number of string matches in current block\n\t\tvar last_eob_len; // bit length of EOB code for last block\n\n\t\t// Output buffer. bits are inserted starting at the bottom (least\n\t\t// significant bits).\n\t\tvar bi_buf;\n\n\t\t// Number of valid bits in bi_buf. All bits above the last valid bit\n\t\t// are always zero.\n\t\tvar bi_valid;\n\n\t\t// number of codes at each bit length for an optimal tree\n\t\tthat.bl_count = [];\n\n\t\t// heap used to build the Huffman trees\n\t\tthat.heap = [];\n\n\t\tdyn_ltree = [];\n\t\tdyn_dtree = [];\n\t\tbl_tree = [];\n\n\t\tfunction lm_init() {\n\t\t\tvar i;\n\t\t\twindow_size = 2 * w_size;\n\n\t\t\thead[hash_size - 1] = 0;\n\t\t\tfor (i = 0; i < hash_size - 1; i++) {\n\t\t\t\thead[i] = 0;\n\t\t\t}\n\n\t\t\t// Set the default configuration parameters:\n\t\t\tmax_lazy_match = config_table[level].max_lazy;\n\t\t\tgood_match = config_table[level].good_length;\n\t\t\tnice_match = config_table[level].nice_length;\n\t\t\tmax_chain_length = config_table[level].max_chain;\n\n\t\t\tstrstart = 0;\n\t\t\tblock_start = 0;\n\t\t\tlookahead = 0;\n\t\t\tmatch_length = prev_length = MIN_MATCH - 1;\n\t\t\tmatch_available = 0;\n\t\t\tins_h = 0;\n\t\t}\n\n\t\tfunction init_block() {\n\t\t\tvar i;\n\t\t\t// Initialize the trees.\n\t\t\tfor (i = 0; i < L_CODES; i++)\n\t\t\t\tdyn_ltree[i * 2] = 0;\n\t\t\tfor (i = 0; i < D_CODES; i++)\n\t\t\t\tdyn_dtree[i * 2] = 0;\n\t\t\tfor (i = 0; i < BL_CODES; i++)\n\t\t\t\tbl_tree[i * 2] = 0;\n\n\t\t\tdyn_ltree[END_BLOCK * 2] = 1;\n\t\t\tthat.opt_len = that.static_len = 0;\n\t\t\tlast_lit = matches = 0;\n\t\t}\n\n\t\t// Initialize the tree data structures for a new zlib stream.\n\t\tfunction tr_init() {\n\n\t\t\tl_desc.dyn_tree = dyn_ltree;\n\t\t\tl_desc.stat_desc = StaticTree.static_l_desc;\n\n\t\t\td_desc.dyn_tree = dyn_dtree;\n\t\t\td_desc.stat_desc = StaticTree.static_d_desc;\n\n\t\t\tbl_desc.dyn_tree = bl_tree;\n\t\t\tbl_desc.stat_desc = StaticTree.static_bl_desc;\n\n\t\t\tbi_buf = 0;\n\t\t\tbi_valid = 0;\n\t\t\tlast_eob_len = 8; // enough lookahead for inflate\n\n\t\t\t// Initialize the first block of the first file:\n\t\t\tinit_block();\n\t\t}\n\n\t\t// Restore the heap property by moving down the tree starting at node k,\n\t\t// exchanging a node with the smallest of its two sons if necessary,\n\t\t// stopping\n\t\t// when the heap property is re-established (each father smaller than its\n\t\t// two sons).\n\t\tthat.pqdownheap = function(tree, // the tree to restore\n\t\tk // node to move down\n\t\t) {\n\t\t\tvar heap = that.heap;\n\t\t\tvar v = heap[k];\n\t\t\tvar j = k << 1; // left son of k\n\t\t\twhile (j <= that.heap_len) {\n\t\t\t\t// Set j to the smallest of the two sons:\n\t\t\t\tif (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t// Exit if v is smaller than both sons\n\t\t\t\tif (smaller(tree, v, heap[j], that.depth))\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Exchange v with the smallest son\n\t\t\t\theap[k] = heap[j];\n\t\t\t\tk = j;\n\t\t\t\t// And continue down the tree, setting j to the left son of k\n\t\t\t\tj <<= 1;\n\t\t\t}\n\t\t\theap[k] = v;\n\t\t};\n\n\t\t// Scan a literal or distance tree to determine the frequencies of the codes\n\t\t// in the bit length tree.\n\t\tfunction scan_tree(tree,// the tree to be scanned\n\t\tmax_code // and its largest code of non zero frequency\n\t\t) {\n\t\t\tvar n; // iterates over all tree elements\n\t\t\tvar prevlen = -1; // last emitted length\n\t\t\tvar curlen; // length of current code\n\t\t\tvar nextlen = tree[0 * 2 + 1]; // length of next code\n\t\t\tvar count = 0; // repeat count of the current code\n\t\t\tvar max_count = 7; // max repeat count\n\t\t\tvar min_count = 4; // min repeat count\n\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t}\n\t\t\ttree[(max_code + 1) * 2 + 1] = 0xffff; // guard\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tcurlen = nextlen;\n\t\t\t\tnextlen = tree[(n + 1) * 2 + 1];\n\t\t\t\tif (++count < max_count && curlen == nextlen) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (count < min_count) {\n\t\t\t\t\tbl_tree[curlen * 2] += count;\n\t\t\t\t} else if (curlen !== 0) {\n\t\t\t\t\tif (curlen != prevlen)\n\t\t\t\t\t\tbl_tree[curlen * 2]++;\n\t\t\t\t\tbl_tree[REP_3_6 * 2]++;\n\t\t\t\t} else if (count <= 10) {\n\t\t\t\t\tbl_tree[REPZ_3_10 * 2]++;\n\t\t\t\t} else {\n\t\t\t\t\tbl_tree[REPZ_11_138 * 2]++;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tprevlen = curlen;\n\t\t\t\tif (nextlen === 0) {\n\t\t\t\t\tmax_count = 138;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else if (curlen == nextlen) {\n\t\t\t\t\tmax_count = 6;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else {\n\t\t\t\t\tmax_count = 7;\n\t\t\t\t\tmin_count = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Construct the Huffman tree for the bit lengths and return the index in\n\t\t// bl_order of the last bit length code to send.\n\t\tfunction build_bl_tree() {\n\t\t\tvar max_blindex; // index of last bit length code of non zero freq\n\n\t\t\t// Determine the bit length frequencies for literal and distance trees\n\t\t\tscan_tree(dyn_ltree, l_desc.max_code);\n\t\t\tscan_tree(dyn_dtree, d_desc.max_code);\n\n\t\t\t// Build the bit length tree:\n\t\t\tbl_desc.build_tree(that);\n\t\t\t// opt_len now includes the length of the tree representations, except\n\t\t\t// the lengths of the bit lengths codes and the 5+5+4 bits for the\n\t\t\t// counts.\n\n\t\t\t// Determine the number of bit length codes to send. The pkzip format\n\t\t\t// requires that at least 4 bit length codes be sent. (appnote.txt says\n\t\t\t// 3 but the actual value used is 4.)\n\t\t\tfor (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n\t\t\t\tif (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Update opt_len to include the bit length tree and counts\n\t\t\tthat.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\n\t\t\treturn max_blindex;\n\t\t}\n\n\t\t// Output a byte on the stream.\n\t\t// IN assertion: there is enough room in pending_buf.\n\t\tfunction put_byte(p) {\n\t\t\tthat.pending_buf[that.pending++] = p;\n\t\t}\n\n\t\tfunction put_short(w) {\n\t\t\tput_byte(w & 0xff);\n\t\t\tput_byte((w >>> 8) & 0xff);\n\t\t}\n\n\t\tfunction putShortMSB(b) {\n\t\t\tput_byte((b >> 8) & 0xff);\n\t\t\tput_byte((b & 0xff) & 0xff);\n\t\t}\n\n\t\tfunction send_bits(value, length) {\n\t\t\tvar val, len = length;\n\t\t\tif (bi_valid > Buf_size - len) {\n\t\t\t\tval = value;\n\t\t\t\t// bi_buf |= (val << bi_valid);\n\t\t\t\tbi_buf |= ((val << bi_valid) & 0xffff);\n\t\t\t\tput_short(bi_buf);\n\t\t\t\tbi_buf = val >>> (Buf_size - bi_valid);\n\t\t\t\tbi_valid += len - Buf_size;\n\t\t\t} else {\n\t\t\t\t// bi_buf |= (value) << bi_valid;\n\t\t\t\tbi_buf |= (((value) << bi_valid) & 0xffff);\n\t\t\t\tbi_valid += len;\n\t\t\t}\n\t\t}\n\n\t\tfunction send_code(c, tree) {\n\t\t\tvar c2 = c * 2;\n\t\t\tsend_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);\n\t\t}\n\n\t\t// Send a literal or distance tree in compressed form, using the codes in\n\t\t// bl_tree.\n\t\tfunction send_tree(tree,// the tree to be sent\n\t\tmax_code // and its largest code of non zero frequency\n\t\t) {\n\t\t\tvar n; // iterates over all tree elements\n\t\t\tvar prevlen = -1; // last emitted length\n\t\t\tvar curlen; // length of current code\n\t\t\tvar nextlen = tree[0 * 2 + 1]; // length of next code\n\t\t\tvar count = 0; // repeat count of the current code\n\t\t\tvar max_count = 7; // max repeat count\n\t\t\tvar min_count = 4; // min repeat count\n\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t}\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tcurlen = nextlen;\n\t\t\t\tnextlen = tree[(n + 1) * 2 + 1];\n\t\t\t\tif (++count < max_count && curlen == nextlen) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (count < min_count) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tsend_code(curlen, bl_tree);\n\t\t\t\t\t} while (--count !== 0);\n\t\t\t\t} else if (curlen !== 0) {\n\t\t\t\t\tif (curlen != prevlen) {\n\t\t\t\t\t\tsend_code(curlen, bl_tree);\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t\tsend_code(REP_3_6, bl_tree);\n\t\t\t\t\tsend_bits(count - 3, 2);\n\t\t\t\t} else if (count <= 10) {\n\t\t\t\t\tsend_code(REPZ_3_10, bl_tree);\n\t\t\t\t\tsend_bits(count - 3, 3);\n\t\t\t\t} else {\n\t\t\t\t\tsend_code(REPZ_11_138, bl_tree);\n\t\t\t\t\tsend_bits(count - 11, 7);\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tprevlen = curlen;\n\t\t\t\tif (nextlen === 0) {\n\t\t\t\t\tmax_count = 138;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else if (curlen == nextlen) {\n\t\t\t\t\tmax_count = 6;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else {\n\t\t\t\t\tmax_count = 7;\n\t\t\t\t\tmin_count = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Send the header for a block using dynamic Huffman trees: the counts, the\n\t\t// lengths of the bit length codes, the literal tree and the distance tree.\n\t\t// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t\tfunction send_all_trees(lcodes, dcodes, blcodes) {\n\t\t\tvar rank; // index in bl_order\n\n\t\t\tsend_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n\t\t\tsend_bits(dcodes - 1, 5);\n\t\t\tsend_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n\t\t\tfor (rank = 0; rank < blcodes; rank++) {\n\t\t\t\tsend_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);\n\t\t\t}\n\t\t\tsend_tree(dyn_ltree, lcodes - 1); // literal tree\n\t\t\tsend_tree(dyn_dtree, dcodes - 1); // distance tree\n\t\t}\n\n\t\t// Flush the bit buffer, keeping at most 7 bits in it.\n\t\tfunction bi_flush() {\n\t\t\tif (bi_valid == 16) {\n\t\t\t\tput_short(bi_buf);\n\t\t\t\tbi_buf = 0;\n\t\t\t\tbi_valid = 0;\n\t\t\t} else if (bi_valid >= 8) {\n\t\t\t\tput_byte(bi_buf & 0xff);\n\t\t\t\tbi_buf >>>= 8;\n\t\t\t\tbi_valid -= 8;\n\t\t\t}\n\t\t}\n\n\t\t// Send one empty static block to give enough lookahead for inflate.\n\t\t// This takes 10 bits, of which 7 may remain in the bit buffer.\n\t\t// The current inflate code requires 9 bits of lookahead. If the\n\t\t// last two codes for the previous block (real code plus EOB) were coded\n\t\t// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\n\t\t// the last real code. In this case we send two empty static blocks instead\n\t\t// of one. (There are no problems if the previous block is stored or fixed.)\n\t\t// To simplify the code, we assume the worst case of last real code encoded\n\t\t// on one bit only.\n\t\tfunction _tr_align() {\n\t\t\tsend_bits(STATIC_TREES << 1, 3);\n\t\t\tsend_code(END_BLOCK, StaticTree.static_ltree);\n\n\t\t\tbi_flush();\n\n\t\t\t// Of the 10 bits for the empty block, we have already sent\n\t\t\t// (10 - bi_valid) bits. The lookahead for the last real code (before\n\t\t\t// the EOB of the previous block) was thus at least one plus the length\n\t\t\t// of the EOB plus what we have just sent of the empty static block.\n\t\t\tif (1 + last_eob_len + 10 - bi_valid < 9) {\n\t\t\t\tsend_bits(STATIC_TREES << 1, 3);\n\t\t\t\tsend_code(END_BLOCK, StaticTree.static_ltree);\n\t\t\t\tbi_flush();\n\t\t\t}\n\t\t\tlast_eob_len = 7;\n\t\t}\n\n\t\t// Save the match info and tally the frequency counts. Return true if\n\t\t// the current block must be flushed.\n\t\tfunction _tr_tally(dist, // distance of matched string\n\t\tlc // match length-MIN_MATCH or unmatched char (if dist==0)\n\t\t) {\n\t\t\tvar out_length, in_length, dcode;\n\t\t\tthat.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;\n\t\t\tthat.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;\n\n\t\t\tthat.pending_buf[l_buf + last_lit] = lc & 0xff;\n\t\t\tlast_lit++;\n\n\t\t\tif (dist === 0) {\n\t\t\t\t// lc is the unmatched char\n\t\t\t\tdyn_ltree[lc * 2]++;\n\t\t\t} else {\n\t\t\t\tmatches++;\n\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\tdist--; // dist = match distance - 1\n\t\t\t\tdyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;\n\t\t\t\tdyn_dtree[Tree.d_code(dist) * 2]++;\n\t\t\t}\n\n\t\t\tif ((last_lit & 0x1fff) === 0 && level > 2) {\n\t\t\t\t// Compute an upper bound for the compressed length\n\t\t\t\tout_length = last_lit * 8;\n\t\t\t\tin_length = strstart - block_start;\n\t\t\t\tfor (dcode = 0; dcode < D_CODES; dcode++) {\n\t\t\t\t\tout_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);\n\t\t\t\t}\n\t\t\t\tout_length >>>= 3;\n\t\t\t\tif ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn (last_lit == lit_bufsize - 1);\n\t\t\t// We avoid equality with lit_bufsize because of wraparound at 64K\n\t\t\t// on 16 bit machines and because stored blocks are restricted to\n\t\t\t// 64K-1 bytes.\n\t\t}\n\n\t\t// Send the block data compressed using the given Huffman trees\n\t\tfunction compress_block(ltree, dtree) {\n\t\t\tvar dist; // distance of matched string\n\t\t\tvar lc; // match length or unmatched char (if dist === 0)\n\t\t\tvar lx = 0; // running index in l_buf\n\t\t\tvar code; // the code to send\n\t\t\tvar extra; // number of extra bits to send\n\n\t\t\tif (last_lit !== 0) {\n\t\t\t\tdo {\n\t\t\t\t\tdist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);\n\t\t\t\t\tlc = (that.pending_buf[l_buf + lx]) & 0xff;\n\t\t\t\t\tlx++;\n\n\t\t\t\t\tif (dist === 0) {\n\t\t\t\t\t\tsend_code(lc, ltree); // send a literal byte\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\t\t\tcode = Tree._length_code[lc];\n\n\t\t\t\t\t\tsend_code(code + LITERALS + 1, ltree); // send the length\n\t\t\t\t\t\t// code\n\t\t\t\t\t\textra = Tree.extra_lbits[code];\n\t\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\t\tlc -= Tree.base_length[code];\n\t\t\t\t\t\t\tsend_bits(lc, extra); // send the extra length bits\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist--; // dist is now the match distance - 1\n\t\t\t\t\t\tcode = Tree.d_code(dist);\n\n\t\t\t\t\t\tsend_code(code, dtree); // send the distance code\n\t\t\t\t\t\textra = Tree.extra_dbits[code];\n\t\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\t\tdist -= Tree.base_dist[code];\n\t\t\t\t\t\t\tsend_bits(dist, extra); // send the extra distance bits\n\t\t\t\t\t\t}\n\t\t\t\t\t} // literal or match pair ?\n\n\t\t\t\t\t// Check that the overlay between pending_buf and d_buf+l_buf is\n\t\t\t\t\t// ok:\n\t\t\t\t} while (lx < last_lit);\n\t\t\t}\n\n\t\t\tsend_code(END_BLOCK, ltree);\n\t\t\tlast_eob_len = ltree[END_BLOCK * 2 + 1];\n\t\t}\n\n\t\t// Flush the bit buffer and align the output on a byte boundary\n\t\tfunction bi_windup() {\n\t\t\tif (bi_valid > 8) {\n\t\t\t\tput_short(bi_buf);\n\t\t\t} else if (bi_valid > 0) {\n\t\t\t\tput_byte(bi_buf & 0xff);\n\t\t\t}\n\t\t\tbi_buf = 0;\n\t\t\tbi_valid = 0;\n\t\t}\n\n\t\t// Copy a stored block, storing first the length and its\n\t\t// one's complement if requested.\n\t\tfunction copy_block(buf, // the input data\n\t\tlen, // its length\n\t\theader // true if block header must be written\n\t\t) {\n\t\t\tbi_windup(); // align on byte boundary\n\t\t\tlast_eob_len = 8; // enough lookahead for inflate\n\n\t\t\tif (header) {\n\t\t\t\tput_short(len);\n\t\t\t\tput_short(~len);\n\t\t\t}\n\n\t\t\tthat.pending_buf.set(window.subarray(buf, buf + len), that.pending);\n\t\t\tthat.pending += len;\n\t\t}\n\n\t\t// Send a stored block\n\t\tfunction _tr_stored_block(buf, // input block\n\t\tstored_len, // length of input block\n\t\teof // true if this is the last block for a file\n\t\t) {\n\t\t\tsend_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type\n\t\t\tcopy_block(buf, stored_len, true); // with header\n\t\t}\n\n\t\t// Determine the best encoding for the current block: dynamic trees, static\n\t\t// trees or store, and output the encoded block to the zip file.\n\t\tfunction _tr_flush_block(buf, // input block, or NULL if too old\n\t\tstored_len, // length of input block\n\t\teof // true if this is the last block for a file\n\t\t) {\n\t\t\tvar opt_lenb, static_lenb;// opt_len and static_len in bytes\n\t\t\tvar max_blindex = 0; // index of last bit length code of non zero freq\n\n\t\t\t// Build the Huffman trees unless a stored block is forced\n\t\t\tif (level > 0) {\n\t\t\t\t// Construct the literal and distance trees\n\t\t\t\tl_desc.build_tree(that);\n\n\t\t\t\td_desc.build_tree(that);\n\n\t\t\t\t// At this point, opt_len and static_len are the total bit lengths\n\t\t\t\t// of\n\t\t\t\t// the compressed block data, excluding the tree representations.\n\n\t\t\t\t// Build the bit length tree for the above two trees, and get the\n\t\t\t\t// index\n\t\t\t\t// in bl_order of the last bit length code to send.\n\t\t\t\tmax_blindex = build_bl_tree();\n\n\t\t\t\t// Determine the best encoding. Compute first the block length in\n\t\t\t\t// bytes\n\t\t\t\topt_lenb = (that.opt_len + 3 + 7) >>> 3;\n\t\t\t\tstatic_lenb = (that.static_len + 3 + 7) >>> 3;\n\n\t\t\t\tif (static_lenb <= opt_lenb)\n\t\t\t\t\topt_lenb = static_lenb;\n\t\t\t} else {\n\t\t\t\topt_lenb = static_lenb = stored_len + 5; // force a stored block\n\t\t\t}\n\n\t\t\tif ((stored_len + 4 <= opt_lenb) && buf != -1) {\n\t\t\t\t// 4: two words for the lengths\n\t\t\t\t// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t\t\t// Otherwise we can't have processed more than WSIZE input bytes\n\t\t\t\t// since\n\t\t\t\t// the last block flush, because compression would have been\n\t\t\t\t// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t\t\t// transform a block into a stored block.\n\t\t\t\t_tr_stored_block(buf, stored_len, eof);\n\t\t\t} else if (static_lenb == opt_lenb) {\n\t\t\t\tsend_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);\n\t\t\t\tcompress_block(StaticTree.static_ltree, StaticTree.static_dtree);\n\t\t\t} else {\n\t\t\t\tsend_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);\n\t\t\t\tsend_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\n\t\t\t\tcompress_block(dyn_ltree, dyn_dtree);\n\t\t\t}\n\n\t\t\t// The above check is made mod 2^32, for files larger than 512 MB\n\t\t\t// and uLong implemented on 32 bits.\n\n\t\t\tinit_block();\n\n\t\t\tif (eof) {\n\t\t\t\tbi_windup();\n\t\t\t}\n\t\t}\n\n\t\tfunction flush_block_only(eof) {\n\t\t\t_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);\n\t\t\tblock_start = strstart;\n\t\t\tstrm.flush_pending();\n\t\t}\n\n\t\t// Fill the window when the lookahead becomes insufficient.\n\t\t// Updates strstart and lookahead.\n\t\t//\n\t\t// IN assertion: lookahead < MIN_LOOKAHEAD\n\t\t// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n\t\t// At least one byte has been read, or avail_in === 0; reads are\n\t\t// performed for at least two bytes (required for the zip translate_eol\n\t\t// option -- not supported here).\n\t\tfunction fill_window() {\n\t\t\tvar n, m;\n\t\t\tvar p;\n\t\t\tvar more; // Amount of free space at the end of the window.\n\n\t\t\tdo {\n\t\t\t\tmore = (window_size - lookahead - strstart);\n\n\t\t\t\t// Deal with !@#$% 64K limit:\n\t\t\t\tif (more === 0 && strstart === 0 && lookahead === 0) {\n\t\t\t\t\tmore = w_size;\n\t\t\t\t} else if (more == -1) {\n\t\t\t\t\t// Very unlikely, but possible on 16 bit machine if strstart ==\n\t\t\t\t\t// 0\n\t\t\t\t\t// and lookahead == 1 (input done one byte at time)\n\t\t\t\t\tmore--;\n\n\t\t\t\t\t// If the window is almost full and there is insufficient\n\t\t\t\t\t// lookahead,\n\t\t\t\t\t// move the upper half to the lower one to make room in the\n\t\t\t\t\t// upper half.\n\t\t\t\t} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\twindow.set(window.subarray(w_size, w_size + w_size), 0);\n\n\t\t\t\t\tmatch_start -= w_size;\n\t\t\t\t\tstrstart -= w_size; // we now have strstart >= MAX_DIST\n\t\t\t\t\tblock_start -= w_size;\n\n\t\t\t\t\t// Slide the hash table (could be avoided with 32 bit values\n\t\t\t\t\t// at the expense of memory usage). We slide even when level ==\n\t\t\t\t\t// 0\n\t\t\t\t\t// to keep the hash table consistent if we switch back to level\n\t\t\t\t\t// > 0\n\t\t\t\t\t// later. (Using level 0 permanently is not an optimal usage of\n\t\t\t\t\t// zlib, so we don't care about this pathological case.)\n\n\t\t\t\t\tn = hash_size;\n\t\t\t\t\tp = n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tm = (head[--p] & 0xffff);\n\t\t\t\t\t\thead[p] = (m >= w_size ? m - w_size : 0);\n\t\t\t\t\t} while (--n !== 0);\n\n\t\t\t\t\tn = w_size;\n\t\t\t\t\tp = n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tm = (prev[--p] & 0xffff);\n\t\t\t\t\t\tprev[p] = (m >= w_size ? m - w_size : 0);\n\t\t\t\t\t\t// If n is not on any hash chain, prev[n] is garbage but\n\t\t\t\t\t\t// its value will never be used.\n\t\t\t\t\t} while (--n !== 0);\n\t\t\t\t\tmore += w_size;\n\t\t\t\t}\n\n\t\t\t\tif (strm.avail_in === 0)\n\t\t\t\t\treturn;\n\n\t\t\t\t// If there was no sliding:\n\t\t\t\t// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n\t\t\t\t// more == window_size - lookahead - strstart\n\t\t\t\t// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n\t\t\t\t// => more >= window_size - 2*WSIZE + 2\n\t\t\t\t// In the BIG_MEM or MMAP case (not yet supported),\n\t\t\t\t// window_size == input_size + MIN_LOOKAHEAD &&\n\t\t\t\t// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n\t\t\t\t// Otherwise, window_size == 2*WSIZE so more >= 2.\n\t\t\t\t// If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n\n\t\t\t\tn = strm.read_buf(window, strstart + lookahead, more);\n\t\t\t\tlookahead += n;\n\n\t\t\t\t// Initialize the hash value now that we have some input:\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = window[strstart] & 0xff;\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\n\t\t\t\t}\n\t\t\t\t// If the whole input has less than MIN_MATCH bytes, ins_h is\n\t\t\t\t// garbage,\n\t\t\t\t// but this is not important since only literal bytes will be\n\t\t\t\t// emitted.\n\t\t\t} while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);\n\t\t}\n\n\t\t// Copy without compression as much as possible from the input stream,\n\t\t// return\n\t\t// the current block state.\n\t\t// This function does not insert new strings in the dictionary since\n\t\t// uncompressible data is probably not useful. This function is used\n\t\t// only for the level=0 compression option.\n\t\t// NOTE: this function should be optimized to avoid extra copying from\n\t\t// window to pending_buf.\n\t\tfunction deflate_stored(flush) {\n\t\t\t// Stored blocks are limited to 0xffff bytes, pending_buf is limited\n\t\t\t// to pending_buf_size, and each stored block has a 5 byte header:\n\n\t\t\tvar max_block_size = 0xffff;\n\t\t\tvar max_start;\n\n\t\t\tif (max_block_size > pending_buf_size - 5) {\n\t\t\t\tmax_block_size = pending_buf_size - 5;\n\t\t\t}\n\n\t\t\t// Copy as much as possible from input to output:\n\t\t\twhile (true) {\n\t\t\t\t// Fill the window as much as possible:\n\t\t\t\tif (lookahead <= 1) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead === 0 && flush == Z_NO_FLUSH)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\tstrstart += lookahead;\n\t\t\t\tlookahead = 0;\n\n\t\t\t\t// Emit a stored block if pending_buf will be full:\n\t\t\t\tmax_start = block_start + max_block_size;\n\t\t\t\tif (strstart === 0 || strstart >= max_start) {\n\t\t\t\t\t// strstart === 0 is possible when wraparound on 16-bit machine\n\t\t\t\t\tlookahead = (strstart - max_start);\n\t\t\t\t\tstrstart = max_start;\n\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\n\t\t\t\t}\n\n\t\t\t\t// Flush if we may have to slide, otherwise block_start may become\n\t\t\t\t// negative and the data will be gone:\n\t\t\t\tif (strstart - block_start >= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflush_block_only(flush == Z_FINISH);\n\t\t\tif (strm.avail_out === 0)\n\t\t\t\treturn (flush == Z_FINISH) ? FinishStarted : NeedMore;\n\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\tfunction longest_match(cur_match) {\n\t\t\tvar chain_length = max_chain_length; // max hash chain length\n\t\t\tvar scan = strstart; // current string\n\t\t\tvar match; // matched string\n\t\t\tvar len; // length of current match\n\t\t\tvar best_len = prev_length; // best match length so far\n\t\t\tvar limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;\n\t\t\tvar _nice_match = nice_match;\n\n\t\t\t// Stop when cur_match becomes <= limit. To simplify the code,\n\t\t\t// we prevent matches with the string of window index 0.\n\n\t\t\tvar wmask = w_mask;\n\n\t\t\tvar strend = strstart + MAX_MATCH;\n\t\t\tvar scan_end1 = window[scan + best_len - 1];\n\t\t\tvar scan_end = window[scan + best_len];\n\n\t\t\t// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of\n\t\t\t// 16.\n\t\t\t// It is easy to get rid of this optimization if necessary.\n\n\t\t\t// Do not waste too much time if we already have a good match:\n\t\t\tif (prev_length >= good_match) {\n\t\t\t\tchain_length >>= 2;\n\t\t\t}\n\n\t\t\t// Do not look for matches beyond the end of the input. This is\n\t\t\t// necessary\n\t\t\t// to make deflate deterministic.\n\t\t\tif (_nice_match > lookahead)\n\t\t\t\t_nice_match = lookahead;\n\n\t\t\tdo {\n\t\t\t\tmatch = cur_match;\n\n\t\t\t\t// Skip to next match if the match length cannot increase\n\t\t\t\t// or if the match length is less than 2:\n\t\t\t\tif (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan]\n\t\t\t\t\t\t|| window[++match] != window[scan + 1])\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The check at best_len-1 can be removed because it will be made\n\t\t\t\t// again later. (This heuristic is not always a win.)\n\t\t\t\t// It is not necessary to compare scan[2] and match[2] since they\n\t\t\t\t// are always equal when the other bytes match, given that\n\t\t\t\t// the hash keys are equal and that HASH_BITS >= 8.\n\t\t\t\tscan += 2;\n\t\t\t\tmatch++;\n\n\t\t\t\t// We check for insufficient lookahead only every 8th comparison;\n\t\t\t\t// the 256th check will be made at strstart+258.\n\t\t\t\tdo {\n\t\t\t\t} while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\n\t\t\t\t\t\t&& window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\n\t\t\t\t\t\t&& window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);\n\n\t\t\t\tlen = MAX_MATCH - (strend - scan);\n\t\t\t\tscan = strend - MAX_MATCH;\n\n\t\t\t\tif (len > best_len) {\n\t\t\t\t\tmatch_start = cur_match;\n\t\t\t\t\tbest_len = len;\n\t\t\t\t\tif (len >= _nice_match)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tscan_end1 = window[scan + best_len - 1];\n\t\t\t\t\tscan_end = window[scan + best_len];\n\t\t\t\t}\n\n\t\t\t} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);\n\n\t\t\tif (best_len <= lookahead)\n\t\t\t\treturn best_len;\n\t\t\treturn lookahead;\n\t\t}\n\n\t\t// Compress as much as possible from the input stream, return the current\n\t\t// block state.\n\t\t// This function does not perform lazy evaluation of matches and inserts\n\t\t// new strings in the dictionary only for unmatched strings or for short\n\t\t// matches. It is used only for the fast compression options.\n\t\tfunction deflate_fast(flush) {\n\t\t\t// short hash_head = 0; // head of the hash chain\n\t\t\tvar hash_head = 0; // head of the hash chain\n\t\t\tvar bflush; // set if current block must be flushed\n\n\t\t\twhile (true) {\n\t\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t\t// string following the next match.\n\t\t\t\tif (lookahead < MIN_LOOKAHEAD) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\n\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t}\n\n\t\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\t\t// At this point we have always match_length < MIN_MATCH\n\n\t\t\t\tif (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t\t// of the string with itself at the start of the input file).\n\t\t\t\t\tif (strategy != Z_HUFFMAN_ONLY) {\n\t\t\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t\t}\n\t\t\t\t\t// longest_match() sets match_start\n\t\t\t\t}\n\t\t\t\tif (match_length >= MIN_MATCH) {\n\t\t\t\t\t// check_match(strstart, match_start, match_length);\n\n\t\t\t\t\tbflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);\n\n\t\t\t\t\tlookahead -= match_length;\n\n\t\t\t\t\t// Insert new strings in the hash table only if the match length\n\t\t\t\t\t// is not too large. This saves time but degrades compression.\n\t\t\t\t\tif (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {\n\t\t\t\t\t\tmatch_length--; // string at strstart already in hash table\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tstrstart++;\n\n\t\t\t\t\t\t\tins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\t\t\thead[ins_h] = strstart;\n\n\t\t\t\t\t\t\t// strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t\t\t// always MIN_MATCH bytes ahead.\n\t\t\t\t\t\t} while (--match_length !== 0);\n\t\t\t\t\t\tstrstart++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrstart += match_length;\n\t\t\t\t\t\tmatch_length = 0;\n\t\t\t\t\t\tins_h = window[strstart] & 0xff;\n\n\t\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\n\t\t\t\t\t\t// If lookahead < MIN_MATCH, ins_h is garbage, but it does\n\t\t\t\t\t\t// not\n\t\t\t\t\t\t// matter since it will be recomputed at next deflate call.\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No match, output a literal byte\n\n\t\t\t\t\tbflush = _tr_tally(0, window[strstart] & 0xff);\n\t\t\t\t\tlookahead--;\n\t\t\t\t\tstrstart++;\n\t\t\t\t}\n\t\t\t\tif (bflush) {\n\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflush_block_only(flush == Z_FINISH);\n\t\t\tif (strm.avail_out === 0) {\n\t\t\t\tif (flush == Z_FINISH)\n\t\t\t\t\treturn FinishStarted;\n\t\t\t\telse\n\t\t\t\t\treturn NeedMore;\n\t\t\t}\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\t// Same as above, but achieves better compression. We use a lazy\n\t\t// evaluation for matches: a match is finally adopted only if there is\n\t\t// no better match at the next window position.\n\t\tfunction deflate_slow(flush) {\n\t\t\t// short hash_head = 0; // head of hash chain\n\t\t\tvar hash_head = 0; // head of hash chain\n\t\t\tvar bflush; // set if current block must be flushed\n\t\t\tvar max_insert;\n\n\t\t\t// Process the input block.\n\t\t\twhile (true) {\n\t\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t\t// string following the next match.\n\n\t\t\t\tif (lookahead < MIN_LOOKAHEAD) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t}\n\n\t\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\t\tprev_length = match_length;\n\t\t\t\tprev_match = match_start;\n\t\t\t\tmatch_length = MIN_MATCH - 1;\n\n\t\t\t\tif (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t\t// of the string with itself at the start of the input file).\n\n\t\t\t\t\tif (strategy != Z_HUFFMAN_ONLY) {\n\t\t\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t\t}\n\t\t\t\t\t// longest_match() sets match_start\n\n\t\t\t\t\tif (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {\n\n\t\t\t\t\t\t// If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t\t\t\t// but we will ignore the current match anyway.\n\t\t\t\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If there was a match at the previous step and the current\n\t\t\t\t// match is not better, output the previous match:\n\t\t\t\tif (prev_length >= MIN_MATCH && match_length <= prev_length) {\n\t\t\t\t\tmax_insert = strstart + lookahead - MIN_MATCH;\n\t\t\t\t\t// Do not insert strings in hash table beyond this.\n\n\t\t\t\t\t// check_match(strstart-1, prev_match, prev_length);\n\n\t\t\t\t\tbflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);\n\n\t\t\t\t\t// Insert in hash table all strings up to the end of the match.\n\t\t\t\t\t// strstart-1 and strstart are already inserted. If there is not\n\t\t\t\t\t// enough lookahead, the last two strings are not inserted in\n\t\t\t\t\t// the hash table.\n\t\t\t\t\tlookahead -= prev_length - 1;\n\t\t\t\t\tprev_length -= 2;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (++strstart <= max_insert) {\n\t\t\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (--prev_length !== 0);\n\t\t\t\t\tmatch_available = 0;\n\t\t\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\t\t\tstrstart++;\n\n\t\t\t\t\tif (bflush) {\n\t\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t} else if (match_available !== 0) {\n\n\t\t\t\t\t// If there was no match at the previous position, output a\n\t\t\t\t\t// single literal. If there was a match but the current match\n\t\t\t\t\t// is longer, truncate the previous match to a single literal.\n\n\t\t\t\t\tbflush = _tr_tally(0, window[strstart - 1] & 0xff);\n\n\t\t\t\t\tif (bflush) {\n\t\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\t}\n\t\t\t\t\tstrstart++;\n\t\t\t\t\tlookahead--;\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t} else {\n\t\t\t\t\t// There is no previous match to compare with, wait for\n\t\t\t\t\t// the next step to decide.\n\n\t\t\t\t\tmatch_available = 1;\n\t\t\t\t\tstrstart++;\n\t\t\t\t\tlookahead--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match_available !== 0) {\n\t\t\t\tbflush = _tr_tally(0, window[strstart - 1] & 0xff);\n\t\t\t\tmatch_available = 0;\n\t\t\t}\n\t\t\tflush_block_only(flush == Z_FINISH);\n\n\t\t\tif (strm.avail_out === 0) {\n\t\t\t\tif (flush == Z_FINISH)\n\t\t\t\t\treturn FinishStarted;\n\t\t\t\telse\n\t\t\t\t\treturn NeedMore;\n\t\t\t}\n\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\tfunction deflateReset(strm) {\n\t\t\tstrm.total_in = strm.total_out = 0;\n\t\t\tstrm.msg = null; //\n\t\t\t\n\t\t\tthat.pending = 0;\n\t\t\tthat.pending_out = 0;\n\n\t\t\tstatus = BUSY_STATE;\n\n\t\t\tlast_flush = Z_NO_FLUSH;\n\n\t\t\ttr_init();\n\t\t\tlm_init();\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {\n\t\t\tif (!_method)\n\t\t\t\t_method = Z_DEFLATED;\n\t\t\tif (!memLevel)\n\t\t\t\tmemLevel = DEF_MEM_LEVEL;\n\t\t\tif (!_strategy)\n\t\t\t\t_strategy = Z_DEFAULT_STRATEGY;\n\n\t\t\t// byte[] my_version=ZLIB_VERSION;\n\n\t\t\t//\n\t\t\t// if (!version || version[0] != my_version[0]\n\t\t\t// || stream_size != sizeof(z_stream)) {\n\t\t\t// return Z_VERSION_ERROR;\n\t\t\t// }\n\n\t\t\tstrm.msg = null;\n\n\t\t\tif (_level == Z_DEFAULT_COMPRESSION)\n\t\t\t\t_level = 6;\n\n\t\t\tif (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0\n\t\t\t\t\t|| _strategy > Z_HUFFMAN_ONLY) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tstrm.dstate = that;\n\n\t\t\tw_bits = bits;\n\t\t\tw_size = 1 << w_bits;\n\t\t\tw_mask = w_size - 1;\n\n\t\t\thash_bits = memLevel + 7;\n\t\t\thash_size = 1 << hash_bits;\n\t\t\thash_mask = hash_size - 1;\n\t\t\thash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n\t\t\twindow = new Uint8Array(w_size * 2);\n\t\t\tprev = [];\n\t\t\thead = [];\n\n\t\t\tlit_bufsize = 1 << (memLevel + 6); // 16K elements by default\n\n\t\t\t// We overlay pending_buf and d_buf+l_buf. This works since the average\n\t\t\t// output size for (length,distance) codes is <= 24 bits.\n\t\t\tthat.pending_buf = new Uint8Array(lit_bufsize * 4);\n\t\t\tpending_buf_size = lit_bufsize * 4;\n\n\t\t\td_buf = Math.floor(lit_bufsize / 2);\n\t\t\tl_buf = (1 + 2) * lit_bufsize;\n\n\t\t\tlevel = _level;\n\n\t\t\tstrategy = _strategy;\n\t\t\tmethod = _method & 0xff;\n\n\t\t\treturn deflateReset(strm);\n\t\t};\n\n\t\tthat.deflateEnd = function() {\n\t\t\tif (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\t// Deallocate in reverse order of allocations:\n\t\t\tthat.pending_buf = null;\n\t\t\thead = null;\n\t\t\tprev = null;\n\t\t\twindow = null;\n\t\t\t// free\n\t\t\tthat.dstate = null;\n\t\t\treturn status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n\t\t};\n\n\t\tthat.deflateParams = function(strm, _level, _strategy) {\n\t\t\tvar err = Z_OK;\n\n\t\t\tif (_level == Z_DEFAULT_COMPRESSION) {\n\t\t\t\t_level = 6;\n\t\t\t}\n\t\t\tif (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tif (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {\n\t\t\t\t// Flush the last buffer:\n\t\t\t\terr = strm.deflate(Z_PARTIAL_FLUSH);\n\t\t\t}\n\n\t\t\tif (level != _level) {\n\t\t\t\tlevel = _level;\n\t\t\t\tmax_lazy_match = config_table[level].max_lazy;\n\t\t\t\tgood_match = config_table[level].good_length;\n\t\t\t\tnice_match = config_table[level].nice_length;\n\t\t\t\tmax_chain_length = config_table[level].max_chain;\n\t\t\t}\n\t\t\tstrategy = _strategy;\n\t\t\treturn err;\n\t\t};\n\n\t\tthat.deflateSetDictionary = function(strm, dictionary, dictLength) {\n\t\t\tvar length = dictLength;\n\t\t\tvar n, index = 0;\n\n\t\t\tif (!dictionary || status != INIT_STATE)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tif (length < MIN_MATCH)\n\t\t\t\treturn Z_OK;\n\t\t\tif (length > w_size - MIN_LOOKAHEAD) {\n\t\t\t\tlength = w_size - MIN_LOOKAHEAD;\n\t\t\t\tindex = dictLength - length; // use the tail of the dictionary\n\t\t\t}\n\t\t\twindow.set(dictionary.subarray(index, index + length), 0);\n\n\t\t\tstrstart = length;\n\t\t\tblock_start = length;\n\n\t\t\t// Insert all strings in the hash table (except for the last two bytes).\n\t\t\t// s->lookahead stays null, so s->ins_h will be recomputed at the next\n\t\t\t// call of fill_window.\n\n\t\t\tins_h = window[0] & 0xff;\n\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;\n\n\t\t\tfor (n = 0; n <= length - MIN_MATCH; n++) {\n\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\tprev[n & w_mask] = head[ins_h];\n\t\t\t\thead[ins_h] = n;\n\t\t\t}\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.deflate = function(_strm, flush) {\n\t\t\tvar i, header, level_flags, old_flush, bstate;\n\n\t\t\tif (flush > Z_FINISH || flush < 0) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tif (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\tif (_strm.avail_out === 0) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\tstrm = _strm; // just in case\n\t\t\told_flush = last_flush;\n\t\t\tlast_flush = flush;\n\n\t\t\t// Write the zlib header\n\t\t\tif (status == INIT_STATE) {\n\t\t\t\theader = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;\n\t\t\t\tlevel_flags = ((level - 1) & 0xff) >> 1;\n\n\t\t\t\tif (level_flags > 3)\n\t\t\t\t\tlevel_flags = 3;\n\t\t\t\theader |= (level_flags << 6);\n\t\t\t\tif (strstart !== 0)\n\t\t\t\t\theader |= PRESET_DICT;\n\t\t\t\theader += 31 - (header % 31);\n\n\t\t\t\tstatus = BUSY_STATE;\n\t\t\t\tputShortMSB(header);\n\t\t\t}\n\n\t\t\t// Flush as much pending output as possible\n\t\t\tif (that.pending !== 0) {\n\t\t\t\tstrm.flush_pending();\n\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t// console.log(\" avail_out==0\");\n\t\t\t\t\t// Since avail_out is 0, deflate will be called again with\n\t\t\t\t\t// more output space, but possibly with both pending and\n\t\t\t\t\t// avail_in equal to zero. There won't be anything to do,\n\t\t\t\t\t// but this is not an error situation so make sure we\n\t\t\t\t\t// return OK instead of BUF_ERROR at next call of deflate:\n\t\t\t\t\tlast_flush = -1;\n\t\t\t\t\treturn Z_OK;\n\t\t\t\t}\n\n\t\t\t\t// Make sure there is something to do and avoid duplicate\n\t\t\t\t// consecutive\n\t\t\t\t// flushes. For repeated and useless calls with Z_FINISH, we keep\n\t\t\t\t// returning Z_STREAM_END instead of Z_BUFF_ERROR.\n\t\t\t} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {\n\t\t\t\tstrm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\t// User must not provide more input after the first FINISH:\n\t\t\tif (status == FINISH_STATE && strm.avail_in !== 0) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\t// Start a new block or continue the current one.\n\t\t\tif (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {\n\t\t\t\tbstate = -1;\n\t\t\t\tswitch (config_table[level].func) {\n\t\t\t\tcase STORED:\n\t\t\t\t\tbstate = deflate_stored(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FAST:\n\t\t\t\t\tbstate = deflate_fast(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SLOW:\n\t\t\t\t\tbstate = deflate_slow(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t}\n\n\t\t\t\tif (bstate == FinishStarted || bstate == FinishDone) {\n\t\t\t\t\tstatus = FINISH_STATE;\n\t\t\t\t}\n\t\t\t\tif (bstate == NeedMore || bstate == FinishStarted) {\n\t\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t\tlast_flush = -1; // avoid BUF_ERROR next call, see above\n\t\t\t\t\t}\n\t\t\t\t\treturn Z_OK;\n\t\t\t\t\t// If flush != Z_NO_FLUSH && avail_out === 0, the next call\n\t\t\t\t\t// of deflate should use the same flush parameter to make sure\n\t\t\t\t\t// that the flush is complete. So we don't have to output an\n\t\t\t\t\t// empty block here, this will be done at next call. This also\n\t\t\t\t\t// ensures that for a very small output buffer, we emit at most\n\t\t\t\t\t// one empty block.\n\t\t\t\t}\n\n\t\t\t\tif (bstate == BlockDone) {\n\t\t\t\t\tif (flush == Z_PARTIAL_FLUSH) {\n\t\t\t\t\t\t_tr_align();\n\t\t\t\t\t} else { // FULL_FLUSH or SYNC_FLUSH\n\t\t\t\t\t\t_tr_stored_block(0, 0, false);\n\t\t\t\t\t\t// For a full flush, this empty block will be recognized\n\t\t\t\t\t\t// as a special marker by inflate_sync().\n\t\t\t\t\t\tif (flush == Z_FULL_FLUSH) {\n\t\t\t\t\t\t\t// state.head[s.hash_size-1]=0;\n\t\t\t\t\t\t\tfor (i = 0; i < hash_size/*-1*/; i++)\n\t\t\t\t\t\t\t\t// forget history\n\t\t\t\t\t\t\t\thead[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstrm.flush_pending();\n\t\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t\tlast_flush = -1; // avoid BUF_ERROR at next call, see above\n\t\t\t\t\t\treturn Z_OK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flush != Z_FINISH)\n\t\t\t\treturn Z_OK;\n\t\t\treturn Z_STREAM_END;\n\t\t};\n\t}\n\n\t// ZStream\n\n\tfunction ZStream() {\n\t\tvar that = this;\n\t\tthat.next_in_index = 0;\n\t\tthat.next_out_index = 0;\n\t\t// that.next_in; // next input byte\n\t\tthat.avail_in = 0; // number of bytes available at next_in\n\t\tthat.total_in = 0; // total nb of input bytes read so far\n\t\t// that.next_out; // next output byte should be put there\n\t\tthat.avail_out = 0; // remaining free space at next_out\n\t\tthat.total_out = 0; // total nb of bytes output so far\n\t\t// that.msg;\n\t\t// that.dstate;\n\t}\n\n\tZStream.prototype = {\n\t\tdeflateInit : function(level, bits) {\n\t\t\tvar that = this;\n\t\t\tthat.dstate = new Deflate();\n\t\t\tif (!bits)\n\t\t\t\tbits = MAX_BITS;\n\t\t\treturn that.dstate.deflateInit(that, level, bits);\n\t\t},\n\n\t\tdeflate : function(flush) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\treturn that.dstate.deflate(that, flush);\n\t\t},\n\n\t\tdeflateEnd : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tvar ret = that.dstate.deflateEnd();\n\t\t\tthat.dstate = null;\n\t\t\treturn ret;\n\t\t},\n\n\t\tdeflateParams : function(level, strategy) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.dstate.deflateParams(that, level, strategy);\n\t\t},\n\n\t\tdeflateSetDictionary : function(dictionary, dictLength) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.dstate.deflateSetDictionary(that, dictionary, dictLength);\n\t\t},\n\n\t\t// Read a new buffer from the current input stream, update the\n\t\t// total number of bytes read. All deflate() input goes through\n\t\t// this function so some applications may wish to modify it to avoid\n\t\t// allocating a large strm->next_in buffer and copying from it.\n\t\t// (See also flush_pending()).\n\t\tread_buf : function(buf, start, size) {\n\t\t\tvar that = this;\n\t\t\tvar len = that.avail_in;\n\t\t\tif (len > size)\n\t\t\t\tlen = size;\n\t\t\tif (len === 0)\n\t\t\t\treturn 0;\n\t\t\tthat.avail_in -= len;\n\t\t\tbuf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);\n\t\t\tthat.next_in_index += len;\n\t\t\tthat.total_in += len;\n\t\t\treturn len;\n\t\t},\n\n\t\t// Flush as much pending output as possible. All deflate() output goes\n\t\t// through this function so some applications may wish to modify it\n\t\t// to avoid allocating a large strm->next_out buffer and copying into it.\n\t\t// (See also read_buf()).\n\t\tflush_pending : function() {\n\t\t\tvar that = this;\n\t\t\tvar len = that.dstate.pending;\n\n\t\t\tif (len > that.avail_out)\n\t\t\t\tlen = that.avail_out;\n\t\t\tif (len === 0)\n\t\t\t\treturn;\n\n\t\t\t// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index\n\t\t\t// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +\n\t\t\t// len)) {\n\t\t\t// console.log(that.dstate.pending_buf.length + \", \" + that.dstate.pending_out + \", \" + that.next_out.length + \", \" +\n\t\t\t// that.next_out_index + \", \" + len);\n\t\t\t// console.log(\"avail_out=\" + that.avail_out);\n\t\t\t// }\n\n\t\t\tthat.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);\n\n\t\t\tthat.next_out_index += len;\n\t\t\tthat.dstate.pending_out += len;\n\t\t\tthat.total_out += len;\n\t\t\tthat.avail_out -= len;\n\t\t\tthat.dstate.pending -= len;\n\t\t\tif (that.dstate.pending === 0) {\n\t\t\t\tthat.dstate.pending_out = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Deflater\n\n\tfunction Deflater(options) {\n\t\tvar that = this;\n\t\tvar z = new ZStream();\n\t\tvar bufsize = 512;\n\t\tvar flush = Z_NO_FLUSH;\n\t\tvar buf = new Uint8Array(bufsize);\n\t\tvar level = options ? options.level : Z_DEFAULT_COMPRESSION;\n\t\tif (typeof level == \"undefined\")\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\tz.deflateInit(level);\n\t\tz.next_out = buf;\n\n\t\tthat.append = function(data, onprogress) {\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\n\t\t\tif (!data.length)\n\t\t\t\treturn;\n\t\t\tz.next_in_index = 0;\n\t\t\tz.next_in = data;\n\t\t\tz.avail_in = data.length;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\terr = z.deflate(flush);\n\t\t\t\tif (err != Z_OK)\n\t\t\t\t\tthrow new Error(\"deflating: \" + z.msg);\n\t\t\t\tif (z.next_out_index)\n\t\t\t\t\tif (z.next_out_index == bufsize)\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n\t\t\t\t\tonprogress(z.next_in_index);\n\t\t\t\t\tlastIndex = z.next_in_index;\n\t\t\t\t}\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t\tthat.flush = function() {\n\t\t\tvar err, buffers = [], bufferIndex = 0, bufferSize = 0, array;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\terr = z.deflate(Z_FINISH);\n\t\t\t\tif (err != Z_STREAM_END && err != Z_OK)\n\t\t\t\t\tthrow new Error(\"deflating: \" + z.msg);\n\t\t\t\tif (bufsize - z.avail_out > 0)\n\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tz.deflateEnd();\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t}\n\n\t// 'zip' may not be defined in z-worker and some tests\n\tvar env = global.zip || global;\n\tenv.Deflater = env._jzlib_Deflater = Deflater;\n})(this);\n")],
  inflater: [zWorker, createUrl("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n\n(function(global) {\n\t\"use strict\";\n\n\t// Global\n\tvar MAX_BITS = 15;\n\n\tvar Z_OK = 0;\n\tvar Z_STREAM_END = 1;\n\tvar Z_NEED_DICT = 2;\n\tvar Z_STREAM_ERROR = -2;\n\tvar Z_DATA_ERROR = -3;\n\tvar Z_MEM_ERROR = -4;\n\tvar Z_BUF_ERROR = -5;\n\n\tvar inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\n\t\t\t0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\n\n\tvar MANY = 1440;\n\n\t// JZlib version : \"1.0.2\"\n\tvar Z_NO_FLUSH = 0;\n\tvar Z_FINISH = 4;\n\n\t// InfTree\n\tvar fixed_bl = 9;\n\tvar fixed_bd = 5;\n\n\tvar fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\n\t\t\t0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\n\t\t\t0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\n\t\t\t0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\n\t\t\t0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\n\t\t\t35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\n\t\t\t26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\n\t\t\t7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\n\t\t\t8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\n\t\t\t8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\n\t\t\t0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\n\t\t\t81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\n\t\t\t0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\n\t\t\t84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\n\t\t\t0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\n\t\t\t80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\n\t\t\t0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\n\t\t\t0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\n\t\t\t0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\n\t\t\t193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\n\t\t\t120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\n\t\t\t227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\n\t\t\t92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\n\t\t\t249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\n\t\t\t130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\n\t\t\t181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\n\t\t\t102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\n\t\t\t221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\n\t\t\t8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\n\t\t\t147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\n\t\t\t85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\n\t\t\t235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\n\t\t\t141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\n\t\t\t167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\n\t\t\t107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\n\t\t\t207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\n\t\t\t127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\n\tvar fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\n\t\t\t8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\n\t\t\t24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\n\n\t// Tables for deflate from PKZIP's appnote.txt.\n\tvar cplens = [ // Copy lengths for literal codes 257..285\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\n\n\t// see note #13 above about 258\n\tvar cplext = [ // Extra bits for literal codes 257..285\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n\t];\n\n\tvar cpdist = [ // Copy offsets for distance codes 0..29\n\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\n\n\tvar cpdext = [ // Extra bits for distance codes\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\n\n\t// If BMAX needs to be larger than 16, then h and x[] should be uLong.\n\tvar BMAX = 15; // maximum bit length of any code\n\n\tfunction InfTree() {\n\t\tvar that = this;\n\n\t\tvar hn; // hufts used in space\n\t\tvar v; // work area for huft_build\n\t\tvar c; // bit length count table\n\t\tvar r; // table entry for structure assignment\n\t\tvar u; // table stack\n\t\tvar x; // bit offsets, then code stack\n\n\t\tfunction huft_build(b, // code lengths in bits (all assumed <=\n\t\t// BMAX)\n\t\tbindex, n, // number of codes (assumed <= 288)\n\t\ts, // number of simple-valued codes (0..s-1)\n\t\td, // list of base values for non-simple codes\n\t\te, // list of extra bits for non-simple codes\n\t\tt, // result: starting table\n\t\tm, // maximum lookup bits, returns actual\n\t\thp,// space for trees\n\t\thn,// hufts used in space\n\t\tv // working area: values in order of bit length\n\t\t) {\n\t\t\t// Given a list of code lengths and a maximum table size, make a set of\n\t\t\t// tables to decode that set of codes. Return Z_OK on success,\n\t\t\t// Z_BUF_ERROR\n\t\t\t// if the given code set is incomplete (the tables are still built in\n\t\t\t// this\n\t\t\t// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\n\t\t\t// of\n\t\t\t// lengths), or Z_MEM_ERROR if not enough memory.\n\n\t\t\tvar a; // counter for codes of length k\n\t\t\tvar f; // i repeats in table every f entries\n\t\t\tvar g; // maximum code length\n\t\t\tvar h; // table level\n\t\t\tvar i; // counter, current code\n\t\t\tvar j; // counter\n\t\t\tvar k; // number of bits in current code\n\t\t\tvar l; // bits per table (returned in m)\n\t\t\tvar mask; // (1 << w) - 1, to avoid cc -O bug on HP\n\t\t\tvar p; // pointer into c[], b[], or v[]\n\t\t\tvar q; // points to current table\n\t\t\tvar w; // bits before this table == (l * h)\n\t\t\tvar xp; // pointer into x\n\t\t\tvar y; // number of dummy codes added\n\t\t\tvar z; // number of entries in current table\n\n\t\t\t// Generate counts for each bit length\n\n\t\t\tp = 0;\n\t\t\ti = n;\n\t\t\tdo {\n\t\t\t\tc[b[bindex + p]]++;\n\t\t\t\tp++;\n\t\t\t\ti--; // assume all entries <= BMAX\n\t\t\t} while (i !== 0);\n\n\t\t\tif (c[0] == n) { // null input--all zero length codes\n\t\t\t\tt[0] = -1;\n\t\t\t\tm[0] = 0;\n\t\t\t\treturn Z_OK;\n\t\t\t}\n\n\t\t\t// Find minimum and maximum length, bound *m by those\n\t\t\tl = m[0];\n\t\t\tfor (j = 1; j <= BMAX; j++)\n\t\t\t\tif (c[j] !== 0)\n\t\t\t\t\tbreak;\n\t\t\tk = j; // minimum code length\n\t\t\tif (l < j) {\n\t\t\t\tl = j;\n\t\t\t}\n\t\t\tfor (i = BMAX; i !== 0; i--) {\n\t\t\t\tif (c[i] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg = i; // maximum code length\n\t\t\tif (l > i) {\n\t\t\t\tl = i;\n\t\t\t}\n\t\t\tm[0] = l;\n\n\t\t\t// Adjust last length count to fill out codes, if needed\n\t\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\t\t\tif ((y -= c[j]) < 0) {\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((y -= c[i]) < 0) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tc[i] += y;\n\n\t\t\t// Generate starting offsets into the value table for each length\n\t\t\tx[1] = j = 0;\n\t\t\tp = 1;\n\t\t\txp = 2;\n\t\t\twhile (--i !== 0) { // note that i == g from above\n\t\t\t\tx[xp] = (j += c[p]);\n\t\t\t\txp++;\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\t// Make a table of values in order of bit lengths\n\t\t\ti = 0;\n\t\t\tp = 0;\n\t\t\tdo {\n\t\t\t\tif ((j = b[bindex + p]) !== 0) {\n\t\t\t\t\tv[x[j]++] = i;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t} while (++i < n);\n\t\t\tn = x[g]; // set n to length of v\n\n\t\t\t// Generate the Huffman codes and for each, make the table entries\n\t\t\tx[0] = i = 0; // first Huffman code is zero\n\t\t\tp = 0; // grab values in bit order\n\t\t\th = -1; // no tables yet--level -1\n\t\t\tw = -l; // bits decoded == (l * h)\n\t\t\tu[0] = 0; // just to keep compilers happy\n\t\t\tq = 0; // ditto\n\t\t\tz = 0; // ditto\n\n\t\t\t// go through the bit lengths (k already is bits in shortest code)\n\t\t\tfor (; k <= g; k++) {\n\t\t\t\ta = c[k];\n\t\t\t\twhile (a-- !== 0) {\n\t\t\t\t\t// here i is the Huffman code of length k bits for value *p\n\t\t\t\t\t// make tables up to required level\n\t\t\t\t\twhile (k > w + l) {\n\t\t\t\t\t\th++;\n\t\t\t\t\t\tw += l; // previous table always l bits\n\t\t\t\t\t\t// compute minimum size table less than or equal to l bits\n\t\t\t\t\t\tz = g - w;\n\t\t\t\t\t\tz = (z > l) ? l : z; // table size upper limit\n\t\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n\t\t\t\t\t\t\t// too few codes for\n\t\t\t\t\t\t\t// k-w bit table\n\t\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\n\t\t\t\t\t\t\txp = k;\n\t\t\t\t\t\t\tif (j < z) {\n\t\t\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\n\t\t\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp])\n\t\t\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\n\t\t\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = 1 << j; // table entries for j-bit table\n\n\t\t\t\t\t\t// allocate new table\n\t\t\t\t\t\tif (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\n\t\t\t\t\t\t\treturn Z_DATA_ERROR; // overflow of MANY\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu[h] = q = /* hp+ */hn[0]; // DEBUG\n\t\t\t\t\t\thn[0] += z;\n\n\t\t\t\t\t\t// connect to last table, if there is one\n\t\t\t\t\t\tif (h !== 0) {\n\t\t\t\t\t\t\tx[h] = i; // save pattern for backing up\n\t\t\t\t\t\t\tr[0] = /* (byte) */j; // bits in this table\n\t\t\t\t\t\t\tr[1] = /* (byte) */l; // bits to dump before this table\n\t\t\t\t\t\t\tj = i >>> (w - l);\n\t\t\t\t\t\t\tr[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\n\t\t\t\t\t\t\thp.set(r, (u[h - 1] + j) * 3);\n\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t// last\n\t\t\t\t\t\t\t// table\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt[0] = q; // first table is returned result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// set up table entry in r\n\t\t\t\t\tr[1] = /* (byte) */(k - w);\n\t\t\t\t\tif (p >= n) {\n\t\t\t\t\t\tr[0] = 128 + 64; // out of values--invalid code\n\t\t\t\t\t} else if (v[p] < s) {\n\t\t\t\t\t\tr[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\n\t\t\t\t\t\t// end-of-block\n\t\t\t\t\t\tr[2] = v[p++]; // simple code is just the value\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\n\t\t\t\t\t\t// up in lists\n\t\t\t\t\t\tr[2] = d[v[p++] - s];\n\t\t\t\t\t}\n\n\t\t\t\t\t// fill code-like entries with r\n\t\t\t\t\tf = 1 << (k - w);\n\t\t\t\t\tfor (j = i >>> w; j < z; j += f) {\n\t\t\t\t\t\thp.set(r, (q + j) * 3);\n\t\t\t\t\t}\n\n\t\t\t\t\t// backwards increment the k-bit code i\n\t\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\n\t\t\t\t\t\ti ^= j;\n\t\t\t\t\t}\n\t\t\t\t\ti ^= j;\n\n\t\t\t\t\t// backup over finished tables\n\t\t\t\t\tmask = (1 << w) - 1; // needed on HP, cc -O bug\n\t\t\t\t\twhile ((i & mask) != x[h]) {\n\t\t\t\t\t\th--; // don't need to update q\n\t\t\t\t\t\tw -= l;\n\t\t\t\t\t\tmask = (1 << w) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return Z_BUF_ERROR if we were given an incomplete table\n\t\t\treturn y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n\t\t}\n\n\t\tfunction initWorkArea(vsize) {\n\t\t\tvar i;\n\t\t\tif (!hn) {\n\t\t\t\thn = []; // []; //new Array(1);\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t\tc = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t\tr = []; // new Array(3);\n\t\t\t\tu = new Int32Array(BMAX); // new Array(BMAX);\n\t\t\t\tx = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t}\n\t\t\tif (v.length < vsize) {\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t}\n\t\t\tfor (i = 0; i < vsize; i++) {\n\t\t\t\tv[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < BMAX + 1; i++) {\n\t\t\t\tc[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tr[i] = 0;\n\t\t\t}\n\t\t\t// for(int i=0; i<BMAX; i++){u[i]=0;}\n\t\t\tu.set(c.subarray(0, BMAX), 0);\n\t\t\t// for(int i=0; i<BMAX+1; i++){x[i]=0;}\n\t\t\tx.set(c.subarray(0, BMAX + 1), 0);\n\t\t}\n\n\t\tthat.inflate_trees_bits = function(c, // 19 code lengths\n\t\tbb, // bits tree desired/actual depth\n\t\ttb, // bits tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\t\t\tinitWorkArea(19);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\n\n\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\tz.msg = \"oversubscribed dynamic bit lengths tree\";\n\t\t\t} else if (result == Z_BUF_ERROR || bb[0] === 0) {\n\t\t\t\tz.msg = \"incomplete dynamic bit lengths tree\";\n\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tthat.inflate_trees_dynamic = function(nl, // number of literal/length codes\n\t\tnd, // number of distance codes\n\t\tc, // that many (total) code lengths\n\t\tbl, // literal desired/actual bit depth\n\t\tbd, // distance desired/actual bit depth\n\t\ttl, // literal/length tree result\n\t\ttd, // distance tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\n\t\t\t// build literal/length tree\n\t\t\tinitWorkArea(288);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\n\t\t\tif (result != Z_OK || bl[0] === 0) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed literal/length tree\";\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete literal/length tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// build distance tree\n\t\t\tinitWorkArea(288);\n\t\t\tresult = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\n\n\t\t\tif (result != Z_OK || (bd[0] === 0 && nl > 257)) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed distance tree\";\n\t\t\t\t} else if (result == Z_BUF_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete distance tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"empty distance tree with lengths\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn Z_OK;\n\t\t};\n\n\t}\n\n\tInfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\n\tbd, // distance desired/actual bit depth\n\ttl,// literal/length tree result\n\ttd// distance tree result\n\t) {\n\t\tbl[0] = fixed_bl;\n\t\tbd[0] = fixed_bd;\n\t\ttl[0] = fixed_tl;\n\t\ttd[0] = fixed_td;\n\t\treturn Z_OK;\n\t};\n\n\t// InfCodes\n\n\t// waiting for \"i:\"=input,\n\t// \"o:\"=output,\n\t// \"x:\"=nothing\n\tvar START = 0; // x: set up for LEN\n\tvar LEN = 1; // i: get length/literal/eob next\n\tvar LENEXT = 2; // i: getting length extra (have base)\n\tvar DIST = 3; // i: get distance next\n\tvar DISTEXT = 4;// i: getting distance extra\n\tvar COPY = 5; // o: copying bytes in window, waiting\n\t// for space\n\tvar LIT = 6; // o: got literal, waiting for output\n\t// space\n\tvar WASH = 7; // o: got eob, possibly still output\n\t// waiting\n\tvar END = 8; // x: got eob and all data flushed\n\tvar BADCODE = 9;// x: got error\n\n\tfunction InfCodes() {\n\t\tvar that = this;\n\n\t\tvar mode; // current inflate_codes mode\n\n\t\t// mode dependent information\n\t\tvar len = 0;\n\n\t\tvar tree; // pointer into tree\n\t\tvar tree_index = 0;\n\t\tvar need = 0; // bits needed\n\n\t\tvar lit = 0;\n\n\t\t// if EXT or COPY, where and how much\n\t\tvar get = 0; // bits to get for extra\n\t\tvar dist = 0; // distance back to copy from\n\n\t\tvar lbits = 0; // ltree bits decoded per branch\n\t\tvar dbits = 0; // dtree bits decoder per branch\n\t\tvar ltree; // literal/length/eob tree\n\t\tvar ltree_index = 0; // literal/length/eob tree\n\t\tvar dtree; // distance tree\n\t\tvar dtree_index = 0; // distance tree\n\n\t\t// Called with number of bytes left to write in window at least 258\n\t\t// (the maximum string length) and number of input bytes available\n\t\t// at least ten. The ten bytes are six bytes for the longest length/\n\t\t// distance pair plus four bytes for overloading the bit buffer.\n\n\t\tfunction inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\n\t\t\tvar t; // temporary pointer\n\t\t\tvar tp; // temporary pointer\n\t\t\tvar tp_index; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar ml; // mask for literal/length tree\n\t\t\tvar md; // mask for distance tree\n\t\t\tvar c; // bytes to copy\n\t\t\tvar d; // distance back to copy from\n\t\t\tvar r; // copy source pointer\n\n\t\t\tvar tp_index_t_3; // (tp_index+t)*3\n\n\t\t\t// load input, output, bit values\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// initialize masks\n\t\t\tml = inflate_mask[bl];\n\t\t\tmd = inflate_mask[bd];\n\n\t\t\t// do until not enough input or output space for fast loop\n\t\t\tdo { // assume called with m >= 258 && n >= 10\n\t\t\t\t// get literal/length code\n\t\t\t\twhile (k < (20)) { // max bits for literal/length code\n\t\t\t\t\tn--;\n\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\tk += 8;\n\t\t\t\t}\n\n\t\t\t\tt = b & ml;\n\t\t\t\ttp = tl;\n\t\t\t\ttp_index = tl_index;\n\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\tm--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdo {\n\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\tc = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\n\n\t\t\t\t\t\tb >>= e;\n\t\t\t\t\t\tk -= e;\n\n\t\t\t\t\t\t// decode distance base of block to copy\n\t\t\t\t\t\twhile (k < (15)) { // max bits for distance code\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt = b & md;\n\t\t\t\t\t\ttp = td;\n\t\t\t\t\t\ttp_index = td_index;\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\te = tp[tp_index_t_3];\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\t\t\t// get extra bits to add to distance base\n\t\t\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\t\t\twhile (k < (e)) { // get extra bits (up to 13)\n\t\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\td = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n\t\t\t\t\t\t\t\tb >>= (e);\n\t\t\t\t\t\t\t\tk -= (e);\n\n\t\t\t\t\t\t\t\t// do the copy\n\t\t\t\t\t\t\t\tm -= c;\n\t\t\t\t\t\t\t\tif (q >= d) { // offset before dest\n\t\t\t\t\t\t\t\t\t// just copy\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tif (q - r > 0 && 2 > (q - r)) {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // minimum\n\t\t\t\t\t\t\t\t\t\t// count is\n\t\t\t\t\t\t\t\t\t\t// three,\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // so unroll\n\t\t\t\t\t\t\t\t\t\t// loop a\n\t\t\t\t\t\t\t\t\t\t// little\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + 2), q);\n\t\t\t\t\t\t\t\t\t\tq += 2;\n\t\t\t\t\t\t\t\t\t\tr += 2;\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else { // else offset after destination\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tr += s.end; // force pointer in window\n\t\t\t\t\t\t\t\t\t} while (r < 0); // covers invalid distances\n\t\t\t\t\t\t\t\t\te = s.end - r;\n\t\t\t\t\t\t\t\t\tif (c > e) { // if source crosses,\n\t\t\t\t\t\t\t\t\t\tc -= e; // wrapped copy\n\t\t\t\t\t\t\t\t\t\tif (q - r > 0 && e > (q - r)) {\n\t\t\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t\t\t} while (--e !== 0);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + e), q);\n\t\t\t\t\t\t\t\t\t\t\tq += e;\n\t\t\t\t\t\t\t\t\t\t\tr += e;\n\t\t\t\t\t\t\t\t\t\t\te = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tr = 0; // copy rest from start of window\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// copy all or what's left\n\t\t\t\t\t\t\t\tif (q - r > 0 && c > (q - r)) {\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t} while (--c !== 0);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + c), q);\n\t\t\t\t\t\t\t\t\tq += c;\n\t\t\t\t\t\t\t\t\tr += c;\n\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if ((e & 64) === 0) {\n\t\t\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\t\t\te = tp[tp_index_t_3];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tz.msg = \"invalid distance code\";\n\n\t\t\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\t\t\tn += c;\n\t\t\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (true);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((e & 64) === 0) {\n\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\tm--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ((e & 32) !== 0) {\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz.msg = \"invalid literal/length code\";\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} while (true);\n\t\t\t} while (m >= 258 && n >= 10);\n\n\t\t\t// not enough input or output--restore pointers and return\n\t\t\tc = z.avail_in - n;\n\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\tn += c;\n\t\t\tp -= c;\n\t\t\tk -= c << 3;\n\n\t\t\ts.bitb = b;\n\t\t\ts.bitk = k;\n\t\t\tz.avail_in = n;\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\ts.write = q;\n\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.init = function(bl, bd, tl, tl_index, td, td_index) {\n\t\t\tmode = START;\n\t\t\tlbits = /* (byte) */bl;\n\t\t\tdbits = /* (byte) */bd;\n\t\t\tltree = tl;\n\t\t\tltree_index = tl_index;\n\t\t\tdtree = td;\n\t\t\tdtree_index = td_index;\n\t\t\ttree = null;\n\t\t};\n\n\t\tthat.proc = function(s, z, r) {\n\t\t\tvar j; // temporary storage\n\t\t\tvar tindex; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b = 0; // bit buffer\n\t\t\tvar k = 0; // bits in bit buffer\n\t\t\tvar p = 0; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar f; // pointer to copy strings from\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// process input and output based on current state\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n\t\t\t\tcase START: // x: set up for LEN\n\t\t\t\t\tif (m >= 258 && n >= 10) {\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\tr = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\n\n\t\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\t\tb = s.bitb;\n\t\t\t\t\t\tk = s.bitk;\n\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\tif (r != Z_OK) {\n\t\t\t\t\t\t\tmode = r == Z_STREAM_END ? WASH : BADCODE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tneed = lbits;\n\t\t\t\t\ttree = ltree;\n\t\t\t\t\ttree_index = ltree_index;\n\n\t\t\t\t\tmode = LEN;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase LEN: // i: get length/literal/eob next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>>= (tree[tindex + 1]);\n\t\t\t\t\tk -= (tree[tindex + 1]);\n\n\t\t\t\t\te = tree[tindex];\n\n\t\t\t\t\tif (e === 0) { // literal\n\t\t\t\t\t\tlit = tree[tindex + 2];\n\t\t\t\t\t\tmode = LIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 16) !== 0) { // length\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tlen = tree[tindex + 2];\n\t\t\t\t\t\tmode = LENEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 32) !== 0) { // end of block\n\t\t\t\t\t\tmode = WASH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = \"invalid literal/length code\";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase LENEXT: // i: getting length extra (have base)\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tneed = dbits;\n\t\t\t\t\ttree = dtree;\n\t\t\t\t\ttree_index = dtree_index;\n\t\t\t\t\tmode = DIST;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DIST: // i: get distance next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>= tree[tindex + 1];\n\t\t\t\t\tk -= tree[tindex + 1];\n\n\t\t\t\t\te = (tree[tindex]);\n\t\t\t\t\tif ((e & 16) !== 0) { // distance\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tdist = tree[tindex + 2];\n\t\t\t\t\t\tmode = DISTEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = \"invalid distance code\";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase DISTEXT: // i: getting distance extra\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tdist += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tmode = COPY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase COPY: // o: copying bytes in window, waiting for space\n\t\t\t\t\tf = q - dist;\n\t\t\t\t\twhile (f < 0) { // modulo window size-\"while\" instead\n\t\t\t\t\t\tf += s.end; // of \"if\" handles invalid distances\n\t\t\t\t\t}\n\t\t\t\t\twhile (len !== 0) {\n\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.window[q++] = s.window[f++];\n\t\t\t\t\t\tm--;\n\n\t\t\t\t\t\tif (f == s.end)\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LIT: // o: got literal, waiting for output space\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\ts.window[q++] = /* (byte) */lit;\n\t\t\t\t\tm--;\n\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WASH: // o: got eob, possibly more output\n\t\t\t\t\tif (k > 7) { // return unused byte, if any\n\t\t\t\t\t\tk -= 8;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t\tp--; // can always return one\n\t\t\t\t\t}\n\n\t\t\t\t\ts.write = q;\n\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\tq = s.write;\n\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\tif (s.read != s.write) {\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = END;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase END:\n\t\t\t\t\tr = Z_STREAM_END;\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase BADCODE: // x: got error\n\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function() {\n\t\t\t// ZFREE(z, c);\n\t\t};\n\n\t}\n\n\t// InfBlocks\n\n\t// Table for deflate from PKZIP's appnote.txt.\n\tvar border = [ // Order of the bit length code lengths\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\tvar TYPE = 0; // get type bits (3, including end bit)\n\tvar LENS = 1; // get lengths for stored\n\tvar STORED = 2;// processing stored block\n\tvar TABLE = 3; // get table lengths\n\tvar BTREE = 4; // get bit lengths tree for a dynamic\n\t// block\n\tvar DTREE = 5; // get length, distance trees for a\n\t// dynamic block\n\tvar CODES = 6; // processing fixed or dynamic block\n\tvar DRY = 7; // output remaining window bytes\n\tvar DONELOCKS = 8; // finished last block, done\n\tvar BADBLOCKS = 9; // ot a data error--stuck here\n\n\tfunction InfBlocks(z, w) {\n\t\tvar that = this;\n\n\t\tvar mode = TYPE; // current inflate_block mode\n\n\t\tvar left = 0; // if STORED, bytes left to copy\n\n\t\tvar table = 0; // table lengths (14 bits)\n\t\tvar index = 0; // index into blens (or border)\n\t\tvar blens; // bit lengths of codes\n\t\tvar bb = [ 0 ]; // bit length tree depth\n\t\tvar tb = [ 0 ]; // bit length decoding tree\n\n\t\tvar codes = new InfCodes(); // if CODES, current state\n\n\t\tvar last = 0; // true if this block is the last block\n\n\t\tvar hufts = new Int32Array(MANY * 3); // single malloc for tree space\n\t\tvar check = 0; // check on output\n\t\tvar inftree = new InfTree();\n\n\t\tthat.bitk = 0; // bits in bit buffer\n\t\tthat.bitb = 0; // bit buffer\n\t\tthat.window = new Uint8Array(w); // sliding window\n\t\tthat.end = w; // one byte after sliding window\n\t\tthat.read = 0; // window read pointer\n\t\tthat.write = 0; // window write pointer\n\n\t\tthat.reset = function(z, c) {\n\t\t\tif (c)\n\t\t\t\tc[0] = check;\n\t\t\t// if (mode == BTREE || mode == DTREE) {\n\t\t\t// }\n\t\t\tif (mode == CODES) {\n\t\t\t\tcodes.free(z);\n\t\t\t}\n\t\t\tmode = TYPE;\n\t\t\tthat.bitk = 0;\n\t\t\tthat.bitb = 0;\n\t\t\tthat.read = that.write = 0;\n\t\t};\n\n\t\tthat.reset(z, null);\n\n\t\t// copy as much as possible from the sliding window to the output area\n\t\tthat.inflate_flush = function(z, r) {\n\t\t\tvar n;\n\t\t\tvar p;\n\t\t\tvar q;\n\n\t\t\t// local copies of source and destination pointers\n\t\t\tp = z.next_out_index;\n\t\t\tq = that.read;\n\n\t\t\t// compute number of bytes to copy as far as end of window\n\t\t\tn = /* (int) */((q <= that.write ? that.write : that.end) - q);\n\t\t\tif (n > z.avail_out)\n\t\t\t\tn = z.avail_out;\n\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\tr = Z_OK;\n\n\t\t\t// update counters\n\t\t\tz.avail_out -= n;\n\t\t\tz.total_out += n;\n\n\t\t\t// copy as far as end of window\n\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\tp += n;\n\t\t\tq += n;\n\n\t\t\t// see if more to copy at beginning of window\n\t\t\tif (q == that.end) {\n\t\t\t\t// wrap pointers\n\t\t\t\tq = 0;\n\t\t\t\tif (that.write == that.end)\n\t\t\t\t\tthat.write = 0;\n\n\t\t\t\t// compute bytes to copy\n\t\t\t\tn = that.write - q;\n\t\t\t\tif (n > z.avail_out)\n\t\t\t\t\tn = z.avail_out;\n\t\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t// update counters\n\t\t\t\tz.avail_out -= n;\n\t\t\t\tz.total_out += n;\n\n\t\t\t\t// copy\n\t\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\t\tp += n;\n\t\t\t\tq += n;\n\t\t\t}\n\n\t\t\t// update pointers\n\t\t\tz.next_out_index = p;\n\t\t\tthat.read = q;\n\n\t\t\t// done\n\t\t\treturn r;\n\t\t};\n\n\t\tthat.proc = function(z, r) {\n\t\t\tvar t; // temporary storage\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\n\t\t\tvar i;\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\t// {\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = that.bitb;\n\t\t\tk = that.bitk;\n\t\t\t// }\n\t\t\t// {\n\t\t\tq = that.write;\n\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t// }\n\n\t\t\t// process input based on current state\n\t\t\t// DEBUG dtree\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase TYPE:\n\n\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\t\t\t\t\tt = /* (int) */(b & 7);\n\t\t\t\t\tlast = t & 1;\n\n\t\t\t\t\tswitch (t >>> 1) {\n\t\t\t\t\tcase 0: // stored\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tt = k & 7; // go to byte boundary\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = LENS; // get length of stored block\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: // fixed\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tvar bl = []; // new Array(1);\n\t\t\t\t\t\tvar bd = []; // new Array(1);\n\t\t\t\t\t\tvar tl = [ [] ]; // new Array(1);\n\t\t\t\t\t\tvar td = [ [] ]; // new Array(1);\n\n\t\t\t\t\t\tInfTree.inflate_trees_fixed(bl, bd, tl, td);\n\t\t\t\t\t\tcodes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = CODES;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: // dynamic\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = TABLE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: // illegal\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"invalid block type\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LENS:\n\n\t\t\t\t\twhile (k < (32)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"invalid stored block lengths\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tleft = (b & 0xffff);\n\t\t\t\t\tb = k = 0; // dump bits\n\t\t\t\t\tmode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STORED:\n\t\t\t\t\tif (n === 0) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = that.write;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\tt = left;\n\t\t\t\t\tif (t > n)\n\t\t\t\t\t\tt = n;\n\t\t\t\t\tif (t > m)\n\t\t\t\t\t\tt = m;\n\t\t\t\t\tthat.window.set(z.read_buf(p, t), q);\n\t\t\t\t\tp += t;\n\t\t\t\t\tn -= t;\n\t\t\t\t\tq += t;\n\t\t\t\t\tm -= t;\n\t\t\t\t\tif ((left -= t) !== 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmode = last !== 0 ? DRY : TYPE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TABLE:\n\n\t\t\t\t\twhile (k < (14)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttable = t = (b & 0x3fff);\n\t\t\t\t\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"too many length or distance symbols\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\t\t\t\t\tif (!blens || blens.length < t) {\n\t\t\t\t\t\tblens = []; // new Array(t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < t; i++) {\n\t\t\t\t\t\t\tblens[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// {\n\t\t\t\t\tb >>>= (14);\n\t\t\t\t\tk -= (14);\n\t\t\t\t\t// }\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = BTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase BTREE:\n\t\t\t\t\twhile (index < 4 + (table >>> 10)) {\n\t\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tblens[border[index++]] = b & 7;\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (index < 19) {\n\t\t\t\t\t\tblens[border[index++]] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbb[0] = 7;\n\t\t\t\t\tt = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tr = t;\n\t\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = DTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DTREE:\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tt = table;\n\t\t\t\t\t\tif (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar j, c;\n\n\t\t\t\t\t\tt = bb[0];\n\n\t\t\t\t\t\twhile (k < (t)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if (tb[0] == -1) {\n\t\t\t\t\t\t// System.err.println(\"null...\");\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tt = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\n\t\t\t\t\t\tc = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n\t\t\t\t\t\tif (c < 16) {\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t\tblens[index++] = c;\n\t\t\t\t\t\t} else { // c == 16..18\n\t\t\t\t\t\t\ti = c == 18 ? 7 : c - 14;\n\t\t\t\t\t\t\tj = c == 18 ? 11 : 3;\n\n\t\t\t\t\t\t\twhile (k < (t + i)) {\n\t\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\n\t\t\t\t\t\t\tj += (b & inflate_mask[i]);\n\n\t\t\t\t\t\t\tb >>>= (i);\n\t\t\t\t\t\t\tk -= (i);\n\n\t\t\t\t\t\t\ti = index;\n\t\t\t\t\t\t\tt = table;\n\t\t\t\t\t\t\tif (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\n\t\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t\t\tz.msg = \"invalid bit length repeat\";\n\t\t\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tc = c == 16 ? blens[i - 1] : 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tblens[i++] = c;\n\t\t\t\t\t\t\t} while (--j !== 0);\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttb[0] = -1;\n\t\t\t\t\t// {\n\t\t\t\t\tvar bl_ = []; // new Array(1);\n\t\t\t\t\tvar bd_ = []; // new Array(1);\n\t\t\t\t\tvar tl_ = []; // new Array(1);\n\t\t\t\t\tvar td_ = []; // new Array(1);\n\t\t\t\t\tbl_[0] = 9; // must be <= 9 for lookahead assumptions\n\t\t\t\t\tbd_[0] = 6; // must be <= 9 for lookahead assumptions\n\n\t\t\t\t\tt = table;\n\t\t\t\t\tt = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\n\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tif (t == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr = t;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tcodes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\n\t\t\t\t\t// }\n\t\t\t\t\tmode = CODES;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase CODES:\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\n\t\t\t\t\tif ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\t\t\t\t\tcodes.free(z);\n\n\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\tb = that.bitb;\n\t\t\t\t\tk = that.bitk;\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\n\t\t\t\t\tif (last === 0) {\n\t\t\t\t\t\tmode = TYPE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = DRY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DRY:\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\tif (that.read != that.write) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = DONELOCKS;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONELOCKS:\n\t\t\t\t\tr = Z_STREAM_END;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\tcase BADBLOCKS:\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function(z) {\n\t\t\tthat.reset(z, null);\n\t\t\tthat.window = null;\n\t\t\thufts = null;\n\t\t\t// ZFREE(z, s);\n\t\t};\n\n\t\tthat.set_dictionary = function(d, start, n) {\n\t\t\tthat.window.set(d.subarray(start, start + n), 0);\n\t\t\tthat.read = that.write = n;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n\t\tthat.sync_point = function() {\n\t\t\treturn mode == LENS ? 1 : 0;\n\t\t};\n\n\t}\n\n\t// Inflate\n\n\t// preset dictionary flag in zlib header\n\tvar PRESET_DICT = 0x20;\n\n\tvar Z_DEFLATED = 8;\n\n\tvar METHOD = 0; // waiting for method byte\n\tvar FLAG = 1; // waiting for flag byte\n\tvar DICT4 = 2; // four dictionary check bytes to go\n\tvar DICT3 = 3; // three dictionary check bytes to go\n\tvar DICT2 = 4; // two dictionary check bytes to go\n\tvar DICT1 = 5; // one dictionary check byte to go\n\tvar DICT0 = 6; // waiting for inflateSetDictionary\n\tvar BLOCKS = 7; // decompressing blocks\n\tvar DONE = 12; // finished check, done\n\tvar BAD = 13; // got an error--stay here\n\n\tvar mark = [ 0, 0, 0xff, 0xff ];\n\n\tfunction Inflate() {\n\t\tvar that = this;\n\n\t\tthat.mode = 0; // current inflate mode\n\n\t\t// mode dependent information\n\t\tthat.method = 0; // if FLAGS, method byte\n\n\t\t// if CHECK, check values to compare\n\t\tthat.was = [ 0 ]; // new Array(1); // computed check value\n\t\tthat.need = 0; // stream check value\n\n\t\t// if BAD, inflateSync's marker bytes count\n\t\tthat.marker = 0;\n\n\t\t// mode independent information\n\t\tthat.wbits = 0; // log2(window size) (8..15, defaults to 15)\n\n\t\t// this.blocks; // current inflate_blocks state\n\n\t\tfunction inflateReset(z) {\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tz.total_in = z.total_out = 0;\n\t\t\tz.msg = null;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\tz.istate.blocks.reset(z, null);\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.inflateEnd = function(z) {\n\t\t\tif (that.blocks)\n\t\t\t\tthat.blocks.free(z);\n\t\t\tthat.blocks = null;\n\t\t\t// ZFREE(z, z->state);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateInit = function(z, w) {\n\t\t\tz.msg = null;\n\t\t\tthat.blocks = null;\n\n\t\t\t// set window size\n\t\t\tif (w < 8 || w > 15) {\n\t\t\t\tthat.inflateEnd(z);\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\tthat.wbits = w;\n\n\t\t\tz.istate.blocks = new InfBlocks(z, 1 << w);\n\n\t\t\t// reset state\n\t\t\tinflateReset(z);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflate = function(z, f) {\n\t\t\tvar r;\n\t\t\tvar b;\n\n\t\t\tif (!z || !z.istate || !z.next_in)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tf = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n\t\t\tr = Z_BUF_ERROR;\n\t\t\twhile (true) {\n\t\t\t\t// System.out.println(\"mode: \"+z.istate.mode);\n\t\t\t\tswitch (z.istate.mode) {\n\t\t\t\tcase METHOD:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tif (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"unknown compression method\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"invalid window size\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = FLAG;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase FLAG:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tb = (z.read_byte(z.next_in_index++)) & 0xff;\n\n\t\t\t\t\tif ((((z.istate.method << 8) + b) % 31) !== 0) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"incorrect header check\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((b & PRESET_DICT) === 0) {\n\t\t\t\t\t\tz.istate.mode = BLOCKS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = DICT4;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT4:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\n\t\t\t\t\tz.istate.mode = DICT3;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT3:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\n\t\t\t\t\tz.istate.mode = DICT2;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT2:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\n\t\t\t\t\tz.istate.mode = DICT1;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT1:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\n\t\t\t\t\tz.istate.mode = DICT0;\n\t\t\t\t\treturn Z_NEED_DICT;\n\t\t\t\tcase DICT0:\n\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\tz.msg = \"need dictionary\";\n\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\tcase BLOCKS:\n\n\t\t\t\t\tr = z.istate.blocks.proc(z, r);\n\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r == Z_OK) {\n\t\t\t\t\t\tr = f;\n\t\t\t\t\t}\n\t\t\t\t\tif (r != Z_STREAM_END) {\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t\tr = f;\n\t\t\t\t\tz.istate.blocks.reset(z, z.istate.was);\n\t\t\t\t\tz.istate.mode = DONE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONE:\n\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\tcase BAD:\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.inflateSetDictionary = function(z, dictionary, dictLength) {\n\t\t\tvar index = 0;\n\t\t\tvar length = dictLength;\n\t\t\tif (!z || !z.istate || z.istate.mode != DICT0)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tif (length >= (1 << z.istate.wbits)) {\n\t\t\t\tlength = (1 << z.istate.wbits) - 1;\n\t\t\t\tindex = dictLength - length;\n\t\t\t}\n\t\t\tz.istate.blocks.set_dictionary(dictionary, index, length);\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateSync = function(z) {\n\t\t\tvar n; // number of bytes to look at\n\t\t\tvar p; // pointer to bytes\n\t\t\tvar m; // number of marker bytes found in a row\n\t\t\tvar r, w; // temporaries to save total_in and total_out\n\n\t\t\t// set up\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tif (z.istate.mode != BAD) {\n\t\t\t\tz.istate.mode = BAD;\n\t\t\t\tz.istate.marker = 0;\n\t\t\t}\n\t\t\tif ((n = z.avail_in) === 0)\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\tp = z.next_in_index;\n\t\t\tm = z.istate.marker;\n\n\t\t\t// search\n\t\t\twhile (n !== 0 && m < 4) {\n\t\t\t\tif (z.read_byte(p) == mark[m]) {\n\t\t\t\t\tm++;\n\t\t\t\t} else if (z.read_byte(p) !== 0) {\n\t\t\t\t\tm = 0;\n\t\t\t\t} else {\n\t\t\t\t\tm = 4 - m;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tn--;\n\t\t\t}\n\n\t\t\t// restore\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\tz.avail_in = n;\n\t\t\tz.istate.marker = m;\n\n\t\t\t// return no joy or set up to restart on a new block\n\t\t\tif (m != 4) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tr = z.total_in;\n\t\t\tw = z.total_out;\n\t\t\tinflateReset(z);\n\t\t\tz.total_in = r;\n\t\t\tz.total_out = w;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n\t\t// implementation to provide an additional safety check. PPP uses\n\t\t// Z_SYNC_FLUSH\n\t\t// but removes the length bytes of the resulting empty stored block. When\n\t\t// decompressing, PPP checks that at the end of input packet, inflate is\n\t\t// waiting for these length bytes.\n\t\tthat.inflateSyncPoint = function(z) {\n\t\t\tif (!z || !z.istate || !z.istate.blocks)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn z.istate.blocks.sync_point();\n\t\t};\n\t}\n\n\t// ZStream\n\n\tfunction ZStream() {\n\t}\n\n\tZStream.prototype = {\n\t\tinflateInit : function(bits) {\n\t\t\tvar that = this;\n\t\t\tthat.istate = new Inflate();\n\t\t\tif (!bits)\n\t\t\t\tbits = MAX_BITS;\n\t\t\treturn that.istate.inflateInit(that, bits);\n\t\t},\n\n\t\tinflate : function(f) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflate(that, f);\n\t\t},\n\n\t\tinflateEnd : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tvar ret = that.istate.inflateEnd(that);\n\t\t\tthat.istate = null;\n\t\t\treturn ret;\n\t\t},\n\n\t\tinflateSync : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSync(that);\n\t\t},\n\t\tinflateSetDictionary : function(dictionary, dictLength) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSetDictionary(that, dictionary, dictLength);\n\t\t},\n\t\tread_byte : function(start) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + 1)[0];\n\t\t},\n\t\tread_buf : function(start, size) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + size);\n\t\t}\n\t};\n\n\t// Inflater\n\n\tfunction Inflater() {\n\t\tvar that = this;\n\t\tvar z = new ZStream();\n\t\tvar bufsize = 512;\n\t\tvar flush = Z_NO_FLUSH;\n\t\tvar buf = new Uint8Array(bufsize);\n\t\tvar nomoreinput = false;\n\n\t\tz.inflateInit();\n\t\tz.next_out = buf;\n\n\t\tthat.append = function(data, onprogress) {\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\n\t\t\tif (data.length === 0)\n\t\t\t\treturn;\n\t\t\tz.next_in_index = 0;\n\t\t\tz.next_in = data;\n\t\t\tz.avail_in = data.length;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\tif ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\n\t\t\t\t\tz.next_in_index = 0;\n\t\t\t\t\tnomoreinput = true;\n\t\t\t\t}\n\t\t\t\terr = z.inflate(flush);\n\t\t\t\tif (nomoreinput && (err === Z_BUF_ERROR)) {\n\t\t\t\t\tif (z.avail_in !== 0)\n\t\t\t\t\t\tthrow new Error(\"inflating: bad input\");\n\t\t\t\t} else if (err !== Z_OK && err !== Z_STREAM_END)\n\t\t\t\t\tthrow new Error(\"inflating: \" + z.msg);\n\t\t\t\tif ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))\n\t\t\t\t\tthrow new Error(\"inflating: bad input\");\n\t\t\t\tif (z.next_out_index)\n\t\t\t\t\tif (z.next_out_index === bufsize)\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n\t\t\t\t\tonprogress(z.next_in_index);\n\t\t\t\t\tlastIndex = z.next_in_index;\n\t\t\t\t}\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t\tthat.flush = function() {\n\t\t\tz.inflateEnd();\n\t\t};\n\t}\n\n\t// 'zip' may not be defined in z-worker and some tests\n\tvar env = global.zip || global;\n\tenv.Inflater = env._jzlib_Inflater = Inflater;\n})(this);\n")]
};

module.exports = zip;


},{"zip":32}],32:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(obj) {
	"use strict";

	var ERR_BAD_FORMAT = "File format is not recognized.";
	var ERR_CRC = "CRC failed.";
	var ERR_ENCRYPTED = "File contains encrypted entry.";
	var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
	var ERR_READ = "Error while reading zip file.";
	var ERR_WRITE = "Error while writing zip file.";
	var ERR_WRITE_DATA = "Error while writing file data.";
	var ERR_READ_DATA = "Error while reading file data.";
	var ERR_DUPLICATED_NAME = "File already exists.";
	var CHUNK_SIZE = 512 * 1024;
	
	var TEXT_PLAIN = "text/plain";

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
	} catch (e) {
	}

	function Crc32() {
		this.crc = -1;
	}
	Crc32.prototype.append = function append(data) {
		var crc = this.crc | 0, table = this.table;
		for (var offset = 0, len = data.length | 0; offset < len; offset++)
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		this.crc = crc;
	};
	Crc32.prototype.get = function get() {
		return ~this.crc;
	};
	Crc32.prototype.table = (function() {
		var i, j, t, table = []; // Uint32Array is actually slower than []
		for (i = 0; i < 256; i++) {
			t = i;
			for (j = 0; j < 8; j++)
				if (t & 1)
					t = (t >>> 1) ^ 0xEDB88320;
				else
					t = t >>> 1;
			table[i] = t;
		}
		return table;
	})();
	
	// "no-op" codec
	function NOOP() {}
	NOOP.prototype.append = function append(bytes, onprogress) {
		return bytes;
	};
	NOOP.prototype.flush = function flush() {};

	function blobSlice(blob, index, length) {
		if (index < 0 || length < 0 || index + length > blob.size)
			throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
		if (blob.slice)
			return blob.slice(index, index + length);
		else if (blob.webkitSlice)
			return blob.webkitSlice(index, index + length);
		else if (blob.mozSlice)
			return blob.mozSlice(index, index + length);
		else if (blob.msSlice)
			return blob.msSlice(index, index + length);
	}

	function getDataHelper(byteLength, bytes) {
		var dataBuffer, dataArray;
		dataBuffer = new ArrayBuffer(byteLength);
		dataArray = new Uint8Array(dataBuffer);
		if (bytes)
			dataArray.set(bytes, 0);
		return {
			buffer : dataBuffer,
			array : dataArray,
			view : new DataView(dataBuffer)
		};
	}

	// Readers
	function Reader() {
	}

	function TextReader(text) {
		var that = this, blobReader;

		function init(callback, onerror) {
			var blob = new Blob([ text ], {
				type : TEXT_PLAIN
			});
			blobReader = new BlobReader(blob);
			blobReader.init(function() {
				that.size = blobReader.size;
				callback();
			}, onerror);
		}

		function readUint8Array(index, length, callback, onerror) {
			blobReader.readUint8Array(index, length, callback, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	TextReader.prototype = new Reader();
	TextReader.prototype.constructor = TextReader;

	function Data64URIReader(dataURI) {
		var that = this, dataStart;

		function init(callback) {
			var dataEnd = dataURI.length;
			while (dataURI.charAt(dataEnd - 1) == "=")
				dataEnd--;
			dataStart = dataURI.indexOf(",") + 1;
			that.size = Math.floor((dataEnd - dataStart) * 0.75);
			callback();
		}

		function readUint8Array(index, length, callback) {
			var i, data = getDataHelper(length);
			var start = Math.floor(index / 3) * 4;
			var end = Math.ceil((index + length) / 3) * 4;
			var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
			var delta = index - Math.floor(start / 4) * 3;
			for (i = delta; i < delta + length; i++)
				data.array[i - delta] = bytes.charCodeAt(i);
			callback(data.array);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	Data64URIReader.prototype = new Reader();
	Data64URIReader.prototype.constructor = Data64URIReader;

	function BlobReader(blob) {
		var that = this;

		function init(callback) {
			that.size = blob.size;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(new Uint8Array(e.target.result));
			};
			reader.onerror = onerror;
			try {
				reader.readAsArrayBuffer(blobSlice(blob, index, length));
			} catch (e) {
				onerror(e);
			}
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	BlobReader.prototype = new Reader();
	BlobReader.prototype.constructor = BlobReader;

	// Writers

	function Writer() {
	}
	Writer.prototype.getData = function(callback) {
		callback(this.data);
	};

	function TextWriter(encoding) {
		var that = this, blob;

		function init(callback) {
			blob = new Blob([], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function getData(callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(e.target.result);
			};
			reader.onerror = onerror;
			reader.readAsText(blob, encoding);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	TextWriter.prototype = new Writer();
	TextWriter.prototype.constructor = TextWriter;

	function Data64URIWriter(contentType) {
		var that = this, data = "", pending = "";

		function init(callback) {
			data += "data:" + (contentType || "") + ";base64,";
			callback();
		}

		function writeUint8Array(array, callback) {
			var i, delta = pending.length, dataString = pending;
			pending = "";
			for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
				dataString += String.fromCharCode(array[i]);
			for (; i < array.length; i++)
				pending += String.fromCharCode(array[i]);
			if (dataString.length > 2)
				data += obj.btoa(dataString);
			else
				pending = dataString;
			callback();
		}

		function getData(callback) {
			callback(data + obj.btoa(pending));
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	Data64URIWriter.prototype = new Writer();
	Data64URIWriter.prototype.constructor = Data64URIWriter;

	function BlobWriter(contentType) {
		var blob, that = this;

		function init(callback) {
			blob = new Blob([], {
				type : contentType
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : contentType
			});
			callback();
		}

		function getData(callback) {
			callback(blob);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	BlobWriter.prototype = new Writer();
	BlobWriter.prototype.constructor = BlobWriter;

	/** 
	 * inflate/deflate core functions
	 * @param worker {Worker} web worker for the task.
	 * @param initialMessage {Object} initial message to be sent to the worker. should contain
	 *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
	 *   This function may add more properties before sending.
	 */
	function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;

		function onflush() {
			worker.removeEventListener('message', onmessage, false);
			onend(outputSize, crc);
		}

		function onmessage(event) {
			var message = event.data, data = message.data, err = message.error;
			if (err) {
				err.toString = function () { return 'Error: ' + this.message; };
				onreaderror(err);
				return;
			}
			if (message.sn !== sn)
				return;
			if (typeof message.codecTime === 'number')
				worker.codecTime += message.codecTime; // should be before onflush()
			if (typeof message.crcTime === 'number')
				worker.crcTime += message.crcTime;

			switch (message.type) {
				case 'append':
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							step();
						}, onwriteerror);
					} else
						step();
					break;
				case 'flush':
					crc = message.crc;
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							onflush();
						}, onwriteerror);
					} else
						onflush();
					break;
				case 'progress':
					if (onprogress)
						onprogress(index + message.loaded, size);
					break;
				case 'importScripts': //no need to handle here
				case 'newTask':
				case 'echo':
					break;
				default:
					console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
			}
		}

		function step() {
			index = chunkIndex * CHUNK_SIZE;
			// use `<=` instead of `<`, because `size` may be 0.
			if (index <= size) {
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					if (onprogress)
						onprogress(index, size);
					var msg = index === 0 ? initialMessage : {sn : sn};
					msg.type = 'append';
					msg.data = array;
					
					// posting a message with transferables will fail on IE10
					try {
						worker.postMessage(msg, [array.buffer]);
					} catch(ex) {
						worker.postMessage(msg); // retry without transferables
					}
					chunkIndex++;
				}, onreaderror);
			} else {
				worker.postMessage({
					sn: sn,
					type: 'flush'
				});
			}
		}

		outputSize = 0;
		worker.addEventListener('message', onmessage, false);
		step();
	}

	function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize = 0,
			crcInput = crcType === 'input',
			crcOutput = crcType === 'output',
			crc = new Crc32();
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			if (index < size)
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
					var outputData;
					try {
						outputData = process.append(inputData, function(loaded) {
							if (onprogress)
								onprogress(index + loaded, size);
						});
					} catch (e) {
						onreaderror(e);
						return;
					}
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							chunkIndex++;
							setTimeout(step, 1);
						}, onwriteerror);
						if (crcOutput)
							crc.append(outputData);
					} else {
						chunkIndex++;
						setTimeout(step, 1);
					}
					if (crcInput)
						crc.append(inputData);
					if (onprogress)
						onprogress(index, size);
				}, onreaderror);
			else {
				try {
					outputData = process.flush();
				} catch (e) {
					onreaderror(e);
					return;
				}
				if (outputData) {
					if (crcOutput)
						crc.append(outputData);
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onend(outputSize, crc.get());
					}, onwriteerror);
				} else
					onend(outputSize, crc.get());
			}
		}

		step();
	}

	function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = computeCrc32 ? 'output' : 'none';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				codecClass: 'Inflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				options: {level: level},
				codecClass: 'Deflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers && computeCrc32) {
			var initialMessage = {
				sn: sn,
				codecClass: 'NOOP',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	// ZipReader

	function decodeASCII(str) {
		var i, out = "", charCode, extendedASCII = [ '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
				'\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
				'\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
				'\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
				'\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
				'\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
				'\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
				'\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
				'\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' ' ];
		for (i = 0; i < str.length; i++) {
			charCode = str.charCodeAt(i) & 0xFF;
			if (charCode > 127)
				out += extendedASCII[charCode - 128];
			else
				out += String.fromCharCode(charCode);
		}
		return out;
	}

	function decodeUTF8(string) {
		return decodeURIComponent(escape(string));
	}

	function getString(bytes) {
		var i, str = "";
		for (i = 0; i < bytes.length; i++)
			str += String.fromCharCode(bytes[i]);
		return str;
	}

	function getDate(timeRaw) {
		var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
		try {
			return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
					(time & 0x001F) * 2, 0);
		} catch (e) {
		}
	}

	function readCommonHeader(entry, data, index, centralDirectory, onerror) {
		entry.version = data.view.getUint16(index, true);
		entry.bitFlag = data.view.getUint16(index + 2, true);
		entry.compressionMethod = data.view.getUint16(index + 4, true);
		entry.lastModDateRaw = data.view.getUint32(index + 6, true);
		entry.lastModDate = getDate(entry.lastModDateRaw);
		if ((entry.bitFlag & 0x01) === 0x01) {
			onerror(ERR_ENCRYPTED);
			return;
		}
		if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
			entry.crc32 = data.view.getUint32(index + 10, true);
			entry.compressedSize = data.view.getUint32(index + 14, true);
			entry.uncompressedSize = data.view.getUint32(index + 18, true);
		}
		if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
			onerror(ERR_ZIP64);
			return;
		}
		entry.filenameLength = data.view.getUint16(index + 22, true);
		entry.extraFieldLength = data.view.getUint16(index + 24, true);
	}

	function createZipReader(reader, callback, onerror) {
		var inflateSN = 0;

		function Entry() {
		}

		Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
			var that = this;

			function testCrc32(crc32) {
				var dataCrc32 = getDataHelper(4);
				dataCrc32.view.setUint32(0, crc32);
				return that.crc32 == dataCrc32.view.getUint32(0);
			}

			function getWriterData(uncompressedSize, crc32) {
				if (checkCrc32 && !testCrc32(crc32))
					onerror(ERR_CRC);
				else
					writer.getData(function(data) {
						onend(data);
					});
			}

			function onreaderror(err) {
				onerror(err || ERR_READ_DATA);
			}

			function onwriteerror(err) {
				onerror(err || ERR_WRITE_DATA);
			}

			reader.readUint8Array(that.offset, 30, function(bytes) {
				var data = getDataHelper(bytes.length, bytes), dataOffset;
				if (data.view.getUint32(0) != 0x504b0304) {
					onerror(ERR_BAD_FORMAT);
					return;
				}
				readCommonHeader(that, data, 4, false, onerror);
				dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
				writer.init(function() {
					if (that.compressionMethod === 0)
						copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					else
						inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
				}, onwriteerror);
			}, onreaderror);
		};

		function seekEOCDR(eocdrCallback) {
			// "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
			// Zip file comment is the last part of EOCDR and has max length of 64KB,
			// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
			var EOCDR_MIN = 22;
			if (reader.size < EOCDR_MIN) {
				onerror(ERR_BAD_FORMAT);
				return;
			}
			var ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

			// In most cases, the EOCDR is EOCDR_MIN bytes long
			doSeek(EOCDR_MIN, function() {
				// If not found, try within EOCDR_MAX bytes
				doSeek(Math.min(EOCDR_MAX, reader.size), function() {
					onerror(ERR_BAD_FORMAT);
				});
			});

			// seek last length bytes of file for EOCDR
			function doSeek(length, eocdrNotFoundCallback) {
				reader.readUint8Array(reader.size - length, length, function(bytes) {
					for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
						if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
							eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
							return;
						}
					}
					eocdrNotFoundCallback();
				}, function() {
					onerror(ERR_READ);
				});
			}
		}

		var zipReader = {
			getEntries : function(callback) {
				var worker = this._worker;
				// look for End of central directory record
				seekEOCDR(function(dataView) {
					var datalength, fileslength;
					datalength = dataView.getUint32(16, true);
					fileslength = dataView.getUint16(8, true);
					if (datalength < 0 || datalength >= reader.size) {
						onerror(ERR_BAD_FORMAT);
						return;
					}
					reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
						var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
						for (i = 0; i < fileslength; i++) {
							entry = new Entry();
							entry._worker = worker;
							if (data.view.getUint32(index) != 0x504b0102) {
								onerror(ERR_BAD_FORMAT);
								return;
							}
							readCommonHeader(entry, data, index + 6, true, onerror);
							entry.commentLength = data.view.getUint16(index + 32, true);
							entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
							entry.offset = data.view.getUint32(index + 42, true);
							filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
							entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
							if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
								entry.directory = true;
							comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
									+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));
							entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
							entries.push(entry);
							index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
						}
						callback(entries);
					}, function() {
						onerror(ERR_READ);
					});
				});
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}
				if (callback)
					callback();
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipReader);
		else {
			createWorker('inflater',
				function(worker) {
					zipReader._worker = worker;
					callback(zipReader);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	// ZipWriter

	function encodeUTF8(string) {
		return unescape(encodeURIComponent(string));
	}

	function getBytes(str) {
		var i, array = [];
		for (i = 0; i < str.length; i++)
			array.push(str.charCodeAt(i));
		return array;
	}

	function createZipWriter(writer, callback, onerror, dontDeflate) {
		var files = {}, filenames = [], datalength = 0;
		var deflateSN = 0;

		function onwriteerror(err) {
			onerror(err || ERR_WRITE);
		}

		function onreaderror(err) {
			onerror(err || ERR_READ_DATA);
		}

		var zipWriter = {
			add : function(name, reader, onend, onprogress, options) {
				var header, filename, date;
				var worker = this._worker;

				function writeHeader(callback) {
					var data;
					date = options.lastModDate || new Date();
					header = getDataHelper(26);
					files[name] = {
						headerArray : header.array,
						directory : options.directory,
						filename : filename,
						offset : datalength,
						comment : getBytes(encodeUTF8(options.comment || ""))
					};
					header.view.setUint32(0, 0x14000808);
					if (options.version)
						header.view.setUint8(0, options.version);
					if (!dontDeflate && options.level !== 0 && !options.directory)
						header.view.setUint16(4, 0x0800);
					header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
					header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
					header.view.setUint16(22, filename.length, true);
					data = getDataHelper(30 + filename.length);
					data.view.setUint32(0, 0x504b0304);
					data.array.set(header.array, 4);
					data.array.set(filename, 30);
					datalength += data.array.length;
					writer.writeUint8Array(data.array, callback, onwriteerror);
				}

				function writeFooter(compressedLength, crc32) {
					var footer = getDataHelper(16);
					datalength += compressedLength || 0;
					footer.view.setUint32(0, 0x504b0708);
					if (typeof crc32 != "undefined") {
						header.view.setUint32(10, crc32, true);
						footer.view.setUint32(4, crc32, true);
					}
					if (reader) {
						footer.view.setUint32(8, compressedLength, true);
						header.view.setUint32(14, compressedLength, true);
						footer.view.setUint32(12, reader.size, true);
						header.view.setUint32(18, reader.size, true);
					}
					writer.writeUint8Array(footer.array, function() {
						datalength += 16;
						onend();
					}, onwriteerror);
				}

				function writeFile() {
					options = options || {};
					name = name.trim();
					if (options.directory && name.charAt(name.length - 1) != "/")
						name += "/";
					if (files.hasOwnProperty(name)) {
						onerror(ERR_DUPLICATED_NAME);
						return;
					}
					filename = getBytes(encodeUTF8(name));
					filenames.push(name);
					writeHeader(function() {
						if (reader)
							if (dontDeflate || options.level === 0)
								copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
							else
								deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
						else
							writeFooter();
					}, onwriteerror);
				}

				if (reader)
					reader.init(writeFile, onreaderror);
				else
					writeFile();
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}

				var data, length = 0, index = 0, indexFilename, file;
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					length += 46 + file.filename.length + file.comment.length;
				}
				data = getDataHelper(length + 22);
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					data.view.setUint32(index, 0x504b0102);
					data.view.setUint16(index + 4, 0x1400);
					data.array.set(file.headerArray, index + 6);
					data.view.setUint16(index + 32, file.comment.length, true);
					if (file.directory)
						data.view.setUint8(index + 38, 0x10);
					data.view.setUint32(index + 42, file.offset, true);
					data.array.set(file.filename, index + 46);
					data.array.set(file.comment, index + 46 + file.filename.length);
					index += 46 + file.filename.length + file.comment.length;
				}
				data.view.setUint32(index, 0x504b0506);
				data.view.setUint16(index + 8, filenames.length, true);
				data.view.setUint16(index + 10, filenames.length, true);
				data.view.setUint32(index + 12, length, true);
				data.view.setUint32(index + 16, datalength, true);
				writer.writeUint8Array(data.array, function() {
					writer.getData(callback);
				}, onwriteerror);
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipWriter);
		else {
			createWorker('deflater',
				function(worker) {
					zipWriter._worker = worker;
					callback(zipWriter);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	function resolveURLs(urls) {
		var a = document.createElement('a');
		return urls.map(function(url) {
			a.href = url;
			return a.href;
		});
	}

	var DEFAULT_WORKER_SCRIPTS = {
		deflater: ['z-worker.js', 'deflate.js'],
		inflater: ['z-worker.js', 'inflate.js']
	};
	function createWorker(type, callback, onerror) {
		if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
			onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
			return;
		}
		var scripts;
		if (obj.zip.workerScripts) {
			scripts = obj.zip.workerScripts[type];
			if (!Array.isArray(scripts)) {
				onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
				return;
			}
			scripts = resolveURLs(scripts);
		} else {
			scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
			scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
		}
		var worker = new Worker(scripts[0]);
		// record total consumed time by inflater/deflater/crc32 in this worker
		worker.codecTime = worker.crcTime = 0;
		worker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });
		worker.addEventListener('message', onmessage);
		function onmessage(ev) {
			var msg = ev.data;
			if (msg.error) {
				worker.terminate(); // should before onerror(), because onerror() may throw.
				onerror(msg.error);
				return;
			}
			if (msg.type === 'importScripts') {
				worker.removeEventListener('message', onmessage);
				worker.removeEventListener('error', errorHandler);
				callback(worker);
			}
		}
		// catch entry script loading error and other unhandled errors
		worker.addEventListener('error', errorHandler);
		function errorHandler(err) {
			worker.terminate();
			onerror(err);
		}
	}

	function onerror_default(error) {
		console.error(error);
	}
	obj.zip = {
		Reader : Reader,
		Writer : Writer,
		BlobReader : BlobReader,
		Data64URIReader : Data64URIReader,
		TextReader : TextReader,
		BlobWriter : BlobWriter,
		Data64URIWriter : Data64URIWriter,
		TextWriter : TextWriter,
		createReader : function(reader, callback, onerror) {
			onerror = onerror || onerror_default;

			reader.init(function() {
				createZipReader(reader, callback, onerror);
			}, onerror);
		},
		createWriter : function(writer, callback, onerror, dontDeflate) {
			onerror = onerror || onerror_default;
			dontDeflate = !!dontDeflate;

			writer.init(function() {
				createZipWriter(writer, callback, onerror, dontDeflate);
			}, onerror);
		},
		useWebWorkers : true,
		/**
		 * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
		 * E.g.: zip.workerScripts = './';
		 */
		workerScriptsPath : null,
		/**
		 * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
		 * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
		 * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
		 * All urls are relative to current base url.
		 * E.g.:
		 * zip.workerScripts = {
		 *   deflater: ['z-worker.js', 'deflate.js'],
		 *   inflater: ['z-worker.js', 'inflate.js']
		 * };
		 */
		workerScripts : null,
	};

})(this);

; browserify_shim__define__module__export__(typeof zip != "undefined" ? zip : window.zip);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvc2NyaXB0cy9hcHAuanMiLCJhcHAvc2NyaXB0cy9pbWFnZWxpYi9hbmFseXNpcy5qcyIsImFwcC9zY3JpcHRzL2ltYWdlbGliL2RyYXdpbmcuanMiLCJhcHAvc2NyaXB0cy9pbWFnZWxpYi9lZmZlY3RzLmpzIiwiYXBwL3NjcmlwdHMvaW1hZ2VsaWIvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9wYWdlcy9hY3Rpb25iYXJpY29ucy5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL2FwcHNob3J0Y3V0aWNvbnMuanMiLCJhcHAvc2NyaXB0cy9wYWdlcy9iYXNlZ2VuZXJhdG9yLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvZ2VuZXJpY2ljb25zLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9wYWdlcy9sYXVuY2hlcmljb25zLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvbmluZXBhdGNoL25pbmVwYXRjaGVzLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvbmluZXBhdGNoL25pbmVwYXRjaGxvYWRlci5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL25pbmVwYXRjaC9uaW5lcGF0Y2hwcmV2aWV3LmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvbmluZXBhdGNoL25pbmVwYXRjaHN0YWdlLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvbmluZXBhdGNoL25pbmVwYXRjaHRyaW1taW5nLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvbmluZXBhdGNoL3N1bW1lci5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL25vdGlmaWNhdGlvbmljb25zLmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL2ZpZWxkcy5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9mb3Jtcy5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9oYXNoLmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL2ltYWdlZmllbGQtY2xpcGFydC5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9pbWFnZWZpZWxkLmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL3V0aWwuanMiLCJhcHAvc2NyaXB0cy9zdHVkaW8vemlwLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Rpbnljb2xvcjIvdGlueWNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL3dlYmZvbnRsb2FkZXIvd2ViZm9udGxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy96aXBqcy1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ppcGpzLWJyb3dzZXJpZnkvdmVuZG9yL3ppcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDZ0JBOztBQUNBOztBQUNBOztBQUVBLE9BQU8sS0FBUCxnQixDQXBCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZ0JBOzswRkFoQkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQk8sSUFBTSw4QkFBVyxFQUFqQjs7QUFFUCxTQUFTLG1CQUFUOztBQTJCQSxTQUFTLGlCQUFULEdBQTZCLEdBQTdCOztBQUVBLFNBQVMsV0FBVCxHQUF1QixVQUFTLEdBQVQsRUFBYyxJQUFkLEVBQW9CLFFBQXBCLEVBQThCO0FBQ25ELE1BQUksQ0FBQyxJQUFJLE1BQVQsRUFBaUI7QUFDZjtBQUNBLFFBQUksTUFBTSxHQUFWO0FBQ0EsVUFBTSxpQkFBUSxPQUFSLENBQWdCLElBQWhCLENBQU47QUFDQSxxQkFBUSxJQUFSLENBQWEsR0FBYixFQUFrQixHQUFsQixFQUF1QixJQUF2QjtBQUNEOztBQUVELE1BQUksUUFBUSxDQUFaO0FBQ0EsTUFBSSxLQUFLLENBQUwsR0FBUyxTQUFTLGlCQUFsQixJQUF1QyxLQUFLLENBQUwsR0FBUyxTQUFTLGlCQUE3RCxFQUFnRjtBQUM5RSxZQUFTLEtBQUssQ0FBTCxHQUFTLFNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7cGFnZXN9IGZyb20gJy4vcGFnZXMnO1xuaW1wb3J0IHtzdHVkaW99IGZyb20gJy4vc3R1ZGlvJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4vaW1hZ2VsaWInO1xuXG53aW5kb3cucGFnZXMgPSBwYWdlcztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0RyYXdpbmd9IGZyb20gJy4vZHJhd2luZyc7XG5cbmV4cG9ydCBjb25zdCBBbmFseXNpcyA9IHt9O1xuXG5BbmFseXNpcy5UUklNX1JFQ1RfV09SS0VSX0pTID0gYFxuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBsID0gZXZlbnQuZGF0YS5zaXplLncsIHQgPSBldmVudC5kYXRhLnNpemUuaCwgciA9IDAsIGIgPSAwO1xuXG4gICAgICB2YXIgYWxwaGE7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGV2ZW50LmRhdGEuc2l6ZS5oOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBldmVudC5kYXRhLnNpemUudzsgeCsrKSB7XG4gICAgICAgICAgYWxwaGEgPSBldmVudC5kYXRhLmltYWdlRGF0YS5kYXRhW1xuICAgICAgICAgICAgICAoKHkgKiBldmVudC5kYXRhLnNpemUudyArIHgpIDw8IDIpICsgM107XG4gICAgICAgICAgaWYgKGFscGhhID49IGV2ZW50LmRhdGEubWluQWxwaGEpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbih4LCBsKTtcbiAgICAgICAgICAgIHQgPSBNYXRoLm1pbih5LCB0KTtcbiAgICAgICAgICAgIHIgPSBNYXRoLm1heCh4LCByKTtcbiAgICAgICAgICAgIGIgPSBNYXRoLm1heCh5LCBiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGwgPiByKSB7XG4gICAgICAgIC8vIG5vIHBpeGVscywgY291bGRuJ3QgdHJpbVxuICAgICAgICBwb3N0TWVzc2FnZSh7IHg6IDAsIHk6IDAsIHc6IGV2ZW50LmRhdGEuc2l6ZS53LCBoOiBldmVudC5kYXRhLnNpemUuaCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwb3N0TWVzc2FnZSh7IHg6IGwsIHk6IHQsIHc6IHIgLSBsICsgMSwgaDogYiAtIHQgKyAxIH0pO1xuICAgIH07YFxuXG5BbmFseXNpcy5NQVhfVFJJTV9TUkNfU0laRSA9IDUwMDtcblxuQW5hbHlzaXMuZ2V0VHJpbVJlY3QgPSBmdW5jdGlvbihjdHgsIHNpemUsIG1pbkFscGhhKSB7XG4gIGlmICghY3R4LmNhbnZhcykge1xuICAgIC8vIExpa2VseSBhbiBpbWFnZVxuICAgIGxldCBzcmMgPSBjdHg7XG4gICAgY3R4ID0gRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgIERyYXdpbmcuY29weShjdHgsIHNyYywgc2l6ZSk7XG4gIH1cblxuICBsZXQgc2NhbGUgPSAxO1xuICBpZiAoc2l6ZS53ID4gQW5hbHlzaXMuTUFYX1RSSU1fU1JDX1NJWkUgfHwgc2l6ZS5oID4gQW5hbHlzaXMuTUFYX1RSSU1fU1JDX1NJWkUpIHtcbiAgICBzY2FsZSA9IChzaXplLncgPiBBbmFseXNpcy5NQVhfVFJJTV9TUkNfU0laRSlcbiAgICAgICAgPyBBbmFseXNpcy5NQVhfVFJJTV9TUkNfU0laRSAvIHNpemUud1xuICAgICAgICA6IEFuYWx5c2lzLk1BWF9UUklNX1NSQ19TSVpFIC8gc2l6ZS5oO1xuICAgIGxldCBzY2FsZWRTaXplID0geyB3OiBzaXplLncgKiBzY2FsZSwgaDogc2l6ZS5oICogc2NhbGUgfTtcbiAgICBsZXQgdG1wQ3R4ID0gRHJhd2luZy5jb250ZXh0KHNjYWxlZFNpemUpO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcywgMCwgMCwgc2l6ZS53LCBzaXplLmgsIDAsIDAsIHNjYWxlZFNpemUudywgc2NhbGVkU2l6ZS5oKTtcbiAgICBjdHggPSB0bXBDdHg7XG4gICAgc2l6ZSA9IHNjYWxlZFNpemU7XG4gIH1cblxuICBsZXQgd29ya2VyO1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAobWluQWxwaGEgPT0gMCkge1xuICAgICAgcmVzb2x2ZSh7IHg6IDAsIHk6IDAsIHc6IHNpemUudywgaDogc2l6ZS5oIH0pO1xuICAgIH1cblxuICAgIG1pbkFscGhhID0gbWluQWxwaGEgfHwgMTtcblxuICAgIHdvcmtlciA9IHJ1bldvcmtlckpzXyhcbiAgICAgICAgQW5hbHlzaXMuVFJJTV9SRUNUX1dPUktFUl9KUyxcbiAgICAgICAge1xuICAgICAgICAgIGltYWdlRGF0YTogY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLncsIHNpemUuaCksXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBtaW5BbHBoYVxuICAgICAgICB9LFxuICAgICAgICByZXN1bHRpbmdSZWN0ID0+IHtcbiAgICAgICAgICByZXN1bHRpbmdSZWN0LnggLz0gc2NhbGU7XG4gICAgICAgICAgcmVzdWx0aW5nUmVjdC55IC89IHNjYWxlO1xuICAgICAgICAgIHJlc3VsdGluZ1JlY3QudyAvPSBzY2FsZTtcbiAgICAgICAgICByZXN1bHRpbmdSZWN0LmggLz0gc2NhbGU7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHRpbmdSZWN0KVxuICAgICAgICAgIHdvcmtlciA9IG51bGw7XG4gICAgICAgIH0pO1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ3dvcmtlcicsIHtcbiAgICBnZXQ6ICgpID0+IHdvcmtlclxuICB9KTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkFuYWx5c2lzLmdldENlbnRlck9mTWFzcyA9IGZ1bmN0aW9uKGN0eCwgc2l6ZSwgbWluQWxwaGEpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoIWN0eC5jYW52YXMpIHtcbiAgICAgIC8vIExpa2VseSBhbiBpbWFnZVxuICAgICAgdmFyIHNyYyA9IGN0eDtcbiAgICAgIGN0eCA9IERyYXdpbmcuY29udGV4dChzaXplKTtcbiAgICAgIERyYXdpbmcuY29weShjdHgsIHNyYywgc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKG1pbkFscGhhID09IDApIHtcbiAgICAgIHJlc29sdmUoeyB4OiBzaXplLncgLyAyLCB5OiBzaXplLmggLyAyIH0pO1xuICAgIH1cblxuICAgIG1pbkFscGhhID0gbWluQWxwaGEgfHwgMTtcblxuICAgIHZhciBsID0gc2l6ZS53LCB0ID0gc2l6ZS5oLCByID0gMCwgYiA9IDA7XG4gICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuXG4gICAgdmFyIHN1bVggPSAwO1xuICAgIHZhciBzdW1ZID0gMDtcbiAgICB2YXIgbiA9IDA7IC8vIG51bWJlciBvZiBwaXhlbHMgPiBtaW5BbHBoYVxuICAgIHZhciBhbHBoYTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNpemUuaDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHNpemUudzsgeCsrKSB7XG4gICAgICAgIGFscGhhID0gaW1hZ2VEYXRhLmRhdGFbKCh5ICogc2l6ZS53ICsgeCkgPDwgMikgKyAzXTtcbiAgICAgICAgaWYgKGFscGhhID49IG1pbkFscGhhKSB7XG4gICAgICAgICAgc3VtWCArPSB4O1xuICAgICAgICAgIHN1bVkgKz0geTtcbiAgICAgICAgICArK247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobiA8PSAwKSB7XG4gICAgICAvLyBubyBwaXhlbHMgPiBtaW5BbHBoYSwganVzdCB1c2UgY2VudGVyXG4gICAgICByZXNvbHZlKHsgeDogc2l6ZS53IC8gMiwgaDogc2l6ZS5oIC8gMiB9KTtcbiAgICB9XG5cbiAgICByZXNvbHZlKHsgeDogTWF0aC5yb3VuZChzdW1YIC8gbiksIHk6IE1hdGgucm91bmQoc3VtWSAvIG4pIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIGZvciBydW5uaW5nIGlubGluZSBXZWIgV29ya2VycywgaWYgdGhlIGJyb3dzZXIgY2FuIHN1cHBvcnRcbiAqIHRoZW0uIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpbmxpbmUgV2ViIFdvcmtlcnMsIHJ1biB0aGUgc2NyaXB0XG4gKiBvbiB0aGUgbWFpbiB0aHJlYWQsIHdpdGggdGhpcyBmdW5jdGlvbiBib2R5J3Mgc2NvcGUsIHVzaW5nIGV2YWwuIEJyb3dzZXJzXG4gKiBtdXN0IHByb3ZpZGUgQmxvYkJ1aWxkZXIsIFVSTC5jcmVhdGVPYmplY3RVUkwsIGFuZCBXb3JrZXIgc3VwcG9ydCB0byB1c2VcbiAqIGlubGluZSBXZWIgV29ya2Vycy4gTW9zdCBmZWF0dXJlcyBzdWNoIGFzIGltcG9ydFNjcmlwdHMoKSBhcmUgbm90XG4gKiBjdXJyZW50bHkgc3VwcG9ydGVkLCBzbyB0aGlzIG9ubHkgd29ya3MgZm9yIGJhc2ljIHdvcmtlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30ganMgVGhlIGlubGluZSBXZWIgV29ya2VyIEphdmFzY3JpcHQgY29kZSB0byBydW4uIFRoaXMgY29kZVxuICogICAgIG11c3QgdXNlICdzZWxmJyBhbmQgbm90ICd0aGlzJyBhcyB0aGUgZ2xvYmFsIGNvbnRleHQgdmFyaWFibGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIG9iamVjdCB0byBwYXNzIHRvIHRoZSB3b3JrZXIuXG4gKiAgICAgRXF1aXZhbGVudCB0byBjYWxsaW5nIFdvcmtlci5wb3N0TWVzc2FnZShwYXJhbXMpO1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHJ1biB3aGVuIHRoZSB3b3JrZXIgY2FsbHNcbiAqICAgICBwb3N0TWVzc2FnZS4gRXF1aXZhbGVudCB0byBhZGRpbmcgYSAnbWVzc2FnZScgZXZlbnQgbGlzdGVuZXIgb24gYVxuICogICAgIFdvcmtlciBvYmplY3QgYW5kIHJ1bm5pbmcgY2FsbGJhY2soZXZlbnQuZGF0YSk7XG4gKi9cbmZ1bmN0aW9uIHJ1bldvcmtlckpzXyhqcywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkw7XG4gIHZhciBXb3JrZXIgPSB3aW5kb3cuV29ya2VyO1xuXG4gIGlmIChVUkwgJiYgV29ya2VyICYmIGhhc0Jsb2JDb25zdHJ1Y3Rvcl8oKSkge1xuICAgIC8vIFRoZSBCbG9iIGNvbnN0cnVjdG9yLCBXb3JrZXIsIGFuZCB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCBhcmUgYWxsIGF2YWlsYWJsZSxcbiAgICAvLyBzbyB3ZSBjYW4gdXNlIGlubGluZSB3b3JrZXJzLlxuICAgIHZhciBiYiA9IG5ldyBCbG9iKFtqc10sIHt0eXBlOid0ZXh0L2phdmFzY3JpcHQnfSk7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChiYikpO1xuICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQuZGF0YSk7XG4gICAgfTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UocGFyYW1zKTtcbiAgICByZXR1cm4gd29ya2VyO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY2FuJ3QgdXNlIGlubGluZSB3b3JrZXJzLCBzbyBydW4gdGhlIHdvcmtlciBKUyBvbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9fRFVNTVlfT0JKRUNUX18gPSB7fTtcbiAgICAgIC8vIFByb3h5IHRvIFdvcmtlci5vbm1lc3NhZ2VcbiAgICAgIHZhciBwb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIC8vIEJpbmQgdGhlIHdvcmtlciB0byB0aGlzIGR1bW15IG9iamVjdC4gVGhlIHdvcmtlciB3aWxsIHJ1blxuICAgICAgLy8gaW4gdGhpcyBzY29wZS5cbiAgICAgIGV2YWwoJ3ZhciBzZWxmPV9fRFVNTVlfT0JKRUNUX187XFxuJyArIGpzKTtcbiAgICAgIC8vIFByb3h5IHRvIFdvcmtlci5wb3N0TWVzc2FnZVxuICAgICAgX19EVU1NWV9PQkpFQ1RfXy5vbm1lc3NhZ2Uoe1xuICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgIH0pO1xuICAgIH0pKCk7XG5cbiAgICAvLyBSZXR1cm4gYSBkdW1teSBXb3JrZXIuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oKXt9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpbGRhcy1sb3JtZWF1L3ppcC5qcy9pc3N1ZXMvMTcjaXNzdWVjb21tZW50LTg1MTMyNThcbi8vIHRoYW5rcyBFcmljIVxuZnVuY3Rpb24gaGFzQmxvYkNvbnN0cnVjdG9yXygpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFuZXcgQmxvYigpO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2RlZmF1bHQgYXMgdGlueWNvbG9yfSBmcm9tICd0aW55Y29sb3IyJztcblxuaW1wb3J0IHtFZmZlY3RzfSBmcm9tICcuL2VmZmVjdHMnO1xuXG5leHBvcnQgY29uc3QgRHJhd2luZyA9IHt9O1xuXG5EcmF3aW5nLmNvbnRleHQgPSBmdW5jdGlvbihzaXplKSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gc2l6ZS53O1xuICBjYW52YXMuaGVpZ2h0ID0gc2l6ZS5oO1xuICBjYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2ltYWdlLXJlbmRlcmluZycsICdvcHRpbWl6ZVF1YWxpdHknLCBudWxsKTtcbiAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xufTtcblxuRHJhd2luZy5jb3B5ID0gZnVuY3Rpb24oZHN0Q3R4LCBzcmMsIHNpemUpIHtcbiAgZHN0Q3R4LmRyYXdJbWFnZShzcmMuY2FudmFzIHx8IHNyYywgMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xufTtcblxuRHJhd2luZy5jbGVhciA9IGZ1bmN0aW9uKGN0eCwgc2l6ZSkge1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUudywgc2l6ZS5oKTtcbn07XG5cbkRyYXdpbmcuZHJhd0NlbnRlckluc2lkZSA9IGZ1bmN0aW9uKGRzdEN0eCwgc3JjLCBkc3RSZWN0LCBzcmNSZWN0KSB7XG4gIGlmIChzcmNSZWN0LncgLyBzcmNSZWN0LmggPiBkc3RSZWN0LncgLyBkc3RSZWN0LmgpIHtcbiAgICB2YXIgaCA9IHNyY1JlY3QuaCAqIGRzdFJlY3QudyAvIHNyY1JlY3QudztcbiAgICAgRHJhd2luZy5kcmF3SW1hZ2VTY2FsZWQoZHN0Q3R4LCBzcmMsXG4gICAgICAgIHNyY1JlY3QueCwgc3JjUmVjdC55LFxuICAgICAgICBzcmNSZWN0LncsIHNyY1JlY3QuaCxcbiAgICAgICAgZHN0UmVjdC54LCBkc3RSZWN0LnkgKyAoZHN0UmVjdC5oIC0gaCkgLyAyLFxuICAgICAgICBkc3RSZWN0LncsIGgpO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gc3JjUmVjdC53ICogZHN0UmVjdC5oIC8gc3JjUmVjdC5oO1xuICAgICBEcmF3aW5nLmRyYXdJbWFnZVNjYWxlZChkc3RDdHgsIHNyYyxcbiAgICAgICAgc3JjUmVjdC54LCBzcmNSZWN0LnksXG4gICAgICAgIHNyY1JlY3Qudywgc3JjUmVjdC5oLFxuICAgICAgICBkc3RSZWN0LnggKyAoZHN0UmVjdC53IC0gdykgLyAyLCBkc3RSZWN0LnksXG4gICAgICAgIHcsIGRzdFJlY3QuaCk7XG4gIH1cbn07XG5cbkRyYXdpbmcuZHJhd0NlbnRlckNyb3AgPSBmdW5jdGlvbihkc3RDdHgsIHNyYywgZHN0UmVjdCwgc3JjUmVjdCkge1xuICBpZiAoc3JjUmVjdC53IC8gc3JjUmVjdC5oID4gZHN0UmVjdC53IC8gZHN0UmVjdC5oKSB7XG4gICAgdmFyIHcgPSBzcmNSZWN0LmggKiBkc3RSZWN0LncgLyBkc3RSZWN0Lmg7XG4gICAgRHJhd2luZy5kcmF3SW1hZ2VTY2FsZWQoZHN0Q3R4LCBzcmMsXG4gICAgICAgIHNyY1JlY3QueCArIChzcmNSZWN0LncgLSB3KSAvIDIsIHNyY1JlY3QueSxcbiAgICAgICAgdywgc3JjUmVjdC5oLFxuICAgICAgICBkc3RSZWN0LngsIGRzdFJlY3QueSxcbiAgICAgICAgZHN0UmVjdC53LCBkc3RSZWN0LmgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBoID0gc3JjUmVjdC53ICogZHN0UmVjdC5oIC8gZHN0UmVjdC53O1xuICAgIERyYXdpbmcuZHJhd0ltYWdlU2NhbGVkKGRzdEN0eCwgc3JjLFxuICAgICAgICBzcmNSZWN0LngsIHNyY1JlY3QueSArIChzcmNSZWN0LmggLSBoKSAvIDIsXG4gICAgICAgIHNyY1JlY3QudywgaCxcbiAgICAgICAgZHN0UmVjdC54LCBkc3RSZWN0LnksXG4gICAgICAgIGRzdFJlY3QudywgZHN0UmVjdC5oKTtcbiAgfVxufTtcblxuRHJhd2luZy5kcmF3SW1hZ2VTY2FsZWQgPSBmdW5jdGlvbihkc3RDdHgsIHNyYywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoKSB7XG4gIHNyYyA9IHNyYy5jYW52YXMgfHwgc3JjO1xuXG4gIC8vIGFsZ29yaXRobTogd2hlbiBzY2FsaW5nIGRvd24sIGRvd25zYW1wbGUgYnkgYXQgbW9zdCBhIGZhY3RvciBvZiAyIHBlciBpdGVyYXRpb25cbiAgLy8gdG8gYXZvaWQgcG9vciBicm93c2VyIGRvd25zYW1wbGluZ1xuICB3aGlsZSAoZHcgPCBzdyAvIDIgfHwgZGggPCBzaCAvIDIpIHtcbiAgICBsZXQgdG1wRHcgPSBNYXRoLmNlaWwoTWF0aC5tYXgoZHcsIHN3IC8gMikpO1xuICAgIGxldCB0bXBEaCA9IE1hdGguY2VpbChNYXRoLm1heChkaCwgc2ggLyAyKSk7XG4gICAgbGV0IHRtcEN0eCA9IERyYXdpbmcuY29udGV4dCh7IHc6IHRtcER3LCBoOiB0bXBEaCB9KTtcblxuICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgdG1wRHcsIHRtcERoKTtcbiAgICB0bXBDdHguZHJhd0ltYWdlKHNyYywgc3gsIHN5LCBzdywgc2gsIDAsIDAsIHRtcER3LCB0bXBEaCk7XG5cbiAgICBzcmMgPSB0bXBDdHguY2FudmFzO1xuICAgIHN4ID0gc3kgPSAwO1xuICAgIHN3ID0gdG1wRHc7XG4gICAgc2ggPSB0bXBEaDtcbiAgfVxuXG4gIGRzdEN0eC5kcmF3SW1hZ2Uoc3JjLCBzeCwgc3ksIHN3LCBzaCwgZHgsIGR5LCBkdywgZGgpO1xufTtcblxuRHJhd2luZy5kcmF3TGF5ZXJzID0gZnVuY3Rpb24oZHN0Q3R4LCBzaXplLCBsYXllclRyZWUpIHtcbiAgZHJhd0xheWVyXyhkc3RDdHgsIGxheWVyVHJlZSk7XG5cbiAgZnVuY3Rpb24gZHJhd0xheWVyXyhkc3RDdHgsIGxheWVyKSB7XG4gICAgbGV0IGxheWVyQ3R4ID0gRHJhd2luZy5jb250ZXh0KHNpemUpO1xuXG4gICAgaWYgKGxheWVyLmNoaWxkcmVuKSB7XG4gICAgICBkcmF3R3JvdXBfKGxheWVyQ3R4LCBsYXllcik7XG4gICAgfSBlbHNlIGlmIChsYXllci5kcmF3KSB7XG4gICAgICBsYXllci5kcmF3KGxheWVyQ3R4KTtcbiAgICB9XG5cbiAgICBpZiAobGF5ZXIuZWZmZWN0cykge1xuICAgICAgLy8gYXBwbHkgZWZmZWN0cyBpbiBhIG5ldyBidWZmZXJcbiAgICAgIGxldCBlZmZlY3RzQ3R4ID0gRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgICAgRWZmZWN0cy5meChsYXllci5lZmZlY3RzLCBlZmZlY3RzQ3R4LCBsYXllckN0eCwgc2l6ZSk7XG4gICAgICBsYXllckN0eCA9IGVmZmVjdHNDdHg7XG4gICAgfVxuXG4gICAgRHJhd2luZy5jb3B5KGRzdEN0eCwgbGF5ZXJDdHgsIHNpemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZHJhd0dyb3VwXyhkc3RDdHgsIGdyb3VwKSB7XG4gICAgbGV0IGRzdEN0eFN0YWNrID0gW2RzdEN0eF07XG5cbiAgICBncm91cC5jaGlsZHJlbi5maWx0ZXIobGF5ZXIgPT4gISFsYXllcikuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBkcmF3TGF5ZXJfKGRzdEN0eFN0YWNrW2RzdEN0eFN0YWNrLmxlbmd0aCAtIDFdLCBsYXllcik7XG4gICAgICBpZiAobGF5ZXIubWFzaykge1xuICAgICAgICAvLyBkcmF3IGZ1dHVyZSBsYXllcnMgaW50byBhIHNlcGFyYXRlIGJ1ZmZlciAobGF0ZXIgZ2V0cyBtYXNrZWQpXG4gICAgICAgIGxldCBtYXNrZWRDb250ZW50Q3R4ID0gRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgICAgICBkc3RDdHhTdGFjay5wdXNoKG1hc2tlZENvbnRlbnRDdHgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgd2hpbGUgKGRzdEN0eFN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCB0YXJnZXRDdHggPSBkc3RDdHhTdGFja1tkc3RDdHhTdGFjay5sZW5ndGggLSAyXTtcbiAgICAgIGxldCBjb250ZW50Q3R4ID0gZHN0Q3R4U3RhY2tbZHN0Q3R4U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB0YXJnZXRDdHguc2F2ZSgpO1xuICAgICAgdGFyZ2V0Q3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2UtYXRvcCc7XG4gICAgICBEcmF3aW5nLmNvcHkodGFyZ2V0Q3R4LCBjb250ZW50Q3R4LCBzaXplKTtcbiAgICAgIHRhcmdldEN0eC5yZXN0b3JlKCk7XG4gICAgICBkc3RDdHhTdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtEcmF3aW5nfSBmcm9tICcuL2RyYXdpbmcnO1xuXG5jb25zdCBPVVRFUl9FRkZFQ1RTID0gbmV3IFNldChbJ291dGVyLXNoYWRvdycsICdjYXN0LXNoYWRvdyddKTtcbmNvbnN0IElOTkVSX0VGRkVDVFMgPSBuZXcgU2V0KFsnaW5uZXItc2hhZG93JywgJ3Njb3JlJ10pO1xuY29uc3QgRklMTF9FRkZFQ1RTID0gbmV3IFNldChbJ2ZpbGwtY29sb3InLCAnZmlsbC1saW5lYXJncmFkaWVudCcsICdmaWxsLXJhZGlhbGdyYWRpZW50J10pO1xuXG5cbmV4cG9ydCBjb25zdCBFZmZlY3RzID0ge1xuICBmeChlZmZlY3RzLCBkc3RDdHgsIHNyYywgc2l6ZSkge1xuICAgIGVmZmVjdHMgPSBlZmZlY3RzIHx8IFtdO1xuXG4gICAgbGV0IG91dGVyRWZmZWN0cyA9IGVmZmVjdHMuZmlsdGVyKGUgPT4gT1VURVJfRUZGRUNUUy5oYXMoZS5lZmZlY3QpKTtcbiAgICBsZXQgaW5uZXJFZmZlY3RzID0gZWZmZWN0cy5maWx0ZXIoZSA9PiBJTk5FUl9FRkZFQ1RTLmhhcyhlLmVmZmVjdCkpO1xuICAgIGxldCBmaWxsRWZmZWN0cyA9IGVmZmVjdHMuZmlsdGVyKGUgPT4gRklMTF9FRkZFQ1RTLmhhcyhlLmVmZmVjdCkpO1xuXG4gICAgbGV0IHRtcEN0eCwgYnVmZmVyQ3R4O1xuXG4gICAgLy8gRmlyc3QgcmVuZGVyIG91dGVyIGVmZmVjdHNcbiAgICBsZXQgcGFkTGVmdCwgcGFkUmlnaHQsIHBhZEJvdHRvbSwgcGFkVG9wO1xuICAgIHBhZExlZnQgPSBwYWRSaWdodCA9IHBhZEJvdHRvbSA9IHBhZFRvcCA9XG4gICAgICAgIG91dGVyRWZmZWN0cy5yZWR1Y2UoKHIsIGUpID0+IE1hdGgubWF4KHIsIGUuYmx1ciB8fCAwKSwgMCk7XG5cbiAgICBsZXQgcGFkZGVkU2l6ZSA9IHtcbiAgICAgIHc6IHNpemUudyArIHBhZExlZnQgKyBwYWRSaWdodCxcbiAgICAgIGg6IHNpemUuaCArIHBhZFRvcCArIHBhZEJvdHRvbVxuICAgIH07XG5cbiAgICB0bXBDdHggPSBEcmF3aW5nLmNvbnRleHQocGFkZGVkU2l6ZSk7XG5cbiAgICBvdXRlckVmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4ge1xuICAgICAgc3dpdGNoIChlZmZlY3QuZWZmZWN0KSB7XG4gICAgICAgIGNhc2UgJ2Nhc3Qtc2hhZG93JzpcbiAgICAgICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHBhZGRlZFNpemUudywgcGFkZGVkU2l6ZS5oKTtcbiAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKHNyYy5jYW52YXMgfHwgc3JjLCBwYWRMZWZ0LCBwYWRUb3ApO1xuICAgICAgICAgIHJlbmRlckNhc3RTaGFkb3dfKHRtcEN0eCwgcGFkZGVkU2l6ZS53LCBwYWRkZWRTaXplLmgpO1xuICAgICAgICAgIGRzdEN0eC5kcmF3SW1hZ2UodG1wQ3R4LmNhbnZhcywgcGFkTGVmdCwgcGFkVG9wLCBzaXplLncsIHNpemUuaCwgMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ291dGVyLXNoYWRvdyc6XG4gICAgICAgICAgbGV0IHRDb2xvciA9IHRpbnljb2xvcihlZmZlY3QuY29sb3IgfHwgJyMwMDAnKTtcbiAgICAgICAgICBsZXQgYWxwaGEgPSB0Q29sb3IuZ2V0QWxwaGEoKTtcbiAgICAgICAgICB0Q29sb3Iuc2V0QWxwaGEoMSk7XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNDYW52YXNGaWx0ZXJzXygpKSB7XG4gICAgICAgICAgICB0bXBDdHguc2F2ZSgpO1xuICAgICAgICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBwYWRkZWRTaXplLncsIHBhZGRlZFNpemUuaCk7XG4gICAgICAgICAgICB0bXBDdHguZmlsdGVyID0gYGJsdXIoJHtlZmZlY3QuYmx1ciB8fCAwfXB4KWA7XG4gICAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKHNyYy5jYW52YXMgfHwgc3JjLCBwYWRMZWZ0LCBwYWRUb3ApO1xuICAgICAgICAgICAgdG1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2UtYXRvcCc7XG4gICAgICAgICAgICB0bXBDdHguZmlsbFN0eWxlID0gdENvbG9yLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgICAgICB0bXBDdHguZmlsbFJlY3QoMCwgMCwgcGFkZGVkU2l6ZS53LCBwYWRkZWRTaXplLmgpO1xuICAgICAgICAgICAgdG1wQ3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgZHN0Q3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGRzdEN0eC50cmFuc2xhdGUoZWZmZWN0LnRyYW5zbGF0ZVggfHwgMCwgZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCk7XG4gICAgICAgICAgICBkc3RDdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgIGRzdEN0eC5kcmF3SW1hZ2UodG1wQ3R4LmNhbnZhcywgcGFkTGVmdCwgcGFkVG9wLCBzaXplLncsIHNpemUuaCwgMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuICAgICAgICAgICAgZHN0Q3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHN0Q3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGRzdEN0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgZHN0Q3R4LnNoYWRvd09mZnNldFggPSBwYWRkZWRTaXplLnc7XG4gICAgICAgICAgICBkc3RDdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICBkc3RDdHguc2hhZG93Q29sb3IgPSB0Q29sb3IudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgICAgIGRzdEN0eC5zaGFkb3dCbHVyID0gY2FudmFzU2hhZG93Qmx1ckZvclJhZGl1c18oZWZmZWN0LmJsdXIgfHwgMCk7XG4gICAgICAgICAgICBkc3RDdHguZHJhd0ltYWdlKHNyYy5jYW52YXMgfHwgc3JjLFxuICAgICAgICAgICAgICAgIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSAtIHBhZGRlZFNpemUudyxcbiAgICAgICAgICAgICAgICAoZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCkpO1xuICAgICAgICAgICAgZHN0Q3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOZXh0LCByZW5kZXIgdGhlIHNvdXJjZSwgZmlsbCBlZmZlY3RzIChmaXJzdCBvbmUpLCBhbmQgaW5uZXIgZWZmZWN0c1xuICAgIC8vIGluIGEgYnVmZmVyIChidWZmZXJDdHgpXG4gICAgYnVmZmVyQ3R4ID0gRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgIHRtcEN0eCA9IERyYXdpbmcuY29udGV4dChzaXplKTtcbiAgICB0bXBDdHguZHJhd0ltYWdlKHNyYy5jYW52YXMgfHwgc3JjLCAwLCAwKTtcbiAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1hdG9wJztcblxuICAgIC8vIEZpbGwgZWZmZWN0c1xuICAgIGxldCBmaWxsT3BhY2l0eSA9IDEuMDtcbiAgICBpZiAoZmlsbEVmZmVjdHMubGVuZ3RoKSB7XG4gICAgICBsZXQgZWZmZWN0ID0gZmlsbEVmZmVjdHNbMF07XG4gICAgICBmaWxsT3BhY2l0eSA9ICgnb3BhY2l0eScgaW4gZWZmZWN0KSA/IGVmZmVjdC5vcGFjaXR5IDogMTtcblxuICAgICAgdG1wQ3R4LnNhdmUoKTtcblxuICAgICAgc3dpdGNoIChlZmZlY3QuZWZmZWN0KSB7XG4gICAgICAgIGNhc2UgJ2ZpbGwtY29sb3InOiB7XG4gICAgICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IGVmZmVjdC5jb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2ZpbGwtbGluZWFyZ3JhZGllbnQnOiB7XG4gICAgICAgICAgbGV0IGdyYWRpZW50ID0gdG1wQ3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgICAgICBlZmZlY3QuZnJvbVgsIGVmZmVjdC5mcm9tWSwgZWZmZWN0LnRvWCwgZWZmZWN0LnRvWSk7XG4gICAgICAgICAgZWZmZWN0LmNvbG9ycy5mb3JFYWNoKCh7b2Zmc2V0LCBjb2xvcn0pID0+IGdyYWRpZW50LmFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKSk7XG4gICAgICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZmlsbC1yYWRpYWxncmFkaWVudCc6IHtcbiAgICAgICAgICBsZXQgZ3JhZGllbnQgPSB0bXBDdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgICAgIGVmZmVjdC5jZW50ZXJYLCBlZmZlY3QuY2VudGVyWSwgMCwgZWZmZWN0LmNlbnRlclgsIGVmZmVjdC5jZW50ZXJZLCBlZmZlY3QucmFkaXVzKTtcbiAgICAgICAgICBlZmZlY3QuY29sb3JzLmZvckVhY2goKHtvZmZzZXQsIGNvbG9yfSkgPT4gZ3JhZGllbnQuYWRkQ29sb3JTdG9wKG9mZnNldCwgY29sb3IpKTtcbiAgICAgICAgICB0bXBDdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHNpemUudywgc2l6ZS5oKTtcbiAgICAgIHRtcEN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgYnVmZmVyQ3R4LnNhdmUoKTtcbiAgICBidWZmZXJDdHguZ2xvYmFsQWxwaGEgPSBmaWxsT3BhY2l0eTtcbiAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRtcEN0eC5jYW52YXMsIDAsIDApO1xuICAgIGJ1ZmZlckN0eC5yZXN0b3JlKCk7XG5cbiAgICAvLyBSZW5kZXIgaW5uZXIgZWZmZWN0c1xuICAgIHBhZExlZnQgPSBwYWRUb3AgPSBwYWRSaWdodCA9IHBhZEJvdHRvbSA9IDA7XG4gICAgaW5uZXJFZmZlY3RzLmZvckVhY2goZWZmZWN0ID0+IHtcbiAgICAgIHBhZExlZnQgICA9IE1hdGgubWF4KHBhZExlZnQsICAgKGVmZmVjdC5ibHVyIHx8IDApICsgTWF0aC5tYXgoMCwgIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSkpO1xuICAgICAgcGFkVG9wICAgID0gTWF0aC5tYXgocGFkVG9wLCAgICAoZWZmZWN0LmJsdXIgfHwgMCkgKyBNYXRoLm1heCgwLCAgKGVmZmVjdC50cmFuc2xhdGVZIHx8IDApKSk7XG4gICAgICBwYWRSaWdodCAgPSBNYXRoLm1heChwYWRSaWdodCwgIChlZmZlY3QuYmx1ciB8fCAwKSArIE1hdGgubWF4KDAsIC0oZWZmZWN0LnRyYW5zbGF0ZVggfHwgMCkpKTtcbiAgICAgIHBhZEJvdHRvbSA9IE1hdGgubWF4KHBhZEJvdHRvbSwgKGVmZmVjdC5ibHVyIHx8IDApICsgTWF0aC5tYXgoMCwgLShlZmZlY3QudHJhbnNsYXRlWSB8fCAwKSkpO1xuICAgIH0pO1xuXG4gICAgcGFkZGVkU2l6ZSA9IHtcbiAgICAgIHc6IHNpemUudyArIHBhZExlZnQgKyBwYWRSaWdodCxcbiAgICAgIGg6IHNpemUuaCArIHBhZFRvcCArIHBhZEJvdHRvbVxuICAgIH07XG5cbiAgICB0bXBDdHggPSBEcmF3aW5nLmNvbnRleHQocGFkZGVkU2l6ZSk7XG5cbiAgICBpbm5lckVmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4ge1xuICAgICAgc3dpdGNoIChlZmZlY3QuZWZmZWN0KSB7XG4gICAgICAgIGNhc2UgJ2lubmVyLXNoYWRvdyc6XG4gICAgICAgICAgdG1wQ3R4LnNhdmUoKTtcbiAgICAgICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHBhZGRlZFNpemUudywgcGFkZGVkU2l6ZS5oKTtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNDYW52YXNGaWx0ZXJzXygpKSB7XG4gICAgICAgICAgICB0bXBDdHguZmlsdGVyID0gYGJsdXIoJHtlZmZlY3QuYmx1ciB8fCAwfXB4KWA7XG4gICAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKGJ1ZmZlckN0eC5jYW52YXMsXG4gICAgICAgICAgICAgICAgcGFkTGVmdCArIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSxcbiAgICAgICAgICAgICAgICBwYWRUb3AgKyAoZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBDdHguc2hhZG93T2Zmc2V0WCA9IHBhZGRlZFNpemUudztcbiAgICAgICAgICAgIHRtcEN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRtcEN0eC5zaGFkb3dDb2xvciA9ICcjMDAwJzsgLy8gY29sb3IgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgIHRtcEN0eC5zaGFkb3dCbHVyID0gY2FudmFzU2hhZG93Qmx1ckZvclJhZGl1c18oZWZmZWN0LmJsdXIgfHwgMCk7XG4gICAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKGJ1ZmZlckN0eC5jYW52YXMsXG4gICAgICAgICAgICAgICAgcGFkTGVmdCArIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSAtIHBhZGRlZFNpemUudyxcbiAgICAgICAgICAgICAgICBwYWRUb3AgKyAoZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdXQnO1xuICAgICAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSBlZmZlY3QuY29sb3I7XG4gICAgICAgICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHBhZGRlZFNpemUudywgcGFkZGVkU2l6ZS5oKTtcbiAgICAgICAgICB0bXBDdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgYnVmZmVyQ3R4LnNhdmUoKTtcbiAgICAgICAgICBidWZmZXJDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1hdG9wJztcbiAgICAgICAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRtcEN0eC5jYW52YXMsIC1wYWRMZWZ0LCAtcGFkVG9wKTtcbiAgICAgICAgICBidWZmZXJDdHgucmVzdG9yZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRHJhdyBidWZmZXIgKHNvdXJjZSwgZmlsbCwgaW5uZXIgZWZmZWN0cykgb24gdG9wIG9mIG91dGVyIGVmZmVjdHNcbiAgICBkc3RDdHguZHJhd0ltYWdlKGJ1ZmZlckN0eC5jYW52YXMsIDAsIDApO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVuZGVyQ2FzdFNoYWRvd18oY3R4LCB3LCBoKSB7XG4gIGxldCB0bXBDdHggPSBEcmF3aW5nLmNvbnRleHQoe3csIGh9KTtcbiAgLy8gcmVuZGVyIHRoZSBjYXN0IHNoYWRvd1xuICBmb3IgKGxldCBvID0gMTsgbyA8IE1hdGgubWF4KHcsIGgpOyBvKyspIHtcbiAgICB0bXBDdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIG8sIG8pO1xuICB9XG4gIHRtcEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLWluJztcbiAgdG1wQ3R4LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICBsZXQgZ3JhZGllbnQgPSB0bXBDdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgdywgaCk7XG4gIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAncmdiYSgwLCAwLCAwLCAuMiknKTtcbiAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICdyZ2JhKDAsIDAsIDAsIDApJyk7XG4gIHRtcEN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICBjdHguZHJhd0ltYWdlKHRtcEN0eC5jYW52YXMsIDAsIDApO1xufVxuXG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ2FudmFzRmlsdGVyc18oKSB7XG4gIGlmICghc3VwcG9ydHNDYW52YXNGaWx0ZXJzXy5oYXNPd25Qcm9wZXJ0eSgnY2FjaGVkJykpIHtcbiAgICBzdXBwb3J0c0NhbnZhc0ZpbHRlcnNfLmNhY2hlZCA9IChcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKS5maWx0ZXIgPT0gJ25vbmUnKTtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c0NhbnZhc0ZpbHRlcnNfLmNhY2hlZDtcbn1cblxuXG4vLyBkZXRlcm1pbmVkIGVtcGlyaWNhbGx5OiBodHRwOi8vY29kZXBlbi5pby9hbm9uL3Blbi9nZ0xPcUpcbmNvbnN0IEJMVVJfTVVMVElQTElFUiA9IFtcbiAge3JlOiAvY2hyb21lL2ksIG11bHQ6IDIuN30sXG4gIHtyZTogL3NhZmFyaS9pLCBtdWx0OiAxLjh9LFxuICB7cmU6IC9maXJlZm94L2ksIG11bHQ6IDEuN30sXG4gIHtyZTogLy4vaSwgbXVsdDogMS43fSwgLy8gZGVmYXVsdFxuXS5maW5kKHggPT4geC5yZS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKS5tdWx0O1xuXG5cbmZ1bmN0aW9uIGNhbnZhc1NoYWRvd0JsdXJGb3JSYWRpdXNfKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzICogQkxVUl9NVUxUSVBMSUVSO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7RWZmZWN0c30gZnJvbSAnLi9lZmZlY3RzJztcbmltcG9ydCB7RHJhd2luZ30gZnJvbSAnLi9kcmF3aW5nJztcbmltcG9ydCB7QW5hbHlzaXN9IGZyb20gJy4vYW5hbHlzaXMnO1xuXG5leHBvcnQgY29uc3QgaW1hZ2VsaWIgPSB7XG4gIERyYXdpbmcsXG4gIEVmZmVjdHMsXG4gIEFuYWx5c2lzLFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge3N0dWRpb30gZnJvbSAnLi4vc3R1ZGlvJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uL2ltYWdlbGliJztcbmltcG9ydCB7QmFzZUdlbmVyYXRvcn0gZnJvbSAnLi9iYXNlZ2VuZXJhdG9yJztcblxuY29uc3QgSUNPTl9TSVpFID0geyB3OiAyNCwgaDogMjQgfTtcbmNvbnN0IFRBUkdFVF9SRUNUID0geyB4OiAwLCB5OiAwLCB3OiAyNCwgaDogMjQgfTtcblxuY29uc3QgR1JJRF9PVkVSTEFZX1NWRyA9XG4gICAgYDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIjRcIiB5PVwiMlwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIyMFwiIHJ4PVwiMlwiLz5cbiAgICAgICAgICAgIDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiM1wiIHk9XCIzXCIgd2lkdGg9XCIxOFwiIGhlaWdodD1cIjE4XCIgcng9XCIyXCIvPlxuICAgICAgICAgICAgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCIyXCIgeT1cIjRcIiB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIi8+XG4gICAgICAgICAgICA8Y2lyY2xlIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI1XCIvPlxuICAgICAgICAgICAgPGNpcmNsZSB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiMTBcIi8+XG4gICAgICAgICAgICA8cGF0aCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgZD1cIk0wIDI0TDI0IDBNMCAwbDI0IDI0bS0xMiAwVjBNOCAwdjI0bTgtMjR2MjRtOC0xMkgwbTAgNGgyNE0wIDhoMjRcIi8+XG4gICAgICAgIDwvZz5cbiAgICA8L3N2Zz5gO1xuXG5leHBvcnQgY2xhc3MgQWN0aW9uQmFySWNvbkdlbmVyYXRvciBleHRlbmRzIEJhc2VHZW5lcmF0b3Ige1xuICBnZXQgZ3JpZE92ZXJsYXlTdmcoKSB7XG4gICAgcmV0dXJuIEdSSURfT1ZFUkxBWV9TVkc7XG4gIH1cblxuICBzZXR1cEZvcm0oKSB7XG4gICAgc3VwZXIuc2V0dXBGb3JtKCk7XG5cbiAgICBsZXQgbmFtZUZpZWxkLCBjdXN0b21Db2xvckZpZWxkO1xuICAgIHRoaXMuZm9ybSA9IG5ldyBzdHVkaW8uRm9ybSh7XG4gICAgICBpZDogJ2ljb25mb3JtJyxcbiAgICAgIGNvbnRhaW5lcjogJyNpbnB1dHMtZm9ybScsXG4gICAgICBmaWVsZHM6IFtcbiAgICAgICAgbmV3IHN0dWRpby5JbWFnZUZpZWxkKCdzb3VyY2UnLCB7XG4gICAgICAgICAgdGl0bGU6ICdTb3VyY2UnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnTXVzdCBiZSB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgbWF4RmluYWxTaXplOiB7IHc6IDEyOCwgaDogMTI4IH0sXG4gICAgICAgICAgY2xpcGFydE5vVHJpbVBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlQ2xpcGFydDogJ2FkZF9jaXJjbGUnLFxuICAgICAgICAgIGRyb3BUYXJnZXQ6IGRvY3VtZW50LmJvZHlcbiAgICAgICAgfSksXG4gICAgICAgIChuYW1lRmllbGQgPSBuZXcgc3R1ZGlvLlRleHRGaWVsZCgnbmFtZScsIHtcbiAgICAgICAgICBuZXdHcm91cDogdHJ1ZSxcbiAgICAgICAgICB0aXRsZTogJ05hbWUnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnVXNlZCB3aGVuIGdlbmVyYXRpbmcgWklQIGZpbGVzLicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnaWNfYWN0aW9uX2V4YW1wbGUnXG4gICAgICAgIH0pKSxcbiAgICAgICAgbmV3IHN0dWRpby5FbnVtRmllbGQoJ3RoZW1lJywge1xuICAgICAgICAgIHRpdGxlOiAnVGhlbWUnLFxuICAgICAgICAgIGJ1dHRvbnM6IHRydWUsXG4gICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgeyBpZDogJ2xpZ2h0JywgdGl0bGU6ICdMaWdodCcgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdkYXJrJywgdGl0bGU6ICdEYXJrJyB9LFxuICAgICAgICAgICAgeyBpZDogJ2N1c3RvbScsIHRpdGxlOiAnQ3VzdG9tJyB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdsaWdodCdcbiAgICAgICAgfSksXG4gICAgICAgIChjdXN0b21Db2xvckZpZWxkID0gbmV3IHN0dWRpby5Db2xvckZpZWxkKCdjb2xvcicsIHtcbiAgICAgICAgICB0aXRsZTogJ0NvbG9yJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdyZ2JhKDMzLCAxNTAsIDI0MywgLjYpJyxcbiAgICAgICAgICBhbHBoYTogdHJ1ZVxuICAgICAgICB9KSlcbiAgICAgIF1cbiAgICB9KTtcbiAgICB0aGlzLmZvcm0ub25DaGFuZ2UoZmllbGQgPT4ge1xuICAgICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcbiAgICAgIGlmICgoIWZpZWxkIHx8IGZpZWxkLmlkXyA9PSAnc291cmNlJylcbiAgICAgICAgICAmJiB2YWx1ZXMuc291cmNlICYmIHZhbHVlcy5zb3VyY2UubmFtZSkge1xuICAgICAgICBsZXQgbmFtZSA9ICdpY19hY3Rpb25fJyArIHN0dWRpby5VdGlsLnNhbml0aXplUmVzb3VyY2VOYW1lKHZhbHVlcy5zb3VyY2UubmFtZSk7XG4gICAgICAgIGlmIChuYW1lICE9IG5hbWVGaWVsZC5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgbmFtZUZpZWxkLnNldFZhbHVlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICQoJy5vdXRwdXRzLXBhbmVsJykuYXR0cignZGF0YS10aGVtZScsIHZhbHVlcy50aGVtZSk7XG4gICAgICBjdXN0b21Db2xvckZpZWxkLnNldEVuYWJsZWQodmFsdWVzLnRoZW1lID09ICdjdXN0b20nKTtcbiAgICAgIHRoaXMucmVnZW5lcmF0ZURlYm91bmNlZF8oKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlZ2VuZXJhdGUoKSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcblxuICAgIHRoaXMuemlwcGVyLmNsZWFyKCk7XG4gICAgdGhpcy56aXBwZXIuc2V0WmlwRmlsZW5hbWUoYCR7dmFsdWVzLm5hbWV9LnppcGApO1xuXG4gICAgdGhpcy5kZW5zaXRpZXMuZm9yRWFjaChkZW5zaXR5ID0+IHtcbiAgICAgIGxldCBtdWx0ID0gc3R1ZGlvLlV0aWwuZ2V0TXVsdEJhc2VNZHBpKGRlbnNpdHkpO1xuICAgICAgbGV0IGljb25TaXplID0gc3R1ZGlvLlV0aWwubXVsdFJvdW5kKElDT05fU0laRSwgbXVsdCk7XG5cbiAgICAgIGxldCBvdXRDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuICAgICAgbGV0IHRtcEN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChpY29uU2l6ZSk7XG5cbiAgICAgIGlmICh2YWx1ZXMuc291cmNlLmN0eCkge1xuICAgICAgICBsZXQgc3JjQ3R4ID0gdmFsdWVzLnNvdXJjZS5jdHg7XG4gICAgICAgIGltYWdlbGliLkRyYXdpbmcuZHJhd0NlbnRlckluc2lkZShcbiAgICAgICAgICAgIHRtcEN0eCxcbiAgICAgICAgICAgIHNyY0N0eCxcbiAgICAgICAgICAgIHN0dWRpby5VdGlsLm11bHQoVEFSR0VUX1JFQ1QsIG11bHQpLFxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHc6IHNyY0N0eC5jYW52YXMud2lkdGgsIGg6IHNyY0N0eC5jYW52YXMuaGVpZ2h0fSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBjb2xvciA9IHZhbHVlcy5jb2xvcjtcbiAgICAgIGlmICh2YWx1ZXMudGhlbWUgPT0gJ2xpZ2h0Jykge1xuICAgICAgICBjb2xvciA9IHRpbnljb2xvcigncmdiYSgwLCAwLCAwLCAuNTQpJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlcy50aGVtZSA9PSAnZGFyaycpIHtcbiAgICAgICAgY29sb3IgPSB0aW55Y29sb3IoJyNmZmYnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFscGhhID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICAgIGNvbG9yLnNldEFscGhhKDEpO1xuXG4gICAgICBpbWFnZWxpYi5FZmZlY3RzLmZ4KFtcbiAgICAgICAge2VmZmVjdDogJ2ZpbGwtY29sb3InLCBjb2xvcjogY29sb3IudG9SZ2JTdHJpbmcoKSwgb3BhY2l0eTogYWxwaGF9XG4gICAgICBdLCBvdXRDdHgsIHRtcEN0eCwgaWNvblNpemUpO1xuXG4gICAgICB0aGlzLnppcHBlci5hZGQoe1xuICAgICAgICBuYW1lOiBgcmVzL2RyYXdhYmxlLSR7ZGVuc2l0eX0vJHt2YWx1ZXMubmFtZX0ucG5nYCxcbiAgICAgICAgY2FudmFzOiBvdXRDdHguY2FudmFzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zZXRJbWFnZUZvclNsb3RfKGRlbnNpdHksIG91dEN0eC5jYW52YXMudG9EYXRhVVJMKCkpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtzdHVkaW99IGZyb20gJy4uL3N0dWRpbyc7XG5pbXBvcnQge2ltYWdlbGlifSBmcm9tICcuLi9pbWFnZWxpYic7XG5pbXBvcnQge0Jhc2VHZW5lcmF0b3J9IGZyb20gJy4vYmFzZWdlbmVyYXRvcic7XG5cbmNvbnN0IElDT05fU0laRSA9IHsgdzogNDgsIGg6IDQ4IH07XG5jb25zdCBUQVJHRVRfUkVDVCA9IHsgeDogMTIsIHk6IDEyLCB3OiAyNCwgaDogMjQgfTtcblxuY29uc3QgR1JJRF9PVkVSTEFZX1NWRyA9XG4gICAgYDxzdmcgd2lkdGg9XCI0OFwiIGhlaWdodD1cIjQ4XCIgdmlld0JveD1cIjAgMCA0OCA0OFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIjEyXCIgeT1cIjEyXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIvPlxuICAgICAgICA8L2c+XG4gICAgPC9zdmc+YDtcblxuZXhwb3J0IGNsYXNzIEFwcFNob3J0Y3V0SWNvbkdlbmVyYXRvciBleHRlbmRzIEJhc2VHZW5lcmF0b3Ige1xuICBnZXQgZ3JpZE92ZXJsYXlTdmcoKSB7XG4gICAgcmV0dXJuIEdSSURfT1ZFUkxBWV9TVkc7XG4gIH1cblxuICBzZXR1cEZvcm0oKSB7XG4gICAgc3VwZXIuc2V0dXBGb3JtKCk7XG5cbiAgICBsZXQgbmFtZUZpZWxkLCBjdXN0b21Db2xvckZpZWxkO1xuICAgIHRoaXMuZm9ybSA9IG5ldyBzdHVkaW8uRm9ybSh7XG4gICAgICBpZDogJ2ljb25mb3JtJyxcbiAgICAgIGNvbnRhaW5lcjogJyNpbnB1dHMtZm9ybScsXG4gICAgICBmaWVsZHM6IFtcbiAgICAgICAgbmV3IHN0dWRpby5JbWFnZUZpZWxkKCdzb3VyY2UnLCB7XG4gICAgICAgICAgdGl0bGU6ICdTb3VyY2UnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnTXVzdCBiZSB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgbWF4RmluYWxTaXplOiB7IHc6IDEyOCwgaDogMTI4IH0sXG4gICAgICAgICAgY2xpcGFydE5vVHJpbVBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlQ2xpcGFydDogJ3NlYXJjaCcsXG4gICAgICAgICAgZHJvcFRhcmdldDogZG9jdW1lbnQuYm9keVxuICAgICAgICB9KSxcbiAgICAgICAgKG5hbWVGaWVsZCA9IG5ldyBzdHVkaW8uVGV4dEZpZWxkKCduYW1lJywge1xuICAgICAgICAgIG5ld0dyb3VwOiB0cnVlLFxuICAgICAgICAgIHRpdGxlOiAnTmFtZScsXG4gICAgICAgICAgaGVscFRleHQ6ICdVc2VkIHdoZW4gZ2VuZXJhdGluZyBaSVAgZmlsZXMuJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdpY19zaG9ydGN1dF9leGFtcGxlJ1xuICAgICAgICB9KSksXG4gICAgICAgIG5ldyBzdHVkaW8uQ29sb3JGaWVsZCgnZm9yZUNvbG9yJywge1xuICAgICAgICAgIHRpdGxlOiAnQ29sb3InLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJyM0NDhhZmYnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgc3R1ZGlvLkNvbG9yRmllbGQoJ2JhY2tDb2xvcicsIHtcbiAgICAgICAgICB0aXRsZTogJ0JhY2tncm91bmQgY29sb3InLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJyNmNWY1ZjUnXG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5mb3JtLm9uQ2hhbmdlKGZpZWxkID0+IHtcbiAgICAgIGxldCB2YWx1ZXMgPSB0aGlzLmZvcm0uZ2V0VmFsdWVzKCk7XG4gICAgICBpZiAoKCFmaWVsZCB8fCBmaWVsZC5pZF8gPT0gJ3NvdXJjZScpXG4gICAgICAgICAgJiYgdmFsdWVzLnNvdXJjZSAmJiB2YWx1ZXMuc291cmNlLm5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSAnaWNfc2hvcnRjdXRfJyArIHN0dWRpby5VdGlsLnNhbml0aXplUmVzb3VyY2VOYW1lKHZhbHVlcy5zb3VyY2UubmFtZSk7XG4gICAgICAgIGlmIChuYW1lICE9IG5hbWVGaWVsZC5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgbmFtZUZpZWxkLnNldFZhbHVlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICQoJy5vdXRwdXRzLXBhbmVsJykuYXR0cignZGF0YS10aGVtZScsIHZhbHVlcy50aGVtZSk7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGVEZWJvdW5jZWRfKCk7XG4gICAgfSk7XG4gIH1cblxuICByZWdlbmVyYXRlKCkge1xuICAgIGxldCB2YWx1ZXMgPSB0aGlzLmZvcm0uZ2V0VmFsdWVzKCk7XG5cbiAgICB0aGlzLnppcHBlci5jbGVhcigpO1xuICAgIHRoaXMuemlwcGVyLnNldFppcEZpbGVuYW1lKGAke3ZhbHVlcy5uYW1lfS56aXBgKTtcblxuICAgIHRoaXMuZGVuc2l0aWVzLmZvckVhY2goZGVuc2l0eSA9PiB7XG4gICAgICBsZXQgbXVsdCA9IHN0dWRpby5VdGlsLmdldE11bHRCYXNlTWRwaShkZW5zaXR5KTtcbiAgICAgIGxldCBpY29uU2l6ZSA9IHN0dWRpby5VdGlsLm11bHRSb3VuZChJQ09OX1NJWkUsIG11bHQpO1xuXG4gICAgICBsZXQgb3V0Q3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KGljb25TaXplKTtcbiAgICAgIGxldCB0bXBDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuXG4gICAgICBvdXRDdHguc2F2ZSgpO1xuICAgICAgb3V0Q3R4LmJlZ2luUGF0aCgpO1xuICAgICAgb3V0Q3R4LmFyYygyNCAqIG11bHQsIDI0ICogbXVsdCwgMjIgKiBtdWx0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICBvdXRDdHguY2xvc2VQYXRoKCk7XG4gICAgICB2YWx1ZXMuYmFja0NvbG9yLnNldEFscGhhKDEpO1xuICAgICAgb3V0Q3R4LmZpbGxTdHlsZSA9IHZhbHVlcy5iYWNrQ29sb3IudG9SZ2JTdHJpbmcoKTtcbiAgICAgIG91dEN0eC5maWxsKCk7XG4gICAgICBvdXRDdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodmFsdWVzLnNvdXJjZS5jdHgpIHtcbiAgICAgICAgbGV0IHNyY0N0eCA9IHZhbHVlcy5zb3VyY2UuY3R4O1xuICAgICAgICBpbWFnZWxpYi5EcmF3aW5nLmRyYXdDZW50ZXJJbnNpZGUoXG4gICAgICAgICAgICB0bXBDdHgsXG4gICAgICAgICAgICBzcmNDdHgsXG4gICAgICAgICAgICBzdHVkaW8uVXRpbC5tdWx0KFRBUkdFVF9SRUNULCBtdWx0KSxcbiAgICAgICAgICAgIHt4OiAwLCB5OiAwLCB3OiBzcmNDdHguY2FudmFzLndpZHRoLCBoOiBzcmNDdHguY2FudmFzLmhlaWdodH0pO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMuZm9yZUNvbG9yLnNldEFscGhhKDEpO1xuICAgICAgaW1hZ2VsaWIuRWZmZWN0cy5meChbXG4gICAgICAgIHtlZmZlY3Q6ICdmaWxsLWNvbG9yJywgY29sb3I6IHZhbHVlcy5mb3JlQ29sb3IudG9SZ2JTdHJpbmcoKX1cbiAgICAgIF0sIG91dEN0eCwgdG1wQ3R4LCBpY29uU2l6ZSk7XG5cbiAgICAgIHRoaXMuemlwcGVyLmFkZCh7XG4gICAgICAgIG5hbWU6IGByZXMvZHJhd2FibGUtJHtkZW5zaXR5fS8ke3ZhbHVlcy5uYW1lfS5wbmdgLFxuICAgICAgICBjYW52YXM6IG91dEN0eC5jYW52YXNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldEltYWdlRm9yU2xvdF8oZGVuc2l0eSwgb3V0Q3R4LmNhbnZhcy50b0RhdGFVUkwoKSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge3N0dWRpb30gZnJvbSAnLi4vc3R1ZGlvJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uL2ltYWdlbGliJztcblxuY29uc3QgREVOU0lUSUVTID0gbmV3IFNldChbJ3h4eGhkcGknLCAneHhoZHBpJywgJ3hoZHBpJywgJ2hkcGknLCAnbWRwaSddKTtcbmNvbnN0IFJFR0VORVJBVEVfREVCT1VOQ0VfVElNRSA9IDIwMDtcblxuY29uc3QgSUNPTl9TSVpFID0geyB3OiAyNCwgaDogMjQgfTtcbmNvbnN0IFRBUkdFVF9SRUNUID0geyB4OiAwLCB5OiAwLCB3OiAyNCwgaDogMjQgfTtcblxuXG5leHBvcnQgY2xhc3MgQmFzZUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnZW5lcmF0ZURlYm91bmNlZF8gPSBzdHVkaW8uVXRpbC5kZWJvdW5jZShcbiAgICAgICAgUkVHRU5FUkFURV9ERUJPVU5DRV9USU1FLFxuICAgICAgICAoKSA9PiB0aGlzLnJlZ2VuZXJhdGUoKSk7XG5cbiAgICB0aGlzLnNldHVwWmlwcGVyKCk7XG4gICAgdGhpcy5zZXR1cE91dHB1dFVpKCk7XG4gICAgdGhpcy5zZXR1cE91dHB1dFNsb3RzKCk7XG4gICAgdGhpcy5zZXR1cEZvcm0oKTtcbiAgICBzdHVkaW8uSGFzaC5iaW5kRm9ybVRvRG9jdW1lbnRIYXNoKHRoaXMuZm9ybSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlZ2VuZXJhdGUoKSwgMCk7XG4gIH1cblxuICBzZXR1cFppcHBlcigpIHtcbiAgICB0aGlzLnppcHBlciA9IHN0dWRpby5aaXAuY3JlYXRlRG93bmxvYWRpZnlaaXBCdXR0b24oJCgnI2Rvd25sb2FkLXppcC1idXR0b24nKSk7XG4gIH1cblxuICBzZXR1cE91dHB1dFVpKCkge1xuICAgIC8vIGdyaWQgdG9nZ2xlXG4gICAgaWYgKHRoaXMuZ3JpZE92ZXJsYXlTdmcpIHtcbiAgICAgIGxldCBkZWZhdWx0Q2hlY2tlZCA9ICgnYXNzZXRTdHVkaW9TaG93R3JpZCcgaW4gbG9jYWxTdG9yYWdlKVxuICAgICAgICAgID8gbG9jYWxTdG9yYWdlLmFzc2V0U3R1ZGlvU2hvd0dyaWQgPT09ICd0cnVlJ1xuICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICQoJyNncmlkLXRvZ2dsZScpLnByb3AoJ2NoZWNrZWQnLCBkZWZhdWx0Q2hlY2tlZCk7XG4gICAgICAkKCcub3V0cHV0cy1wYW5lbCcpLnRvZ2dsZUNsYXNzKCdzaG93LWdyaWQnLCBkZWZhdWx0Q2hlY2tlZCk7XG5cbiAgICAgICQoJyNncmlkLXRvZ2dsZScpLmNsaWNrKGV2ID0+IHtcbiAgICAgICAgbGV0IGNoZWNrZWQgPSAkKGV2LmN1cnJlbnRUYXJnZXQpLmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UuYXNzZXRTdHVkaW9TaG93R3JpZCA9IFN0cmluZyhjaGVja2VkKTtcbiAgICAgICAgJCgnLm91dHB1dHMtcGFuZWwnKS50b2dnbGVDbGFzcygnc2hvdy1ncmlkJywgY2hlY2tlZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCgnI2dyaWQtdG9nZ2xlLWNvbnRhaW5lcicpLmhpZGUoKTtcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHNsb3RzIHRvZ2dsZVxuICAgICQoJy5vdXRwdXRzLWFkZGl0aW9uYWwtdG9nZ2xlJykuY2xpY2soKCkgPT4gJCgnLm91dHB1dHMtcGFuZWwnKS50b2dnbGVDbGFzcygnaXMtc2hvd2luZy1hbGwnKSk7XG4gIH1cblxuICBzZXR1cE91dHB1dFNsb3RzKCkge1xuICAgIHRoaXMuZGVuc2l0aWVzLmZvckVhY2goZGVuc2l0eSA9PiB7XG4gICAgICB0aGlzLmNyZWF0ZUltYWdlT3V0cHV0U2xvdF8oe1xuICAgICAgICBjb250YWluZXI6IChkZW5zaXR5ID09ICd4eHhoZHBpJykgPyAkKCcub3V0cHV0cy1tYWluJykgOiAkKCcub3V0cHV0cy1hZGRpdGlvbmFsJyksXG4gICAgICAgIGlkOiBkZW5zaXR5LFxuICAgICAgICBsYWJlbDogZGVuc2l0eVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgZGVuc2l0aWVzKCkge1xuICAgIHJldHVybiBERU5TSVRJRVM7XG4gIH1cblxuICBjcmVhdGVJbWFnZU91dHB1dFNsb3RfKHBhcmFtcykge1xuICAgIGxldCAkaW1hZ2VDb250YWluZXIgPSAkKCc8ZGl2PicpXG4gICAgICAgIC5hZGRDbGFzcygnb3V0cHV0cy1pbWFnZS1jb250YWluZXInKVxuICAgICAgICAuYXBwZW5kKCQoJzxpbWc+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ291dHB1dHMtaW1hZ2UnKVxuICAgICAgICAgIC5hdHRyKCdkYXRhLWlkJywgYG91dC1pY29uLSR7cGFyYW1zLmlkfWApKTtcblxuICAgIGlmICh0aGlzLmdyaWRPdmVybGF5U3ZnKSB7XG4gICAgICAkKCc8ZGl2PicpXG4gICAgICAgICAgLmFkZENsYXNzKCdvdXRwdXRzLWltYWdlLW92ZXJsYXknKVxuICAgICAgICAgIC5odG1sKHRoaXMuZ3JpZE92ZXJsYXlTdmcpXG4gICAgICAgICAgLmFwcGVuZFRvKCRpbWFnZUNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbGV0ICRibG9jayA9ICQoJzxkaXY+JylcbiAgICAgICAgLmFkZENsYXNzKCdvdXRwdXRzLWltYWdlLWJsb2NrJylcbiAgICAgICAgLmFwcGVuZCgkKCc8ZGl2PicpXG4gICAgICAgICAgLmFkZENsYXNzKCdvdXRwdXRzLWxhYmVsJylcbiAgICAgICAgICAudGV4dChwYXJhbXMubGFiZWwpKVxuICAgICAgICAuYXBwZW5kKCRpbWFnZUNvbnRhaW5lcilcbiAgICAgICAgLmFwcGVuZFRvKHBhcmFtcy5jb250YWluZXIpO1xuXG4gICAgcmV0dXJuICRibG9jaztcbiAgfVxuXG4gIHNldEltYWdlRm9yU2xvdF8oaWQsIHVybCkge1xuICAgIHN0dWRpby5VdGlsLmxvYWRJbWFnZUZyb21VcmkodXJsKVxuICAgICAgICAudGhlbihpbWcgPT4gJChgW2RhdGEtaWQ9XCJvdXQtaWNvbi0ke2lkfVwiXWApLmF0dHIoJ3NyYycsIGltZy5zcmMpKTtcbiAgfVxuXG4gIHNldHVwRm9ybSgpIHtcbiAgfVxuXG4gIHJlZ2VuZXJhdGUoKSB7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge3N0dWRpb30gZnJvbSAnLi4vc3R1ZGlvJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uL2ltYWdlbGliJztcbmltcG9ydCB7QmFzZUdlbmVyYXRvcn0gZnJvbSAnLi9iYXNlZ2VuZXJhdG9yJztcblxuY29uc3QgSUNPTl9TSVpFID0ge3c6IDI0LCBoOiAyNH07XG5jb25zdCBUQVJHRVRfUkVDVCA9IHt4OiAxLCB5OiAxLCB3OiAyMiwgaDogMjJ9O1xuXG5leHBvcnQgY2xhc3MgR2VuZXJpY0ljb25HZW5lcmF0b3IgZXh0ZW5kcyBCYXNlR2VuZXJhdG9yIHtcbiAgc2V0dXBGb3JtKCkge1xuICAgIHN1cGVyLnNldHVwRm9ybSgpO1xuXG4gICAgbGV0IG5hbWVGaWVsZDtcbiAgICB0aGlzLmZvcm0gPSBuZXcgc3R1ZGlvLkZvcm0oe1xuICAgICAgaWQ6ICdpY29uZm9ybScsXG4gICAgICBjb250YWluZXI6ICcjaW5wdXRzLWZvcm0nLFxuICAgICAgZmllbGRzOiBbXG4gICAgICAgIG5ldyBzdHVkaW8uSW1hZ2VGaWVsZCgnc291cmNlJywge1xuICAgICAgICAgIHRpdGxlOiAnU291cmNlJyxcbiAgICAgICAgICBoZWxwVGV4dDogJ011c3QgYmUgdHJhbnNwYXJlbnQnLFxuICAgICAgICAgIG1heEZpbmFsU2l6ZTogeyB3OiA3MjAsIGg6IDcyMCB9LCAvLyBtYXggcmVuZGVyIHNpemUsIGZvciBTVkdzXG4gICAgICAgICAgZGVmYXVsdFZhbHVlQ2xpcGFydDogJ2FjX3VuaXQnLFxuICAgICAgICAgIGRyb3BUYXJnZXQ6IGRvY3VtZW50LmJvZHlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBzdHVkaW8uUmFuZ2VGaWVsZCgnc2l6ZScsIHtcbiAgICAgICAgICBuZXdHcm91cDogdHJ1ZSxcbiAgICAgICAgICB0aXRsZTogJ0Fzc2V0IHNpemUnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnU2l6ZSBvZiB0aGUgZmluYWwgYXNzZXQnLFxuICAgICAgICAgIG1pbjogNCxcbiAgICAgICAgICBtYXg6IDIwMCxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IDMyLFxuICAgICAgICAgIHRleHRGbjogZCA9PiBgJHtkfWRwYCxcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBzdHVkaW8uUmFuZ2VGaWVsZCgncGFkZGluZycsIHtcbiAgICAgICAgICB0aXRsZTogJ0Fzc2V0IHBhZGRpbmcnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnUGFkZGluZyBhcm91bmQgdGhlIGljb24gYXNzZXQnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogOCxcbiAgICAgICAgICB0ZXh0Rm46IGQgPT4gYCR7ZH1kcGAsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgc3R1ZGlvLkNvbG9yRmllbGQoJ2NvbG9yJywge1xuICAgICAgICAgIHRpdGxlOiAnQ29sb3InLFxuICAgICAgICAgIGhlbHBUZXh0OiAnRmxhdCBmb3JlZ3JvdW5kIGNvbG9yJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdyZ2JhKDAsIDAsIDAsIDAuNTQpJyxcbiAgICAgICAgICBhbHBoYTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgKG5hbWVGaWVsZCA9IG5ldyBzdHVkaW8uVGV4dEZpZWxkKCduYW1lJywge1xuICAgICAgICAgIHRpdGxlOiAnTmFtZScsXG4gICAgICAgICAgaGVscFRleHQ6ICdVc2VkIHdoZW4gZ2VuZXJhdGluZyBaSVAgZmlsZXMgYXMgdGhlIHJlc291cmNlIG5hbWUuJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdpY19leGFtcGxlJ1xuICAgICAgICB9KSlcbiAgICAgIF1cbiAgICB9KTtcbiAgICB0aGlzLmZvcm0ub25DaGFuZ2UoZmllbGQgPT4ge1xuICAgICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcbiAgICAgIGlmICgoIWZpZWxkIHx8IGZpZWxkLmlkXyA9PSAnc291cmNlJylcbiAgICAgICAgICAmJiB2YWx1ZXMuc291cmNlICYmIHZhbHVlcy5zb3VyY2UubmFtZSkge1xuICAgICAgICBsZXQgbmFtZSA9ICdpY18nICsgc3R1ZGlvLlV0aWwuc2FuaXRpemVSZXNvdXJjZU5hbWUodmFsdWVzLnNvdXJjZS5uYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgIT0gbmFtZUZpZWxkLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICBuYW1lRmllbGQuc2V0VmFsdWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWdlbmVyYXRlRGVib3VuY2VkXygpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVnZW5lcmF0ZSgpIHtcbiAgICBsZXQgdmFsdWVzID0gdGhpcy5mb3JtLmdldFZhbHVlcygpO1xuXG4gICAgdGhpcy56aXBwZXIuY2xlYXIoKTtcbiAgICB0aGlzLnppcHBlci5zZXRaaXBGaWxlbmFtZShgJHt2YWx1ZXMubmFtZX0uemlwYCk7XG5cbiAgICB0aGlzLmRlbnNpdGllcy5mb3JFYWNoKGRlbnNpdHkgPT4ge1xuICAgICAgbGV0IG11bHQgPSBzdHVkaW8uVXRpbC5nZXRNdWx0QmFzZU1kcGkoZGVuc2l0eSk7XG4gICAgICBsZXQgdG90YWxTaXplID0gdmFsdWVzLnNpemU7XG4gICAgICBsZXQgcGFkZGluZyA9IE1hdGgubWluKHZhbHVlcy5zaXplIC8gMiwgdmFsdWVzLnBhZGRpbmcpO1xuICAgICAgbGV0IGljb25TaXplID0gc3R1ZGlvLlV0aWwubXVsdFJvdW5kKFxuICAgICAgICAgIHt3OiB0b3RhbFNpemUsIGg6IHRvdGFsU2l6ZX0sIG11bHQpO1xuICAgICAgbGV0IHRhcmdldFJlY3QgPSBzdHVkaW8uVXRpbC5tdWx0Um91bmQoXG4gICAgICAgICAge3g6IHBhZGRpbmcsIHk6IHBhZGRpbmcsIHc6IHRvdGFsU2l6ZSAtIHBhZGRpbmcgKiAyLCBoOiB0b3RhbFNpemUgLSBwYWRkaW5nICogMn0sIG11bHQpO1xuXG4gICAgICBsZXQgb3V0Q3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KGljb25TaXplKTtcbiAgICAgIGxldCB0bXBDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuXG4gICAgICBpZiAodmFsdWVzLnNvdXJjZS5jdHgpIHtcbiAgICAgICAgbGV0IHNyY0N0eCA9IHZhbHVlcy5zb3VyY2UuY3R4O1xuICAgICAgICBpbWFnZWxpYi5EcmF3aW5nLmRyYXdDZW50ZXJJbnNpZGUoXG4gICAgICAgICAgICB0bXBDdHgsXG4gICAgICAgICAgICBzcmNDdHgsXG4gICAgICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHc6IHNyY0N0eC5jYW52YXMud2lkdGgsIGg6IHNyY0N0eC5jYW52YXMuaGVpZ2h0fSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBjb2xvciA9IHZhbHVlcy5jb2xvcjtcbiAgICAgIGxldCBhbHBoYSA9IGNvbG9yLmdldEFscGhhKCk7XG4gICAgICBjb2xvci5zZXRBbHBoYSgxKTtcblxuICAgICAgaW1hZ2VsaWIuRWZmZWN0cy5meChbXG4gICAgICAgIHtlZmZlY3Q6ICdmaWxsLWNvbG9yJywgY29sb3I6IGNvbG9yLnRvUmdiU3RyaW5nKCksIG9wYWNpdHk6IGFscGhhfVxuICAgICAgXSwgb3V0Q3R4LCB0bXBDdHgsIGljb25TaXplKTtcblxuICAgICAgdGhpcy56aXBwZXIuYWRkKHtcbiAgICAgICAgbmFtZTogYHJlcy9kcmF3YWJsZS0ke2RlbnNpdHl9LyR7dmFsdWVzLm5hbWV9LnBuZ2AsXG4gICAgICAgIGNhbnZhczogb3V0Q3R4LmNhbnZhc1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2V0SW1hZ2VGb3JTbG90XyhkZW5zaXR5LCBvdXRDdHguY2FudmFzLnRvRGF0YVVSTCgpKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TGF1bmNoZXJJY29uR2VuZXJhdG9yfSBmcm9tICcuL2xhdW5jaGVyaWNvbnMnO1xuaW1wb3J0IHtBcHBTaG9ydGN1dEljb25HZW5lcmF0b3J9IGZyb20gJy4vYXBwc2hvcnRjdXRpY29ucyc7XG5pbXBvcnQge0FjdGlvbkJhckljb25HZW5lcmF0b3J9IGZyb20gJy4vYWN0aW9uYmFyaWNvbnMnO1xuaW1wb3J0IHtOb3RpZmljYXRpb25JY29uR2VuZXJhdG9yfSBmcm9tICcuL25vdGlmaWNhdGlvbmljb25zJztcbmltcG9ydCB7R2VuZXJpY0ljb25HZW5lcmF0b3J9IGZyb20gJy4vZ2VuZXJpY2ljb25zJztcbmltcG9ydCB7TmluZVBhdGNoR2VuZXJhdG9yfSBmcm9tICcuL25pbmVwYXRjaC9uaW5lcGF0Y2hlcyc7XG5cbmV4cG9ydCBjb25zdCBwYWdlcyA9IHtcbiAgTGF1bmNoZXJJY29uR2VuZXJhdG9yLFxuICBBcHBTaG9ydGN1dEljb25HZW5lcmF0b3IsXG4gIEFjdGlvbkJhckljb25HZW5lcmF0b3IsXG4gIE5vdGlmaWNhdGlvbkljb25HZW5lcmF0b3IsXG4gIEdlbmVyaWNJY29uR2VuZXJhdG9yLFxuICBOaW5lUGF0Y2hHZW5lcmF0b3IsXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3R1ZGlvfSBmcm9tICcuLi9zdHVkaW8nO1xuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vaW1hZ2VsaWInO1xuaW1wb3J0IHtCYXNlR2VuZXJhdG9yfSBmcm9tICcuL2Jhc2VnZW5lcmF0b3InO1xuXG5jb25zdCBJQ09OX1NJWkUgPSB7IHc6IDQ4LCBoOiA0OCB9O1xuXG5jb25zdCBUQVJHRVRfUkVDVFNfQllfU0hBUEUgPSB7XG4gIG5vbmU6IHsgeDogIDMsIHk6ICAzLCB3OiAgNDIsIGg6ICA0MiB9LFxuICBjaXJjbGU6IHsgeDogIDIsIHk6ICAyLCB3OiAgNDQsIGg6ICA0NCB9LFxuICBzcXVhcmU6IHsgeDogIDUsIHk6ICA1LCB3OiAgMzgsIGg6ICAzOCB9LFxuICB2cmVjdDogeyB4OiAgOCwgeTogIDIsIHc6ICAzMiwgaDogIDQ0IH0sXG4gIGhyZWN0OiB7IHg6ICAyLCB5OiAgOCwgdzogIDQ0LCBoOiAgMzIgfSxcbn07XG5cbmNvbnN0IEdSSURfT1ZFUkxBWV9TVkcgPVxuICAgIGA8c3ZnIHdpZHRoPVwiNDhcIiBoZWlnaHQ9XCI0OFwiIHZpZXdCb3g9XCIwIDAgNDggNDhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiNDRcIiByeD1cIjNcIi8+XG4gICAgICAgICAgICA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIjVcIiB5PVwiNVwiIHdpZHRoPVwiMzhcIiBoZWlnaHQ9XCIzOFwiIHJ4PVwiM1wiLz5cbiAgICAgICAgICAgIDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiMlwiIHk9XCI4XCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjMyXCIgcng9XCIzXCIvPlxuICAgICAgICAgICAgPGNpcmNsZSB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgY3g9XCIyNFwiIGN5PVwiMjRcIiByPVwiMTBcIi8+XG4gICAgICAgICAgICA8Y2lyY2xlIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiBjeD1cIjI0XCIgY3k9XCIyNFwiIHI9XCIyMlwiLz5cbiAgICAgICAgICAgIDxwYXRoIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiBkPVwiTTAgNDhMNDggME0wIDBsNDggNDhNMjQgNDhWME0xNyAwdjQ4TTMxIDB2NDhNNDggMjRIME0wIDMxaDQ4TTAgMTdoNDhcIi8+XG4gICAgICAgIDwvZz5cbiAgICA8L3N2Zz5gO1xuXG5cbmV4cG9ydCBjbGFzcyBMYXVuY2hlckljb25HZW5lcmF0b3IgZXh0ZW5kcyBCYXNlR2VuZXJhdG9yIHtcbiAgZ2V0IGRlbnNpdGllcygpIHtcbiAgICByZXR1cm4gbmV3IFNldChbJ3h4eGhkcGknIC8qIG11c3QgYmUgZmlyc3QgKi8sICd3ZWInLCAneHhoZHBpJywgJ3hoZHBpJywgJ2hkcGknLCAnbWRwaSddKTtcbiAgfVxuXG4gIGdldCBncmlkT3ZlcmxheVN2ZygpIHtcbiAgICByZXR1cm4gR1JJRF9PVkVSTEFZX1NWRztcbiAgfVxuXG4gIHNldHVwRm9ybSgpIHtcbiAgICBsZXQgYmFja0NvbG9yRmllbGQsIGVmZmVjdHNGaWVsZDtcbiAgICB0aGlzLmZvcm0gPSBuZXcgc3R1ZGlvLkZvcm0oe1xuICAgICAgaWQ6ICdpY29uZm9ybScsXG4gICAgICBjb250YWluZXI6ICcjaW5wdXRzLWZvcm0nLFxuICAgICAgZmllbGRzOiBbXG4gICAgICAgIG5ldyBzdHVkaW8uSW1hZ2VGaWVsZCgnZm9yZWdyb3VuZCcsIHtcbiAgICAgICAgICB0aXRsZTogJ0ZvcmVncm91bmQnLFxuICAgICAgICAgIG1heEZpbmFsU2l6ZTogeyB3OiA3MjAsIGg6IDcyMCB9LCAvLyBtYXggcmVuZGVyIHNpemUsIGZvciBTVkdzXG4gICAgICAgICAgZGVmYXVsdFZhbHVlVHJpbTogMSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWVQYWRkaW5nOiAuMjUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlQ2xpcGFydDogJ2FuZHJvaWQnLFxuICAgICAgICAgIGRyb3BUYXJnZXQ6IGRvY3VtZW50LmJvZHlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBzdHVkaW8uQ29sb3JGaWVsZCgnZm9yZUNvbG9yJywge1xuICAgICAgICAgIG5ld0dyb3VwOiB0cnVlLFxuICAgICAgICAgIHRpdGxlOiAnQ29sb3InLFxuICAgICAgICAgIGhlbHBUZXh0OiAnU2V0IHRvIHRyYW5zcGFyZW50IHRvIHVzZSBvcmlnaW5hbCBjb2xvcnMnLFxuICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ3JnYmEoOTYsIDEyNSwgMTM5LCAwKSdcbiAgICAgICAgfSksXG4gICAgICAgIChiYWNrQ29sb3JGaWVsZCA9IG5ldyBzdHVkaW8uQ29sb3JGaWVsZCgnYmFja0NvbG9yJywge1xuICAgICAgICAgIHRpdGxlOiAnQmFja2dyb3VuZCBjb2xvcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnIzQ0OGFmZidcbiAgICAgICAgfSkpLFxuICAgICAgICBuZXcgc3R1ZGlvLkJvb2xlYW5GaWVsZCgnY3JvcCcsIHtcbiAgICAgICAgICB0aXRsZTogJ1NjYWxpbmcnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICAgICAgb2ZmVGV4dDogJ0NlbnRlcicsXG4gICAgICAgICAgb25UZXh0OiAnQ3JvcCdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBzdHVkaW8uRW51bUZpZWxkKCdiYWNrZ3JvdW5kU2hhcGUnLCB7XG4gICAgICAgICAgdGl0bGU6ICdTaGFwZScsXG4gICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgeyBpZDogJ25vbmUnLCB0aXRsZTogJ05vbmUnIH0sXG4gICAgICAgICAgICB7IGlkOiAnc3F1YXJlJywgdGl0bGU6ICdTcXVhcmUnIH0sXG4gICAgICAgICAgICB7IGlkOiAnY2lyY2xlJywgdGl0bGU6ICdDaXJjbGUnIH0sXG4gICAgICAgICAgICB7IGlkOiAndnJlY3QnLCB0aXRsZTogJ1RhbGwgcmVjdCcgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdocmVjdCcsIHRpdGxlOiAnV2lkZSByZWN0JyB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdzcXVhcmUnXG4gICAgICAgIH0pLFxuICAgICAgICAoZWZmZWN0c0ZpZWxkID0gbmV3IHN0dWRpby5FbnVtRmllbGQoJ2VmZmVjdHMnLCB7XG4gICAgICAgICAgdGl0bGU6ICdFZmZlY3QnLFxuICAgICAgICAgIGJ1dHRvbnM6IHRydWUsXG4gICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgeyBpZDogJ25vbmUnLCB0aXRsZTogJ05vbmUnIH0sXG4gICAgICAgICAgICB7IGlkOiAnZWxldmF0ZScsIHRpdGxlOiAnRWxldmF0ZScgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdzaGFkb3cnLCB0aXRsZTogJ0Nhc3Qgc2hhZG93JyB9LFxuICAgICAgICAgICAgeyBpZDogJ3Njb3JlJywgdGl0bGU6ICdTY29yZScgfSxcbiAgICAgICAgICAgIC8vIHsgaWQ6ICdkb2dlYXInLCB0aXRsZTogJ0ZvbGRlZCcgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnbm9uZSdcbiAgICAgICAgfSkpXG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5mb3JtLm9uQ2hhbmdlKGZpZWxkID0+IHtcbiAgICAgIGJhY2tDb2xvckZpZWxkLnNldEVuYWJsZWQodGhpcy5mb3JtLmdldFZhbHVlcygpLmJhY2tncm91bmRTaGFwZSAhPSAnbm9uZScpO1xuICAgICAgZWZmZWN0c0ZpZWxkLnNldEVuYWJsZWQodGhpcy5mb3JtLmdldFZhbHVlcygpLmJhY2tncm91bmRTaGFwZSAhPSAnbm9uZScpO1xuICAgICAgdGhpcy5yZWdlbmVyYXRlRGVib3VuY2VkXygpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVnZW5lcmF0ZSgpIHtcbiAgICBsZXQgaWNvbk5hbWUgPSAnaWNfbGF1bmNoZXInO1xuXG4gICAgdGhpcy56aXBwZXIuY2xlYXIoKTtcbiAgICB0aGlzLnppcHBlci5zZXRaaXBGaWxlbmFtZShpY29uTmFtZSArICcuemlwJyk7XG5cbiAgICBsZXQgeHh4aGRwaUN0eCA9IG51bGw7XG5cbiAgICB0aGlzLmRlbnNpdGllcy5mb3JFYWNoKGRlbnNpdHkgPT4ge1xuICAgICAgbGV0IGN0eDtcbiAgICAgIGlmIChkZW5zaXR5ID09ICd4eHhoZHBpJyB8fCBkZW5zaXR5ID09ICd3ZWInKSB7XG4gICAgICAgIGN0eCA9IHRoaXMucmVnZW5lcmF0ZVJhd0F0RGVuc2l0eV8oZGVuc2l0eSk7XG4gICAgICAgIGlmIChkZW5zaXR5ID09ICd4eHhoZHBpJykge1xuICAgICAgICAgIHh4eGhkcGlDdHggPSBjdHg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGp1c3Qgc2NhbGUgZG93biB4eHhoZHBpXG4gICAgICAgIGxldCBtdWx0ID0gc3R1ZGlvLlV0aWwuZ2V0TXVsdEJhc2VNZHBpKGRlbnNpdHkpO1xuICAgICAgICBsZXQgaWNvblNpemUgPSBzdHVkaW8uVXRpbC5tdWx0Um91bmQoSUNPTl9TSVpFLCBtdWx0KTtcbiAgICAgICAgY3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KGljb25TaXplKTtcbiAgICAgICAgaW1hZ2VsaWIuRHJhd2luZy5kcmF3SW1hZ2VTY2FsZWQoXG4gICAgICAgICAgICBjdHgsIHh4eGhkcGlDdHgsXG4gICAgICAgICAgICAwLCAwLCAxOTIsIDE5MixcbiAgICAgICAgICAgIDAsIDAsIGljb25TaXplLncsIGljb25TaXplLmgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnppcHBlci5hZGQoe1xuICAgICAgICBuYW1lOiAoZGVuc2l0eSA9PSAnd2ViJylcbiAgICAgICAgICAgID8gJ3dlYl9oaV9yZXNfNTEyLnBuZydcbiAgICAgICAgICAgIDogYHJlcy9taXBtYXAtJHtkZW5zaXR5fS8ke2ljb25OYW1lfS5wbmdgLFxuICAgICAgICBjYW52YXM6IGN0eC5jYW52YXNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldEltYWdlRm9yU2xvdF8oZGVuc2l0eSwgY3R4LmNhbnZhcy50b0RhdGFVUkwoKSk7XG4gICAgfSk7XG4gIH1cblxuICByZWdlbmVyYXRlUmF3QXREZW5zaXR5XyhkZW5zaXR5KSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcbiAgICBsZXQgZm9yZVNyY0N0eCA9IHZhbHVlcy5mb3JlZ3JvdW5kID8gdmFsdWVzLmZvcmVncm91bmQuY3R4IDogbnVsbDtcbiAgICBsZXQgbXVsdCA9IHN0dWRpby5VdGlsLmdldE11bHRCYXNlTWRwaShkZW5zaXR5KTtcbiAgICBpZiAoZGVuc2l0eSA9PSAnd2ViJykge1xuICAgICAgbXVsdCA9IDUxMiAvIDQ4O1xuICAgIH1cblxuICAgIGxldCBpY29uU2l6ZSA9IHN0dWRpby5VdGlsLm11bHRSb3VuZChJQ09OX1NJWkUsIG11bHQpO1xuICAgIGxldCB0YXJnZXRSZWN0ID0gVEFSR0VUX1JFQ1RTX0JZX1NIQVBFW3ZhbHVlcy5iYWNrZ3JvdW5kU2hhcGVdO1xuXG4gICAgbGV0IG91dEN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChpY29uU2l6ZSk7XG5cbiAgICBsZXQgcm91bmRSZWN0UGF0aF8gPSAoY3R4LCB7eCwgeSwgdywgaH0sIHIpID0+IHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHcgLSByLCB5KTtcbiAgICAgIGN0eC5hcmNUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByLCByKTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgICBjdHguYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCByKTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICAgIGN0eC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSByLCByKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIHIpO1xuICAgICAgY3R4LmFyY1RvKHgsIHksIHggKyByLCB5LCByKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgbGV0IGJhY2tncm91bmRMYXllciA9IHtcbiAgICAgIC8vIGJhY2tncm91bmQgbGF5ZXJcbiAgICAgIGRyYXc6IGN0eCA9PiB7XG4gICAgICAgIGN0eC5zY2FsZShtdWx0LCBtdWx0KTtcbiAgICAgICAgdmFsdWVzLmJhY2tDb2xvci5zZXRBbHBoYSgxKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlcy5iYWNrQ29sb3IudG9SZ2JTdHJpbmcoKTtcblxuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IFRBUkdFVF9SRUNUU19CWV9TSEFQRVt2YWx1ZXMuYmFja2dyb3VuZFNoYXBlXTtcbiAgICAgICAgc3dpdGNoICh2YWx1ZXMuYmFja2dyb3VuZFNoYXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICBjYXNlICd2cmVjdCc6XG4gICAgICAgICAgY2FzZSAnaHJlY3QnOlxuICAgICAgICAgICAgcm91bmRSZWN0UGF0aF8oY3R4LCB0YXJnZXRSZWN0LCAzKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgIHRhcmdldFJlY3QueCArIHRhcmdldFJlY3QudyAvIDIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVjdC55ICsgdGFyZ2V0UmVjdC5oIC8gMixcbiAgICAgICAgICAgICAgICB0YXJnZXRSZWN0LncgLyAyLFxuICAgICAgICAgICAgICAgIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXNrOiB0cnVlXG4gICAgfTtcblxuICAgIGxldCBmb3JlZ3JvdW5kTGF5ZXIgPSB7XG4gICAgICAvLyBmb3JlZ3JvdW5kIGNvbnRlbnQgbGF5ZXJcbiAgICAgIGRyYXc6IGN0eCA9PiB7XG4gICAgICAgIGlmICghZm9yZVNyY0N0eCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkcmF3Rm5fID0gaW1hZ2VsaWIuRHJhd2luZ1t2YWx1ZXMuY3JvcCA/ICdkcmF3Q2VudGVyQ3JvcCcgOiAnZHJhd0NlbnRlckluc2lkZSddO1xuICAgICAgICBkcmF3Rm5fKGN0eCwgZm9yZVNyY0N0eCwgc3R1ZGlvLlV0aWwubXVsdCh0YXJnZXRSZWN0LCBtdWx0KSxcbiAgICAgICAgICAgIHt4OiAwLCB5OiAwLCB3OiBmb3JlU3JjQ3R4LmNhbnZhcy53aWR0aCwgaDogZm9yZVNyY0N0eC5jYW52YXMuaGVpZ2h0fSk7XG4gICAgICB9LFxuICAgICAgZWZmZWN0czogW11cbiAgICB9O1xuXG4gICAgaWYgKHZhbHVlcy5iYWNrZ3JvdW5kU2hhcGUgIT0gJ25vbmUnICYmdmFsdWVzLmVmZmVjdHMgPT0gJ3NoYWRvdycpIHtcbiAgICAgIGZvcmVncm91bmRMYXllci5lZmZlY3RzLnB1c2goe2VmZmVjdDogJ2Nhc3Qtc2hhZG93J30pO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMuZm9yZUNvbG9yLmdldEFscGhhKCkpIHtcbiAgICAgIGZvcmVncm91bmRMYXllci5lZmZlY3RzLnB1c2goe1xuICAgICAgICBlZmZlY3Q6ICdmaWxsLWNvbG9yJyxcbiAgICAgICAgY29sb3I6IHZhbHVlcy5mb3JlQ29sb3IudG9SZ2JTdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5iYWNrZ3JvdW5kU2hhcGUgIT0gJ25vbmUnICYmXG4gICAgICAgICh2YWx1ZXMuZWZmZWN0cyA9PSAnZWxldmF0ZScgfHwgdmFsdWVzLmVmZmVjdHMgPT0gJ3NoYWRvdycpKSB7XG4gICAgICBmb3JlZ3JvdW5kTGF5ZXIuZWZmZWN0cyA9IGZvcmVncm91bmRMYXllci5lZmZlY3RzLmNvbmNhdChbXG4gICAgICAgIHtcbiAgICAgICAgICBlZmZlY3Q6ICdvdXRlci1zaGFkb3cnLFxuICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjIpJyxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAuMjUgKiBtdWx0XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBlZmZlY3Q6ICdvdXRlci1zaGFkb3cnLFxuICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjIpJyxcbiAgICAgICAgICBibHVyOiAxICogbXVsdCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAxICogbXVsdFxuICAgICAgICB9XG4gICAgICBdKTtcbiAgICB9XG5cbiAgICBsZXQgc2NvcmVMYXllciA9IHtcbiAgICAgIGRyYXc6IGN0eCA9PiB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLCAwLCAwLCAuMSknO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgaWNvblNpemUudywgaWNvblNpemUuaCAvIDIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbWFnZWxpYi5EcmF3aW5nLmRyYXdMYXllcnMob3V0Q3R4LCBpY29uU2l6ZSwge1xuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgdmFsdWVzLmJhY2tncm91bmRTaGFwZSAhPSAnbm9uZScgPyBiYWNrZ3JvdW5kTGF5ZXIgOiBudWxsLFxuICAgICAgICBmb3JlZ3JvdW5kTGF5ZXIsXG4gICAgICAgICh2YWx1ZXMuYmFja2dyb3VuZFNoYXBlICE9ICdub25lJyAmJiB2YWx1ZXMuZWZmZWN0cyA9PSAnc2NvcmUnKSA/IHNjb3JlTGF5ZXIgOiBudWxsLFxuICAgICAgXSxcbiAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGVmZmVjdDogJ2lubmVyLXNoYWRvdycsXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiknLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IC4yNSAqIG11bHRcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGVmZmVjdDogJ2lubmVyLXNoYWRvdycsXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IC0uMjUgKiBtdWx0XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBlZmZlY3Q6ICdmaWxsLXJhZGlhbGdyYWRpZW50JyxcbiAgICAgICAgICBjZW50ZXJYOiAwLFxuICAgICAgICAgIGNlbnRlclk6IDAsXG4gICAgICAgICAgcmFkaXVzOiBpY29uU2l6ZS53LFxuICAgICAgICAgIGNvbG9yczogW1xuICAgICAgICAgICAgeyBvZmZzZXQ6IDAsIGNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwuMSknIH0sXG4gICAgICAgICAgICB7IG9mZnNldDogMS4wLCBjb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMCknIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBlZmZlY3Q6ICdvdXRlci1zaGFkb3cnLFxuICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjMpJyxcbiAgICAgICAgICBibHVyOiAuNyAqIG11bHQsXG4gICAgICAgICAgdHJhbnNsYXRlWTogLjcgKiBtdWx0XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRDdHg7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge3N0dWRpb30gZnJvbSAnLi4vLi4vc3R1ZGlvJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uLy4uL2ltYWdlbGliJztcbmltcG9ydCB7QmFzZUdlbmVyYXRvcn0gZnJvbSAnLi4vYmFzZWdlbmVyYXRvcic7XG5cbmltcG9ydCB7TmluZVBhdGNoU3RhZ2V9IGZyb20gJy4vbmluZXBhdGNoc3RhZ2UnO1xuaW1wb3J0IHtOaW5lUGF0Y2hQcmV2aWV3fSBmcm9tICcuL25pbmVwYXRjaHByZXZpZXcnO1xuaW1wb3J0IHtOaW5lUGF0Y2hMb2FkZXJ9IGZyb20gJy4vbmluZXBhdGNobG9hZGVyJztcblxuXG5jb25zdCBERU5TSVRJRVMgPSBuZXcgU2V0KFsneHh4aGRwaScsICd4eGhkcGknLCAneGhkcGknLCAnaGRwaScsICdtZHBpJ10pO1xuY29uc3QgU09VUkNFX0RFTlNJVFlfT1BUSU9OUyA9IFtcbiAgeyBpZDogJzE2MCcsIHRpdGxlOiAgICdtZHBpPGJyPjxzbWFsbD4oMTYwKTwvc21hbGw+JyB9LFxuICB7IGlkOiAnMjQwJywgdGl0bGU6ICAgJ2hkcGk8YnI+PHNtYWxsPigyNDApPC9zbWFsbD4nIH0sXG4gIHsgaWQ6ICczMjAnLCB0aXRsZTogICd4aGRwaTxicj48c21hbGw+KDMyMCk8L3NtYWxsPicgfSxcbiAgeyBpZDogJzQ4MCcsIHRpdGxlOiAneHhoZHBpPGJyPjxzbWFsbD4oNDgwKTwvc21hbGw+JyB9LFxuICB7IGlkOiAnNjQwJywgdGl0bGU6ICd4eHhoZHBpPGJyPjxzbWFsbD4oNjQwKTwvc21hbGw+JyB9XG5dO1xuXG5cbmlmIChkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guaW5kZXhPZignZXh0cmFkZW5zaXRpZXMnKSA+PSAwKSB7XG4gIERFTlNJVElFUy5hZGQoJ2xkcGknKTtcbiAgREVOU0lUSUVTLmFkZCgndHZkcGknKTtcbiAgLy8gU09VUkNFX0RFTlNJVFlfT1BUSU9OUy5wdXNoKHsgaWQ6ICcxMjAnLCB0aXRsZTogICAnbGRwaTxicj48c21hbGw+KDEyMCk8L3NtYWxsPicgfSk7XG4gIC8vIFNPVVJDRV9ERU5TSVRZX09QVElPTlMucHVzaCh7IGlkOiAnMjEzJywgdGl0bGU6ICAndHZkcGk8YnI+PHNtYWxsPigyMTMpPC9zbWFsbD4nIH0pO1xufVxuXG5cbmV4cG9ydCBjbGFzcyBOaW5lUGF0Y2hHZW5lcmF0b3IgZXh0ZW5kcyBCYXNlR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YWdlID0gbmV3IE5pbmVQYXRjaFN0YWdlKCk7XG4gICAgdGhpcy5wcmV2aWV3ID0gbmV3IE5pbmVQYXRjaFByZXZpZXcodGhpcy5zdGFnZSk7XG5cbiAgICB0aGlzLnN0YWdlLm9uQ2hhbmdlKCgpID0+IHtcbiAgICAgIHRoaXMucmVnZW5lcmF0ZSgpO1xuICAgICAgdGhpcy5wcmV2aWV3LnJlZHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXR1cE91dHB1dHNQcmV2aWV3VGFicygpO1xuICB9XG5cbiAgc2V0dXBPdXRwdXRzUHJldmlld1RhYnMoKSB7XG4gICAgJCgnLm91dHB1dHMtcHJldmlldy10YWJzIGlucHV0Jykub24oJ2NoYW5nZScsIGV2ID0+IHtcbiAgICAgICQoJy5vdXRwdXRzLXByZXZpZXctc2lkZWJhcicpLmF0dHIoJ2RhdGEtdmlldycsICQoZXYuY3VycmVudFRhcmdldCkudmFsKCkpO1xuICAgICAgJCgnLm91dHB1dHMtcHJldmlldy10YWJzIGlucHV0JykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICQoZXYuY3VycmVudFRhcmdldCkucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGRlbnNpdGllcygpIHtcbiAgICByZXR1cm4gREVOU0lUSUVTO1xuICB9XG5cbiAgc2V0dXBGb3JtKCkge1xuICAgIHN1cGVyLnNldHVwRm9ybSgpO1xuICAgIGxldCBuYW1lRmllbGQ7XG4gICAgdGhpcy5mb3JtID0gbmV3IHN0dWRpby5Gb3JtKHtcbiAgICAgIGlkOiAnbmluZXBhdGNoZm9ybScsXG4gICAgICBjb250YWluZXI6ICcjaW5wdXRzLWZvcm0nLFxuICAgICAgZmllbGRzOiBbXG4gICAgICAgIG5ldyBzdHVkaW8uSW1hZ2VGaWVsZCgnc291cmNlJywge1xuICAgICAgICAgIHRpdGxlOiAnU291cmNlIGdyYXBoaWMnLFxuICAgICAgICAgIGltYWdlT25seTogdHJ1ZSxcbiAgICAgICAgICBub1RyaW1Gb3JtOiB0cnVlLFxuICAgICAgICAgIG5vUHJldmlldzogdHJ1ZSxcbiAgICAgICAgICBkcm9wVGFyZ2V0OiBkb2N1bWVudC5ib2R5XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgc3R1ZGlvLkVudW1GaWVsZCgnc291cmNlRGVuc2l0eScsIHtcbiAgICAgICAgICB0aXRsZTogJ1NvdXJjZSBkZW5zaXR5JyxcbiAgICAgICAgICBidXR0b25zOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbnM6IFNPVVJDRV9ERU5TSVRZX09QVElPTlMsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnMzIwJ1xuICAgICAgICB9KSxcbiAgICAgICAgKG5hbWVGaWVsZCA9IG5ldyBzdHVkaW8uVGV4dEZpZWxkKCduYW1lJywge1xuICAgICAgICAgIHRpdGxlOiAnRHJhd2FibGUgbmFtZScsXG4gICAgICAgICAgaGVscFRleHQ6ICdVc2VkIHdoZW4gZ2VuZXJhdGluZyBaSVAgZmlsZXMuIEJlY29tZXMgPGNvZGU+Jmx0O25hbWUmZ3Q7LjkucG5nPC9jb2RlPi4nLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ2V4YW1wbGUnXG4gICAgICAgIH0pKVxuICAgICAgXVxuICAgIH0pO1xuICAgIHRoaXMuZm9ybS5vbkNoYW5nZShmaWVsZCA9PiB7XG4gICAgICBsZXQgdmFsdWVzID0gdGhpcy5mb3JtLmdldFZhbHVlcygpO1xuICAgICAgaWYgKCFmaWVsZCB8fCBmaWVsZC5pZF8gPT0gJ3NvdXJjZScpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5zb3VyY2UpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlcy5zb3VyY2UuY3R4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBzcmMgPSB2YWx1ZXMuc291cmNlO1xuICAgICAgICAgIGxldCBzaXplID0geyB3OiBzcmMuY3R4LmNhbnZhcy53aWR0aCwgaDogc3JjLmN0eC5jYW52YXMuaGVpZ2h0IH07XG4gICAgICAgICAgdGhpcy5zdGFnZS5uYW1lID0gYCR7c3JjLm5hbWV9LSR7c2l6ZS53fXgke3NpemUuaH1gO1xuICAgICAgICAgIC8vIGxldCBpc1N2ZyA9ICEhc3JjLm5hbWUubWF0Y2goL1xcLnN2ZyQvaSk7XG4gICAgICAgICAgaWYgKHNyYy5uYW1lICYmIHNyYy5uYW1lLm1hdGNoKC9cXC45XFwucG5nJC9pKSkge1xuICAgICAgICAgICAgTmluZVBhdGNoTG9hZGVyLmxvYWROaW5lUGF0Y2hJbnRvU3RhZ2Uoc3JjLmN0eCwgdGhpcy5zdGFnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UubG9hZFNvdXJjZUltYWdlKHNyYy5jdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjLm5hbWUpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gc3R1ZGlvLlV0aWwuc2FuaXRpemVSZXNvdXJjZU5hbWUoc3JjLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbmFtZUZpZWxkLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgbmFtZUZpZWxkLnNldFZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YWdlLmxvYWRTb3VyY2VJbWFnZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWdlbmVyYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZWdlbmVyYXRlKCkge1xuICAgIC8vIHRoaXMucHJldmlldy51cGRhdGUoKTtcblxuICAgIGlmICghdGhpcy5zdGFnZS5zcmNDdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWVzID0gdGhpcy5mb3JtLmdldFZhbHVlcygpO1xuXG4gICAgdGhpcy56aXBwZXIuY2xlYXIoKTtcbiAgICB0aGlzLnppcHBlci5zZXRaaXBGaWxlbmFtZShgJHt2YWx1ZXMubmFtZX0uOS56aXBgKTtcblxuICAgIHRoaXMuZGVuc2l0aWVzLmZvckVhY2goZGVuc2l0eSA9PiB7XG4gICAgICBsZXQgZHBpID0gc3R1ZGlvLlV0aWwuZ2V0RHBpRm9yRGVuc2l0eShkZW5zaXR5KTtcblxuICAgICAgLy8gc2NhbGUgc291cmNlIGdyYXBoaWNcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgYmV0dGVyLXNtb290aGluZyBvcHRpb25cbiAgICAgIGxldCBzY2FsZSA9IGRwaSAvIHZhbHVlcy5zb3VyY2VEZW5zaXR5O1xuICAgICAgbGV0IG91dFNpemUgPSB7XG4gICAgICAgIHc6IE1hdGguY2VpbCh0aGlzLnN0YWdlLnNyY1NpemUudyAqIHNjYWxlKSArIDIsXG4gICAgICAgIGg6IE1hdGguY2VpbCh0aGlzLnN0YWdlLnNyY1NpemUuaCAqIHNjYWxlKSArIDJcbiAgICAgIH07XG4gICAgICBsZXQgb3V0Q3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KG91dFNpemUpO1xuICAgICAgaW1hZ2VsaWIuRHJhd2luZy5kcmF3SW1hZ2VTY2FsZWQob3V0Q3R4LCB0aGlzLnN0YWdlLnNyY0N0eCxcbiAgICAgICAgICAwLCAwLCB0aGlzLnN0YWdlLnNyY1NpemUudywgdGhpcy5zdGFnZS5zcmNTaXplLmgsXG4gICAgICAgICAgMSwgMSwgb3V0U2l6ZS53IC0gMiwgb3V0U2l6ZS5oIC0gMik7XG5cbiAgICAgIC8vIGRyYXcgQW5kcm9pZCA0LjMgb3B0aWNhbCBib3VuZHNcbiAgICAgIG91dEN0eC5zdHJva2VTdHlsZSA9ICcjZjAwJztcbiAgICAgIG91dEN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgb3V0Q3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBvdXRDdHgubW92ZVRvKDEsIG91dFNpemUuaCAtIDAuNSk7XG4gICAgICBvdXRDdHgubGluZVRvKDEgKyBNYXRoLmZsb29yKHNjYWxlICogdGhpcy5zdGFnZS5vcHRpY2FsQm91bmRzUmVjdC54KSwgb3V0U2l6ZS5oIC0gMC41KTtcbiAgICAgIG91dEN0eC5zdHJva2UoKTtcblxuICAgICAgb3V0Q3R4Lm1vdmVUbyhNYXRoLmNlaWwoc2NhbGUgKiAodGhpcy5zdGFnZS5vcHRpY2FsQm91bmRzUmVjdC54ICsgdGhpcy5zdGFnZS5vcHRpY2FsQm91bmRzUmVjdC53KSkgKyAxLCBvdXRTaXplLmggLSAwLjUpO1xuICAgICAgb3V0Q3R4LmxpbmVUbyhvdXRTaXplLncgLSAxLCBvdXRTaXplLmggLSAwLjUpO1xuICAgICAgb3V0Q3R4LnN0cm9rZSgpO1xuXG4gICAgICBvdXRDdHgubW92ZVRvKG91dFNpemUudyAtIDAuNSwgMSk7XG4gICAgICBvdXRDdHgubGluZVRvKG91dFNpemUudyAtIDAuNSwgMSArIE1hdGguZmxvb3Ioc2NhbGUgKiB0aGlzLnN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LnkpKTtcbiAgICAgIG91dEN0eC5zdHJva2UoKTtcblxuICAgICAgb3V0Q3R4Lm1vdmVUbyhvdXRTaXplLncgLSAwLjUsIE1hdGguY2VpbChzY2FsZSAqICh0aGlzLnN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LnkgKyB0aGlzLnN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LmgpKSArIDEpO1xuICAgICAgb3V0Q3R4LmxpbmVUbyhvdXRTaXplLncgLSAwLjUsIG91dFNpemUuaCAtIDEpO1xuICAgICAgb3V0Q3R4LnN0cm9rZSgpO1xuXG4gICAgICBvdXRDdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIC8vIGRyYXcgbmluZS1wYXRjaCB0aWNrIG1hcmtzXG4gICAgICBvdXRDdHguc3Ryb2tlU3R5bGUgPSAnIzAwMCc7XG4gICAgICBvdXRDdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIG91dEN0eC5tb3ZlVG8oMSArIE1hdGguZmxvb3Ioc2NhbGUgKiB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LngpLCAwLjUpO1xuICAgICAgb3V0Q3R4LmxpbmVUbygxICsgTWF0aC5jZWlsKHNjYWxlICogKHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QueCArIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QudykpLCAwLjUpO1xuICAgICAgb3V0Q3R4LnN0cm9rZSgpO1xuXG4gICAgICBvdXRDdHgubW92ZVRvKDAuNSwgMSArIE1hdGguZmxvb3Ioc2NhbGUgKiB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LnkpKTtcbiAgICAgIG91dEN0eC5saW5lVG8oMC41LCAxICsgTWF0aC5jZWlsKHNjYWxlICogKHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QueSArIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QuaCkpKTtcbiAgICAgIG91dEN0eC5zdHJva2UoKTtcblxuICAgICAgb3V0Q3R4Lm1vdmVUbygxICsgTWF0aC5mbG9vcihzY2FsZSAqIHRoaXMuc3RhZ2UuY29udGVudFJlY3QueCksIG91dFNpemUuaCAtIDAuNSk7XG4gICAgICBvdXRDdHgubGluZVRvKDEgKyBNYXRoLmNlaWwoc2NhbGUgKiAodGhpcy5zdGFnZS5jb250ZW50UmVjdC54ICsgdGhpcy5zdGFnZS5jb250ZW50UmVjdC53KSksIG91dFNpemUuaCAtIDAuNSk7XG4gICAgICBvdXRDdHguc3Ryb2tlKCk7XG5cbiAgICAgIG91dEN0eC5tb3ZlVG8ob3V0U2l6ZS53IC0gMC41LCAxICsgTWF0aC5mbG9vcihzY2FsZSAqIHRoaXMuc3RhZ2UuY29udGVudFJlY3QueSkpO1xuICAgICAgb3V0Q3R4LmxpbmVUbyhvdXRTaXplLncgLSAwLjUsIDEgKyBNYXRoLmNlaWwoc2NhbGUgKiAodGhpcy5zdGFnZS5jb250ZW50UmVjdC55ICsgdGhpcy5zdGFnZS5jb250ZW50UmVjdC5oKSkpO1xuICAgICAgb3V0Q3R4LnN0cm9rZSgpO1xuXG4gICAgICBvdXRDdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIC8vIGFkZCB0byB6aXAgYW5kIHNob3cgcHJldmlld1xuXG4gICAgICB0aGlzLnppcHBlci5hZGQoe1xuICAgICAgICBuYW1lOiBgcmVzL2RyYXdhYmxlLSR7ZGVuc2l0eX0vJHt2YWx1ZXMubmFtZX0uOS5wbmdgLFxuICAgICAgICBjYW52YXM6IG91dEN0eC5jYW52YXNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldEltYWdlRm9yU2xvdF8oZGVuc2l0eSwgb3V0Q3R4LmNhbnZhcy50b0RhdGFVUkwoKSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2ltYWdlbGlifSBmcm9tICcuLi8uLi9pbWFnZWxpYic7XG5cbmNvbnN0IG51bWJlckZvclJHQkEgPSAocixnLGIsYSkgPT4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyAoYiA8PCAwKSArIChhIDw8IDI0KTtcbmNvbnN0IEJMQUNLID0gbnVtYmVyRm9yUkdCQSgwLDAsMCwyNTUpO1xuY29uc3QgUkVEID0gbnVtYmVyRm9yUkdCQSgyNTUsMCwwLDI1NSk7XG5cbmV4cG9ydCBjb25zdCBOaW5lUGF0Y2hMb2FkZXIgPSB7XG4gIGxvYWROaW5lUGF0Y2hJbnRvU3RhZ2UoY3R4LCBzdGFnZSkge1xuICAgIGxldCBzcmNTaXplID0geyB3OiBjdHguY2FudmFzLndpZHRoLCBoOiBjdHguY2FudmFzLmhlaWdodCB9O1xuICAgIGxldCBpbWdEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzcmNTaXplLncsIHNyY1NpemUuaCk7XG4gICAgbGV0IHNpemUgPSB7IHc6IHNyY1NpemUudyAtIDIsIGg6IHNyY1NpemUuaCAtIDIgfTtcbiAgICBsZXQgcmVjdHMgPSB7XG4gICAgICBjb250ZW50UmVjdDogeyB4OiAwLCB5OiAwLCB3OiBzaXplLncsIGg6IHNpemUuaCB9LFxuICAgICAgc3RyZXRjaFJlY3Q6IHsgeDogMCwgeTogMCwgdzogc2l6ZS53LCBoOiBzaXplLmggfSxcbiAgICAgIG9wdGljYWxCb3VuZHNSZWN0OiB7IHg6IDAsIHk6IDAsIHc6IHNpemUudywgaDogc2l6ZS5oIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2dldFBpeGVsKHgsIHkpIHtcbiAgICAgIHJldHVybiAoaW1nRGF0YS5kYXRhWyh5ICogc3JjU2l6ZS53ICsgeCkgKiA0ICsgMF0gPDwgMTYpIC8vIHJcbiAgICAgICAgICArIChpbWdEYXRhLmRhdGFbKHkgKiBzcmNTaXplLncgKyB4KSAqIDQgKyAxXSA8PCA4KSAvLyBnXG4gICAgICAgICAgKyAoaW1nRGF0YS5kYXRhWyh5ICogc3JjU2l6ZS53ICsgeCkgKiA0ICsgMl0gPDwgMCkgLy8gYlxuICAgICAgICAgICsgKGltZ0RhdGEuZGF0YVsoeSAqIHNyY1NpemUudyArIHgpICogNCArIDNdIDw8IDI0KTsgLy8gYVxuICAgIH1cblxuICAgIGxldCBpblJlZ2lvbjtcblxuICAgIC8vIFJlYWQgc3RyZXRjaCByZWN0XG4gICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemUudzsgeCsrKSB7XG4gICAgICBsZXQgcCA9IF9nZXRQaXhlbCh4ICsgMSwgMCk7XG4gICAgICBpZiAoIWluUmVnaW9uICYmIHAgPT0gQkxBQ0spIHtcbiAgICAgICAgcmVjdHMuc3RyZXRjaFJlY3QueCA9IHg7XG4gICAgICAgIGluUmVnaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5SZWdpb24gJiYgcCAhPSBCTEFDSykge1xuICAgICAgICByZWN0cy5zdHJldGNoUmVjdC53ID0geCAtIHJlY3RzLnN0cmV0Y2hSZWN0Lng7XG4gICAgICAgIGluUmVnaW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemUuaDsgeSsrKSB7XG4gICAgICBsZXQgcCA9IF9nZXRQaXhlbCgwLCB5ICsgMSk7XG4gICAgICBpZiAoIWluUmVnaW9uICYmIHAgPT0gQkxBQ0spIHtcbiAgICAgICAgcmVjdHMuc3RyZXRjaFJlY3QueSA9IHk7XG4gICAgICAgIGluUmVnaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5SZWdpb24gJiYgcCAhPSBCTEFDSykge1xuICAgICAgICByZWN0cy5zdHJldGNoUmVjdC5oID0geSAtIHJlY3RzLnN0cmV0Y2hSZWN0Lnk7XG4gICAgICAgIGluUmVnaW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVhZCBjb250ZW50IHJlY3RcbiAgICBpblJlZ2lvbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZS53OyB4KyspIHtcbiAgICAgIGxldCBwID0gX2dldFBpeGVsKHggKyAxLCBzcmNTaXplLmggLSAxKTtcbiAgICAgIGlmICghaW5SZWdpb24gJiYgcCA9PSBCTEFDSykge1xuICAgICAgICByZWN0cy5jb250ZW50UmVjdC54ID0geDtcbiAgICAgICAgaW5SZWdpb24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpblJlZ2lvbiAmJiBwICE9IEJMQUNLKSB7XG4gICAgICAgIHJlY3RzLmNvbnRlbnRSZWN0LncgPSB4IC0gcmVjdHMuY29udGVudFJlY3QueDtcbiAgICAgICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpblJlZ2lvbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZS5oOyB5KyspIHtcbiAgICAgIGxldCBwID0gX2dldFBpeGVsKHNyY1NpemUudyAtIDEsIHkgKyAxKTtcbiAgICAgIGlmICghaW5SZWdpb24gJiYgcCA9PSBCTEFDSykge1xuICAgICAgICByZWN0cy5jb250ZW50UmVjdC55ID0geTtcbiAgICAgICAgaW5SZWdpb24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpblJlZ2lvbiAmJiBwICE9IEJMQUNLKSB7XG4gICAgICAgIHJlY3RzLmNvbnRlbnRSZWN0LmggPSB5IC0gcmVjdHMuY29udGVudFJlY3QueTtcbiAgICAgICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWFkIG9wdGljYWwgYm91bmRzIHJlY3RcbiAgICBpblJlZ2lvbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZS53OyB4KyspIHtcbiAgICAgIGxldCBwID0gX2dldFBpeGVsKHggKyAxLCBzcmNTaXplLmggLSAxKTtcbiAgICAgIGlmICghaW5SZWdpb24gJiYgcCAhPSBSRUQpIHtcbiAgICAgICAgcmVjdHMub3B0aWNhbEJvdW5kc1JlY3QueCA9IHg7XG4gICAgICAgIGluUmVnaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5SZWdpb24gJiYgcCA9PSBSRUQpIHtcbiAgICAgICAgcmVjdHMub3B0aWNhbEJvdW5kc1JlY3QudyA9IHggLSByZWN0cy5vcHRpY2FsQm91bmRzUmVjdC54O1xuICAgICAgICBpblJlZ2lvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemUuaDsgeSsrKSB7XG4gICAgICBsZXQgcCA9IF9nZXRQaXhlbChzcmNTaXplLncgLSAxLCB5ICsgMSk7XG4gICAgICBpZiAoIWluUmVnaW9uICYmIHAgIT0gUkVEKSB7XG4gICAgICAgIHJlY3RzLm9wdGljYWxCb3VuZHNSZWN0LnkgPSB5O1xuICAgICAgICBpblJlZ2lvbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGluUmVnaW9uICYmIHAgPT0gUkVEKSB7XG4gICAgICAgIHJlY3RzLm9wdGljYWxCb3VuZHNSZWN0LmggPSB5IC0gcmVjdHMub3B0aWNhbEJvdW5kc1JlY3QueTtcbiAgICAgICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbnNldCB0aGUgY29udGV4dFxuICAgIGxldCBuZXdDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG4gICAgbmV3Q3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAxLCAxLCBzaXplLncsIHNpemUuaCwgMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuICAgIHN0YWdlLmxvYWRTb3VyY2VJbWFnZShuZXdDdHgsIHJlY3RzKTtcbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgTmluZVBhdGNoUHJldmlldyB7XG4gIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgIHRoaXMuc2l6ZSA9IHt3OiAyMDAsIGg6IDIwMH07XG4gICAgdGhpcy5zZXR1cFVpKCk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxuXG4gIHNldHVwVWkoKSB7XG4gICAgbGV0IHN0YXJ0V2lkdGgsIHN0YXJ0SGVpZ2h0LCBzdGFydFgsIHN0YXJ0WTtcblxuICAgIGxldCBtb3VzZU1vdmVIYW5kbGVyXyA9IGV2ID0+IHtcbiAgICAgIHRoaXMuc2l6ZS53ID0gTWF0aC5tYXgoMSwgc3RhcnRXaWR0aCArIChldi5wYWdlWCAtIHN0YXJ0WCkgKiAyKTtcbiAgICAgIHRoaXMuc2l6ZS5oID0gTWF0aC5tYXgoMSwgc3RhcnRIZWlnaHQgKyAoZXYucGFnZVkgLSBzdGFydFkpICogMik7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH07XG5cbiAgICBsZXQgbW91c2VVcEhhbmRsZXJfID0gZXYgPT4ge1xuICAgICAgJCh3aW5kb3cpXG4gICAgICAgICAgLm9mZignbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcl8pXG4gICAgICAgICAgLm9mZignbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyXyk7XG4gICAgfTtcblxuICAgICQoJy5wcmV2aWV3LWFyZWEnKVxuICAgICAgICAub24oJ21vdXNlZG93bicsIGV2ID0+IHtcbiAgICAgICAgICBzdGFydFdpZHRoID0gdGhpcy5zaXplLnc7XG4gICAgICAgICAgc3RhcnRIZWlnaHQgPSB0aGlzLnNpemUuaDtcbiAgICAgICAgICBzdGFydFggPSBldi5wYWdlWDtcbiAgICAgICAgICBzdGFydFkgPSBldi5wYWdlWTtcblxuICAgICAgICAgICQod2luZG93KVxuICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXJfKVxuICAgICAgICAgICAgICAub24oJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcl8pO1xuICAgICAgICB9KTtcblxuICAgICQoJyNwcmV2aWV3LXdpdGgtY29udGVudCcpLmNsaWNrKGV2ID0+ICQoJy50ZXh0LXByZXZpZXcnKS50b2dnbGUoJChldi5jdXJyZW50VGFyZ2V0KS5pcygnOmNoZWNrZWQnKSkpO1xuICB9XG5cbiAgcmVkcmF3KCkge1xuICAgIGxldCBjYW52YXMgPSAkKCcucHJldmlldy1hcmVhIGNhbnZhcycpLmdldCgwKTtcbiAgICBjYW52YXMud2lkdGggPSB0aGlzLnNpemUudztcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLmg7XG5cbiAgICBpZiAodGhpcy5zdGFnZS5zcmNDdHgpIHtcbiAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgbGV0IGZpeGVkID0ge1xuICAgICAgICBsOiB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LngsXG4gICAgICAgIHQ6IHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QueSxcbiAgICAgICAgcjogdGhpcy5zdGFnZS5zcmNTaXplLncgLSB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LnggLSB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LncsXG4gICAgICAgIGI6IHRoaXMuc3RhZ2Uuc3JjU2l6ZS5oIC0gdGhpcy5zdGFnZS5zdHJldGNoUmVjdC55IC0gdGhpcy5zdGFnZS5zdHJldGNoUmVjdC5oXG4gICAgICB9O1xuXG4gICAgICAvLyBUTFxuICAgICAgaWYgKGZpeGVkLmwgJiYgZml4ZWQudClcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICAwLCAwLCBmaXhlZC5sLCBmaXhlZC50LFxuICAgICAgICAgICAgMCwgMCwgZml4ZWQubCwgZml4ZWQudCk7XG5cbiAgICAgIC8vIEJMXG4gICAgICBpZiAoZml4ZWQubCAmJiBmaXhlZC5iKVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICAgIDAsIHRoaXMuc3RhZ2Uuc3JjU2l6ZS5oIC0gZml4ZWQuYiwgZml4ZWQubCwgZml4ZWQuYixcbiAgICAgICAgICAgIDAsIHRoaXMuc2l6ZS5oIC0gZml4ZWQuYiwgZml4ZWQubCwgZml4ZWQuYik7XG5cbiAgICAgIC8vIFRSXG4gICAgICBpZiAoZml4ZWQuciAmJiBmaXhlZC50KVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICAgIHRoaXMuc3RhZ2Uuc3JjU2l6ZS53IC0gZml4ZWQuciwgMCwgZml4ZWQuciwgZml4ZWQudCxcbiAgICAgICAgICAgIHRoaXMuc2l6ZS53IC0gZml4ZWQuciwgMCwgZml4ZWQuciwgZml4ZWQudCk7XG5cbiAgICAgIC8vIEJSXG4gICAgICBpZiAoZml4ZWQuciAmJiBmaXhlZC5iKVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICAgIHRoaXMuc3RhZ2Uuc3JjU2l6ZS53IC0gZml4ZWQuciwgdGhpcy5zdGFnZS5zcmNTaXplLmggLSBmaXhlZC5iLCBmaXhlZC5yLCBmaXhlZC5iLFxuICAgICAgICAgICAgdGhpcy5zaXplLncgLSBmaXhlZC5yLCB0aGlzLnNpemUuaCAtIGZpeGVkLmIsIGZpeGVkLnIsIGZpeGVkLmIpO1xuXG4gICAgICAvLyBUb3BcbiAgICAgIGlmIChmaXhlZC50KVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICAgIGZpeGVkLmwsIDAsIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QudywgZml4ZWQudCxcbiAgICAgICAgICAgIGZpeGVkLmwsIDAsIHRoaXMuc2l6ZS53IC0gZml4ZWQubCAtIGZpeGVkLnIsIGZpeGVkLnQpO1xuXG4gICAgICAvLyBMZWZ0XG4gICAgICBpZiAoZml4ZWQubClcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICAwLCBmaXhlZC50LCBmaXhlZC5sLCB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LmgsXG4gICAgICAgICAgICAwLCBmaXhlZC50LCBmaXhlZC5sLCB0aGlzLnNpemUuaCAtIGZpeGVkLnQgLSBmaXhlZC5iKTtcblxuICAgICAgLy8gUmlnaHRcbiAgICAgIGlmIChmaXhlZC5yKVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICAgIHRoaXMuc3RhZ2Uuc3JjU2l6ZS53IC0gZml4ZWQuciwgZml4ZWQudCwgZml4ZWQuciwgdGhpcy5zdGFnZS5zdHJldGNoUmVjdC5oLFxuICAgICAgICAgICAgdGhpcy5zaXplLncgLSBmaXhlZC5yLCBmaXhlZC50LCBmaXhlZC5yLCB0aGlzLnNpemUuaCAtIGZpeGVkLnQgLSBmaXhlZC5iKTtcblxuICAgICAgLy8gQm90dG9tXG4gICAgICBpZiAoZml4ZWQuYilcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICBmaXhlZC5sLCB0aGlzLnN0YWdlLnNyY1NpemUuaCAtIGZpeGVkLmIsIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QudywgZml4ZWQuYixcbiAgICAgICAgICAgIGZpeGVkLmwsIHRoaXMuc2l6ZS5oIC0gZml4ZWQuYiwgdGhpcy5zaXplLncgLSBmaXhlZC5sIC0gZml4ZWQuciwgZml4ZWQuYik7XG5cbiAgICAgIC8vIE1pZGRsZVxuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgZml4ZWQubCwgZml4ZWQudCwgdGhpcy5zdGFnZS5zdHJldGNoUmVjdC53LCB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LmgsXG4gICAgICAgICAgZml4ZWQubCwgZml4ZWQudCwgdGhpcy5zaXplLncgLSBmaXhlZC5sIC0gZml4ZWQuciwgdGhpcy5zaXplLmggLSBmaXhlZC50IC0gZml4ZWQuYik7XG5cbiAgICAgIC8vIHByZXZpZXcgY29udGVudFxuICAgICAgJCgnLnByZXZpZXctYXJlYSAudGV4dC1wcmV2aWV3JylcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuc3RhZ2UuY29udGVudFJlY3QueCArIFwicHhcIixcbiAgICAgICAgICAgIHRvcDogdGhpcy5zdGFnZS5jb250ZW50UmVjdC55ICsgXCJweFwiLFxuICAgICAgICAgICAgd2lkdGg6ICh0aGlzLnNpemUudyAtIHRoaXMuc3RhZ2Uuc3JjU2l6ZS53ICsgdGhpcy5zdGFnZS5jb250ZW50UmVjdC53KSArIFwicHhcIixcbiAgICAgICAgICAgIGhlaWdodDogKHRoaXMuc2l6ZS5oIC0gdGhpcy5zdGFnZS5zcmNTaXplLmggKyB0aGlzLnN0YWdlLmNvbnRlbnRSZWN0LmgpICsgXCJweFwiXG4gICAgICAgICAgfSk7XG4gICAgfVxuICB9XG59IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uLy4uL2ltYWdlbGliJztcbmltcG9ydCB7TmluZVBhdGNoVHJpbW1pbmd9IGZyb20gJy4vbmluZXBhdGNodHJpbW1pbmcnO1xuXG5jb25zdCBFTVBUWV9SRUNUID0ge3g6IDAsIHk6IDAsIHc6IDAsIGg6IDB9O1xuXG5jb25zdCBTTE9QX1BJWEVMUyA9IDEwO1xuXG5leHBvcnQgY2xhc3MgTmluZVBhdGNoU3RhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnpvb20gPSAxO1xuICAgIHRoaXMubWF0dGVDb2xvciA9ICdsaWdodCc7XG4gICAgdGhpcy5lZGl0TW9kZSA9ICdzdHJldGNoJztcbiAgICB0aGlzLnN0cmV0Y2hSZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgRU1QVFlfUkVDVCk7XG4gICAgdGhpcy5jb250ZW50UmVjdCA9IE9iamVjdC5hc3NpZ24oe30sIEVNUFRZX1JFQ1QpO1xuICAgIHRoaXMub3B0aWNhbEJvdW5kc1JlY3QgPSBPYmplY3QuYXNzaWduKHt9LCBFTVBUWV9SRUNUKTtcbiAgICB0aGlzLm5hbWUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gW107XG5cbiAgICB0aGlzLiRzdGFnZSA9ICQoJy5uaW5lLXBhdGNoLXN0YWdlJyk7XG4gICAgdGhpcy4kY2FudmFzQ29udGFpbmVyID0gJCgnLnN0YWdlLWNhbnZhcy1jb250YWluZXInKTtcblxuICAgIHRoaXMuc2V0dXBVaSgpO1xuICAgIHRoaXMuc2V0dXBEcmFnZ2luZygpO1xuXG4gICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlbGF5b3V0KCk7XG4gICAgICB0aGlzLnJlZHJhd092ZXJsYXkoKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgbm90aWZ5Q2hhbmdlXygpIHtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18uZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgfVxuXG4gIHNldHVwVWkoKSB7XG4gICAgLy8gU3RhZ2UgY29kZVxuICAgIHRoaXMuJHRvcExhYmVsID0gJCgnPGRpdj4nKS5hZGRDbGFzcygnY2FudmFzLWxhYmVsIGxhYmVsLXZlcnRpY2FsJykuaGlkZSgpLmFwcGVuZFRvKCdib2R5Jyk7XG4gICAgdGhpcy4kbGVmdExhYmVsID0gJCgnPGRpdj4nKS5hZGRDbGFzcygnY2FudmFzLWxhYmVsIGxhYmVsLWhvcml6b250YWwnKS5oaWRlKCkuYXBwZW5kVG8oJ2JvZHknKTtcbiAgICB0aGlzLiRyaWdodExhYmVsID0gJCgnPGRpdj4nKS5hZGRDbGFzcygnY2FudmFzLWxhYmVsIGxhYmVsLWhvcml6b250YWwnKS5oaWRlKCkuYXBwZW5kVG8oJ2JvZHknKTtcbiAgICB0aGlzLiRib3R0b21MYWJlbCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2NhbnZhcy1sYWJlbCBsYWJlbC12ZXJ0aWNhbCcpLmhpZGUoKS5hcHBlbmRUbygnYm9keScpO1xuXG4gICAgJCgnLnN0YWdlLXdoaWNoIGlucHV0Jykub24oJ2NoYW5nZScsIGV2ID0+IHtcbiAgICAgIHRoaXMuZWRpdE1vZGUgPSAkKGV2LmN1cnJlbnRUYXJnZXQpLnZhbCgpO1xuICAgICAgJCgnLnRyaW0tYnV0dG9uJykudG9nZ2xlKHRoaXMuZWRpdE1vZGUgPT0gJ3N0cmV0Y2gnKTtcbiAgICAgICQoJy5maW5kLXJlZ2lvbi1idXR0b24nKS50ZXh0KHtcbiAgICAgICAgc3RyZXRjaDogJ0F1dG8tc3RyZXRjaCcsXG4gICAgICAgIHBhZGRpbmc6ICdBdXRvLXBhZGRpbmcnLFxuICAgICAgICBvcHRpY2FsYm91bmRzOiAnQXV0by1ib3VuZHMnXG4gICAgICB9W3RoaXMuZWRpdE1vZGVdKTtcbiAgICAgICQoJy5zdGFnZS13aGljaCBpbnB1dCcpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAkKGV2LmN1cnJlbnRUYXJnZXQpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICAgIHRoaXMucmVkcmF3T3ZlcmxheSgpO1xuICAgIH0pO1xuXG4gICAgJCgnLnN0YWdlLW1hdHRlLWNvbG9yIGlucHV0Jykub24oJ2NoYW5nZScsIGV2ID0+IHtcbiAgICAgIHRoaXMubWF0dGVDb2xvciA9ICQoZXYuY3VycmVudFRhcmdldCkudmFsKCk7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmF0dHIoJ2RhdGEtdGhlbWUnLCB0aGlzLm1hdHRlQ29sb3IpO1xuICAgICAgJCgnLnN0YWdlLW1hdHRlLWNvbG9yIGlucHV0JykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICQoZXYuY3VycmVudFRhcmdldCkucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuICAgICAgdGhpcy5yZWRyYXdJbWFnZSgpO1xuICAgIH0pO1xuXG4gICAgJCgnLnRyaW0tZWRnZS1idXR0b24nKS5jbGljaygoKSA9PiBOaW5lUGF0Y2hUcmltbWluZy50cmltRWRnZXModGhpcykpO1xuICAgICQoJy50cmltLXN0cmV0Y2gtYnV0dG9uJykuY2xpY2soKCkgPT4gTmluZVBhdGNoVHJpbW1pbmcudHJpbVN0cmV0Y2hSZWdpb24odGhpcykpO1xuICAgICQoJy5maW5kLXJlZ2lvbi1idXR0b24nKS5jbGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVjdCA9IE5pbmVQYXRjaFRyaW1taW5nLmRldGVjdFJlZ2lvbih0aGlzLCB0aGlzLmVkaXRNb2RlKTtcbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09ICdzdHJldGNoJykge1xuICAgICAgICB0aGlzLnN0cmV0Y2hSZWN0ID0gcmVjdDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lZGl0TW9kZSA9PSAnb3B0aWNhbGJvdW5kcycpIHtcbiAgICAgICAgdGhpcy5vcHRpY2FsQm91bmRzUmVjdCA9IHJlY3Q7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWRpdE1vZGUgPT0gJ3BhZGRpbmcnKSB7XG4gICAgICAgIHRoaXMuY29udGVudFJlY3QgPSByZWN0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNhdmVSZWN0cygpO1xuICAgICAgdGhpcy5yZWRyYXdPdmVybGF5KCk7XG4gICAgICB0aGlzLm5vdGlmeUNoYW5nZV8oKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldHVwRHJhZ2dpbmcoKSB7XG4gICAgbGV0IG1vdXNlVXBIYW5kbGVyXywgZHJhZ2dpbmdNb3VzZU1vdmVIYW5kbGVyXztcblxuICAgIGxldCBnZXRFZGl0UmVjdF8gPSAoKSA9PiAoe1xuICAgICAgc3RyZXRjaDogdGhpcy5zdHJldGNoUmVjdCxcbiAgICAgIHBhZGRpbmc6IHRoaXMuY29udGVudFJlY3QsXG4gICAgICBvcHRpY2FsYm91bmRzOiB0aGlzLm9wdGljYWxCb3VuZHNSZWN0XG4gICAgfVt0aGlzLmVkaXRNb2RlXSk7XG5cbiAgICB0aGlzLiRjYW52YXNDb250YWluZXJcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBldiA9PiB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yZWRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgJCh3aW5kb3cpXG4gICAgICAgICAgICAgIC5vbignbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyXylcbiAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBkcmFnZ2luZ01vdXNlTW92ZUhhbmRsZXJfKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBldiA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLiRpbWFnZUNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGhhbmRsZWQgYnkgb3RoZXIgbW91c2Vtb3ZlIGhhbmRsZXJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZWRpdFJlY3QgPSBnZXRFZGl0UmVjdF8oKTtcbiAgICAgICAgICBsZXQgb2ZmcyA9IHRoaXMuJGNhbnZhc0NvbnRhaW5lci5vZmZzZXQoKTtcbiAgICAgICAgICBsZXQgb2Zmc2V0WCA9IGV2LnBhZ2VYIC0gb2Zmcy5sZWZ0O1xuICAgICAgICAgIGxldCBvZmZzZXRZID0gZXYucGFnZVkgLSBvZmZzLnRvcDtcblxuICAgICAgICAgIHRoaXMuZWRpdExlZnQgPSB0aGlzLmVkaXRSaWdodCA9IHRoaXMuZWRpdFRvcCA9IHRoaXMuZWRpdEJvdHRvbSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKG9mZnNldFggPj0gZWRpdFJlY3QueCAqIHRoaXMuem9vbSAtIFNMT1BfUElYRUxTICYmXG4gICAgICAgICAgICAgIG9mZnNldFggPD0gZWRpdFJlY3QueCAqIHRoaXMuem9vbSArIFNMT1BfUElYRUxTKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldFggPj0gKGVkaXRSZWN0LnggKyBlZGl0UmVjdC53KSAqIHRoaXMuem9vbSAtIFNMT1BfUElYRUxTICYmXG4gICAgICAgICAgICAgICAgICAgICBvZmZzZXRYIDw9IChlZGl0UmVjdC54ICsgZWRpdFJlY3QudykgKiB0aGlzLnpvb20gKyBTTE9QX1BJWEVMUykge1xuICAgICAgICAgICAgdGhpcy5lZGl0UmlnaHQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvZmZzZXRZID49IGVkaXRSZWN0LnkgKiB0aGlzLnpvb20gLSBTTE9QX1BJWEVMUyAmJlxuICAgICAgICAgICAgICBvZmZzZXRZIDw9IGVkaXRSZWN0LnkgKiB0aGlzLnpvb20gKyBTTE9QX1BJWEVMUykge1xuICAgICAgICAgICAgdGhpcy5lZGl0VG9wID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldFkgPj0gKGVkaXRSZWN0LnkgKyBlZGl0UmVjdC5oKSAqIHRoaXMuem9vbSAtIFNMT1BfUElYRUxTICYmXG4gICAgICAgICAgICAgICAgICAgICBvZmZzZXRZIDw9IChlZGl0UmVjdC55ICsgZWRpdFJlY3QuaCkgKiB0aGlzLnpvb20gKyBTTE9QX1BJWEVMUykge1xuICAgICAgICAgICAgdGhpcy5lZGl0Qm90dG9tID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgIGlmICh0aGlzLmVkaXRMZWZ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0VG9wKSB7XG4gICAgICAgICAgICAgIGN1cnNvciA9ICdudy1yZXNpemUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVkaXRCb3R0b20pIHtcbiAgICAgICAgICAgICAgY3Vyc29yID0gJ3N3LXJlc2l6ZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJzb3IgPSAndy1yZXNpemUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lZGl0UmlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRUb3ApIHtcbiAgICAgICAgICAgICAgY3Vyc29yID0gJ25lLXJlc2l6ZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWRpdEJvdHRvbSkge1xuICAgICAgICAgICAgICBjdXJzb3IgPSAnc2UtcmVzaXplJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnNvciA9ICdlLXJlc2l6ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVkaXRUb3ApIHtcbiAgICAgICAgICAgIGN1cnNvciA9ICduLXJlc2l6ZSc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVkaXRCb3R0b20pIHtcbiAgICAgICAgICAgIGN1cnNvciA9ICdzLXJlc2l6ZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuJGNhbnZhc0NvbnRhaW5lci5jc3MoJ2N1cnNvcicsIGN1cnNvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICBtb3VzZVVwSGFuZGxlcl8gPSBldiA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICAgIHRoaXMuc2F2ZVJlY3RzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAkKHdpbmRvdylcbiAgICAgICAgICAgIC5vZmYoJ21vdXNlbW92ZScsIGRyYWdnaW5nTW91c2VNb3ZlSGFuZGxlcl8pXG4gICAgICAgICAgICAub2ZmKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXJfKTtcbiAgICAgIH07XG5cbiAgICAgIGRyYWdnaW5nTW91c2VNb3ZlSGFuZGxlcl8gPSBldiA9PiB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGxldCBlZGl0UmVjdCA9IGdldEVkaXRSZWN0XygpO1xuICAgICAgICBsZXQgb2ZmcyA9IHRoaXMuJGNhbnZhc0NvbnRhaW5lci5vZmZzZXQoKTtcbiAgICAgICAgbGV0IG9mZnNldFggPSBldi5wYWdlWCAtIG9mZnMubGVmdDtcbiAgICAgICAgbGV0IG9mZnNldFkgPSBldi5wYWdlWSAtIG9mZnMudG9wO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRMZWZ0KSB7XG4gICAgICAgICAgbGV0IG5ld1ggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlZGl0UmVjdC54ICsgZWRpdFJlY3QudyAtIDEsIE1hdGgucm91bmQob2Zmc2V0WCAvIHRoaXMuem9vbSkpKTtcbiAgICAgICAgICBlZGl0UmVjdC53ID0gZWRpdFJlY3QudyArIGVkaXRSZWN0LnggLSBuZXdYO1xuICAgICAgICAgIGVkaXRSZWN0LnggPSBuZXdYO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRUb3ApIHtcbiAgICAgICAgICBsZXQgbmV3WSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVkaXRSZWN0LnkgKyBlZGl0UmVjdC5oIC0gMSwgTWF0aC5yb3VuZChvZmZzZXRZIC8gdGhpcy56b29tKSkpO1xuICAgICAgICAgIGVkaXRSZWN0LmggPSBlZGl0UmVjdC5oICsgZWRpdFJlY3QueSAtIG5ld1k7XG4gICAgICAgICAgZWRpdFJlY3QueSA9IG5ld1k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdFJpZ2h0KSB7XG4gICAgICAgICAgZWRpdFJlY3QudyA9IE1hdGgubWluKHRoaXMuc3JjU2l6ZS53IC0gZWRpdFJlY3QueCxcbiAgICAgICAgICAgICAgTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChvZmZzZXRYIC8gdGhpcy56b29tKSAtIGVkaXRSZWN0LngpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0Qm90dG9tKSB7XG4gICAgICAgICAgZWRpdFJlY3QuaCA9IE1hdGgubWluKHRoaXMuc3JjU2l6ZS5oIC0gZWRpdFJlY3QueSxcbiAgICAgICAgICAgICAgTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChvZmZzZXRZIC8gdGhpcy56b29tKSAtIGVkaXRSZWN0LnkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZV8oKTtcbiAgICAgIH07XG4gIH1cblxuICBsb2FkU291cmNlSW1hZ2Uoc3JjQ3R4LCBpbml0UmVjdHMgPSB7fSkge1xuICAgIHRoaXMuJGNhbnZhc0NvbnRhaW5lci5lbXB0eSgpO1xuICAgICQoJy5lZGl0b3ItYnV0dG9uJykuYXR0cignZGlzYWJsZWQnLCBzcmNDdHggPyBudWxsIDogJ2Rpc2FibGVkJyk7XG5cbiAgICBpZiAoIXNyY0N0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3JjQ3R4ID0gc3JjQ3R4O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzdGFnZSBzb3VyY2Ugc2l6ZVxuICAgIGxldCBzcmNTaXplQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGxldCBuZXdTcmNTaXplID0geyB3OiB0aGlzLnNyY0N0eC5jYW52YXMud2lkdGgsIGg6IHRoaXMuc3JjQ3R4LmNhbnZhcy5oZWlnaHQgfTtcbiAgICBzcmNTaXplQ2hhbmdlZCA9ICF0aGlzLnNyY1NpemVcbiAgICAgICAgfHwgdGhpcy5zcmNTaXplLncgIT0gbmV3U3JjU2l6ZS53XG4gICAgICAgIHx8IHRoaXMuc3JjU2l6ZS5oICE9IG5ld1NyY1NpemUuaDtcbiAgICB0aGlzLnNyY1NpemUgPSBuZXdTcmNTaXplO1xuXG4gICAgLy8gUmVzZXQgdGhlIHN0cmV0Y2gsIHBhZGRpbmcvY29udGVudCwgYW5kIG9wdGljYWwgYm91bmRzIHJlZ2lvbnNcbiAgICBpZiAoc3JjU2l6ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc3RyZXRjaFJlY3QgPSBpbml0UmVjdHMuc3RyZXRjaFJlY3QgfHwge1xuICAgICAgICB4OiBNYXRoLmZsb29yKHRoaXMuc3JjU2l6ZS53IC8gMyksXG4gICAgICAgIHk6IE1hdGguZmxvb3IodGhpcy5zcmNTaXplLmggLyAzKSxcbiAgICAgICAgdzogTWF0aC5jZWlsKHRoaXMuc3JjU2l6ZS53IC8gMyksXG4gICAgICAgIGg6IE1hdGguY2VpbCh0aGlzLnNyY1NpemUuaCAvIDMpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNvbnRlbnRSZWN0ID0gaW5pdFJlY3RzLmNvbnRlbnRSZWN0IHx8IHsgeDogMCwgeTogMCwgdzogdGhpcy5zcmNTaXplLncsIGg6IHRoaXMuc3JjU2l6ZS5oIH07XG4gICAgICB0aGlzLm9wdGljYWxCb3VuZHNSZWN0ID0gaW5pdFJlY3RzLm9wdGljYWxCb3VuZHNSZWN0IHx8IHsgeDogMCwgeTogMCwgdzogdGhpcy5zcmNTaXplLncsIGg6IHRoaXMuc3JjU2l6ZS5oIH07XG4gICAgfVxuXG4gICAgaWYgKCFpbml0UmVjdHMuc3RyZXRjaFJlY3QpIHtcbiAgICAgIHRoaXMubG9hZExhc3RSZWN0cygpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgc3RhZ2UgY2FudmFzXG4gICAgdGhpcy4kaW1hZ2VDYW52YXMgPSAkKCc8Y2FudmFzPicpXG4gICAgICAgIC5hdHRyKHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5zcmNTaXplLncsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLnNyY1NpemUuaFxuICAgICAgICB9KVxuICAgICAgICAuYXBwZW5kVG8odGhpcy4kY2FudmFzQ29udGFpbmVyKTtcblxuICAgIHRoaXMuJG92ZXJsYXlDYW52YXMgPSAkKCc8Y2FudmFzPicpLmFkZENsYXNzKCdvdmVybGF5JykuYXBwZW5kVG8odGhpcy4kY2FudmFzQ29udGFpbmVyKTtcblxuICAgIHRoaXMucmVsYXlvdXQoKTtcbiAgICB0aGlzLnJlZHJhd0ltYWdlKCk7XG4gICAgdGhpcy5yZWRyYXdPdmVybGF5KCk7XG4gICAgdGhpcy5ub3RpZnlDaGFuZ2VfKCk7XG4gIH1cblxuICByZWxheW91dCgpIHtcbiAgICBpZiAoIXRoaXMuJGltYWdlQ2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHpvb20gbGV2ZWwgdGhhdCdsbCBzaG93IHRoZSBzdGFnZSBhcyBsYXJnZSBhcyBwb3NzaWJsZVxuICAgIGxldCBob3Jpek1heFpvb20gPSBNYXRoLmZsb29yKHRoaXMuJHN0YWdlLndpZHRoKCkgLyB0aGlzLnNyY1NpemUudyk7XG4gICAgbGV0IHZlcnRNYXhab29tID0gTWF0aC5mbG9vcih0aGlzLiRzdGFnZS5oZWlnaHQoKSAvIHRoaXMuc3JjU2l6ZS5oKTtcbiAgICB0aGlzLnpvb20gPSBNYXRoLm1heCgxLCBNYXRoLm1pbihob3Jpek1heFpvb20sIHZlcnRNYXhab29tKSk7XG4gICAgdGhpcy56b29tZWRTaXplID0ge1xuICAgICAgdzogdGhpcy5zcmNTaXplLncgKiB0aGlzLnpvb20sXG4gICAgICBoOiB0aGlzLnNyY1NpemUuaCAqIHRoaXMuem9vbVxuICAgIH07XG5cbiAgICB0aGlzLiRpbWFnZUNhbnZhcy5jc3Moe1xuICAgICAgd2lkdGg6IHRoaXMuem9vbWVkU2l6ZS53LFxuICAgICAgaGVpZ2h0OiB0aGlzLnpvb21lZFNpemUuaFxuICAgIH0pO1xuICAgIHRoaXMuJG92ZXJsYXlDYW52YXMuYXR0cih7XG4gICAgICB3aWR0aDogdGhpcy56b29tZWRTaXplLncsXG4gICAgICBoZWlnaHQ6IHRoaXMuem9vbWVkU2l6ZS5oXG4gICAgfSk7XG4gIH1cblxuICByZWRyYXdJbWFnZSgpIHtcbiAgICBpZiAoIXRoaXMuJGltYWdlQ2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGltZ0N0eCA9IHRoaXMuJGltYWdlQ2FudmFzLmdldCgwKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGltZ0N0eC5maWxsU3R5bGUgPSAodGhpcy5tYXR0ZUNvbG9yID09ICdsaWdodCcpID8gJyNlZWUnIDogJyM1NTUnO1xuICAgIGltZ0N0eC5maWxsUmVjdCgwLCAwLCB0aGlzLnNyY1NpemUudywgdGhpcy5zcmNTaXplLmgpO1xuXG4gICAgLy8gZHJhdyBzb3VyY2UgZ3JhcGhpY1xuICAgIGltZ0N0eC5kcmF3SW1hZ2UodGhpcy5zcmNDdHguY2FudmFzLCAwLCAwKTtcbiAgfVxuXG4gIHJlZHJhd092ZXJsYXkoKSB7XG4gICAgaWYgKCF0aGlzLnNyY0N0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBlZGl0UmVjdCA9IHtcbiAgICAgIHN0cmV0Y2g6IHRoaXMuc3RyZXRjaFJlY3QsXG4gICAgICBwYWRkaW5nOiB0aGlzLmNvbnRlbnRSZWN0LFxuICAgICAgb3B0aWNhbGJvdW5kczogdGhpcy5vcHRpY2FsQm91bmRzUmVjdFxuICAgIH1bdGhpcy5lZGl0TW9kZV07XG5cbiAgICBsZXQgY3R4ID0gdGhpcy4kb3ZlcmxheUNhbnZhcy5nZXQoMCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuem9vbWVkU2l6ZS53LCB0aGlzLnpvb21lZFNpemUuaCk7XG4gICAgY3R4LnNhdmUoKTtcblxuICAgIC8vIGRyYXcgY3VycmVudCBlZGl0IHJlZ2lvblxuICAgIGlmIChlZGl0UmVjdCA9PT0gdGhpcy5zdHJldGNoUmVjdCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKDAsIGVkaXRSZWN0LnkgKiB0aGlzLnpvb20gKyAuNSk7XG4gICAgICBjdHgubGluZVRvKHRoaXMuem9vbWVkU2l6ZS53LCBlZGl0UmVjdC55ICogdGhpcy56b29tICsgLjUpO1xuXG4gICAgICBjdHgubW92ZVRvKDAsIChlZGl0UmVjdC55ICsgZWRpdFJlY3QuaCkgKiB0aGlzLnpvb20gLSAuNSk7XG4gICAgICBjdHgubGluZVRvKHRoaXMuem9vbWVkU2l6ZS53LCAoZWRpdFJlY3QueSArIGVkaXRSZWN0LmgpICogdGhpcy56b29tIC0gLjUpO1xuXG4gICAgICBjdHgubW92ZVRvKGVkaXRSZWN0LnggKiB0aGlzLnpvb20gKyAuNSwgMCk7XG4gICAgICBjdHgubGluZVRvKGVkaXRSZWN0LnggKiB0aGlzLnpvb20gKyAuNSwgdGhpcy56b29tZWRTaXplLmgpO1xuXG4gICAgICBjdHgubW92ZVRvKChlZGl0UmVjdC54ICsgZWRpdFJlY3QudykgKiB0aGlzLnpvb20gLSAuNSwgMCk7XG4gICAgICBjdHgubGluZVRvKChlZGl0UmVjdC54ICsgZWRpdFJlY3QudykgKiB0aGlzLnpvb20gLSAuNSwgdGhpcy56b29tZWRTaXplLmgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgucmVjdChcbiAgICAgICAgICBlZGl0UmVjdC54ICogdGhpcy56b29tICsgLjUsIGVkaXRSZWN0LnkgKiB0aGlzLnpvb20gKyAuNSxcbiAgICAgICAgICBlZGl0UmVjdC53ICogdGhpcy56b29tIC0gMSwgZWRpdFJlY3QuaCAqIHRoaXMuem9vbSAtIDEpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAxKSc7XG4gICAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMjMsIDY4LCAxKSc7XG4gICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgLjUpJztcbiAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgLjUpJztcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbMywgM10pO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIC8vIGRyYXcgZGlzdGFuY2UgbGFiZWxzXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIGxldCBzdGFnZU9mZnNldCA9IHRoaXMuJGNhbnZhc0NvbnRhaW5lci5vZmZzZXQoKTtcblxuICAgICAgdGhpcy4kbGVmdExhYmVsXG4gICAgICAgICAgLnRleHQoZWRpdFJlY3QueClcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YWdlT2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICB3aWR0aDogZWRpdFJlY3QueCAqIHRoaXMuem9vbSxcbiAgICAgICAgICAgIHRvcDogc3RhZ2VPZmZzZXQudG9wICsgKGVkaXRSZWN0LnkgKyBlZGl0UmVjdC5oIC8gMikgKiB0aGlzLnpvb21cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zaG93KCk7XG5cbiAgICAgIHRoaXMuJHJpZ2h0TGFiZWxcbiAgICAgICAgICAudGV4dCh0aGlzLnNyY1NpemUudyAtIGVkaXRSZWN0LnggLSBlZGl0UmVjdC53KVxuICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgbGVmdDogc3RhZ2VPZmZzZXQubGVmdCArIChlZGl0UmVjdC54ICsgZWRpdFJlY3QudykgKiB0aGlzLnpvb20sXG4gICAgICAgICAgICB3aWR0aDogKHRoaXMuc3JjU2l6ZS53IC0gZWRpdFJlY3QueCAtIGVkaXRSZWN0LncpICogdGhpcy56b29tLFxuICAgICAgICAgICAgdG9wOiBzdGFnZU9mZnNldC50b3AgKyAoZWRpdFJlY3QueSArIGVkaXRSZWN0LmggLyAyKSAqIHRoaXMuem9vbVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNob3coKTtcblxuICAgICAgdGhpcy4kdG9wTGFiZWxcbiAgICAgICAgICAudGV4dChlZGl0UmVjdC55KVxuICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgdG9wOiBzdGFnZU9mZnNldC50b3AsXG4gICAgICAgICAgICBoZWlnaHQ6IGVkaXRSZWN0LnkgKiB0aGlzLnpvb20sXG4gICAgICAgICAgICBsZWZ0OiBzdGFnZU9mZnNldC5sZWZ0ICsgKGVkaXRSZWN0LnggKyBlZGl0UmVjdC53IC8gMikgKiB0aGlzLnpvb21cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zaG93KCk7XG5cbiAgICAgIHRoaXMuJGJvdHRvbUxhYmVsXG4gICAgICAgICAgLnRleHQodGhpcy5zcmNTaXplLmggLSBlZGl0UmVjdC55IC0gZWRpdFJlY3QuaClcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgIHRvcDogc3RhZ2VPZmZzZXQudG9wICsgKGVkaXRSZWN0LnkgKyBlZGl0UmVjdC5oKSAqIHRoaXMuem9vbSxcbiAgICAgICAgICAgIGhlaWdodDogKHRoaXMuc3JjU2l6ZS5oIC0gZWRpdFJlY3QueSAtIGVkaXRSZWN0LmgpICogdGhpcy56b29tLFxuICAgICAgICAgICAgbGVmdDogc3RhZ2VPZmZzZXQubGVmdCArIChlZGl0UmVjdC54ICsgZWRpdFJlY3QudyAvIDIpICogdGhpcy56b29tXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiR0b3BMYWJlbC5oaWRlKCk7XG4gICAgICB0aGlzLiRsZWZ0TGFiZWwuaGlkZSgpO1xuICAgICAgdGhpcy4kcmlnaHRMYWJlbC5oaWRlKCk7XG4gICAgICB0aGlzLiRib3R0b21MYWJlbC5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxvY2FsU3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gYGFzc2V0U3R1ZGlvTmluZVBhdGNoU3RhZ2UtJHt0aGlzLm5hbWV9YDtcbiAgfVxuXG4gIHNhdmVSZWN0cygpIHtcbiAgICBsb2NhbFN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXldID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc3RyZXRjaFJlY3Q6IHRoaXMuc3RyZXRjaFJlY3QsXG4gICAgICBjb250ZW50UmVjdDogdGhpcy5jb250ZW50UmVjdCxcbiAgICAgIG9wdGljYWxCb3VuZHNSZWN0OiB0aGlzLm9wdGljYWxCb3VuZHNSZWN0XG4gICAgfSk7XG4gIH1cblxuICBsb2FkTGFzdFJlY3RzKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgc3RvcmUgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleV0pO1xuICAgICAgaWYgKHN0b3JlLnN0cmV0Y2hSZWN0ICYmIHN0b3JlLmNvbnRlbnRSZWN0ICYmIHN0b3JlLm9wdGljYWxCb3VuZHNSZWN0KSB7XG4gICAgICAgIHRoaXMuc3RyZXRjaFJlY3QgPSBmaXRSZWN0XyhzdG9yZS5zdHJldGNoUmVjdCwgdGhpcy5zcmNTaXplKTtcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGZpdFJlY3RfKHN0b3JlLmNvbnRlbnRSZWN0LCB0aGlzLnNyY1NpemUpO1xuICAgICAgICB0aGlzLm9wdGljYWxCb3VuZHNSZWN0ID0gZml0UmVjdF8oc3RvcmUub3B0aWNhbEJvdW5kc1JlY3QsIHRoaXMuc3JjU2l6ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG5mdW5jdGlvbiBmaXRSZWN0XyhyZWN0LCBzaXplKSB7XG4gIGxldCBuZXdSZWN0ID0ge307XG4gIG5ld1JlY3QueCA9IE1hdGgubWF4KDAsIHJlY3QueCk7XG4gIG5ld1JlY3QueSA9IE1hdGgubWF4KDAsIHJlY3QueSk7XG4gIG5ld1JlY3QudyA9IE1hdGgubWluKHNpemUudyAtIHJlY3QueCwgcmVjdC53KTtcbiAgbmV3UmVjdC5oID0gTWF0aC5taW4oc2l6ZS5oIC0gcmVjdC55LCByZWN0LmgpO1xuICByZXR1cm4gbmV3UmVjdDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2ltYWdlbGlifSBmcm9tICcuLi8uLi9pbWFnZWxpYic7XG5pbXBvcnQge1N1bW1lcn0gZnJvbSAnLi9zdW1tZXInO1xuXG5leHBvcnQgY29uc3QgTmluZVBhdGNoVHJpbW1pbmcgPSB7XG4gIC8qKlxuICAgKiBUcmltcyBleGNlc3MgZWRnZXMgb2YgdGhlIG5pbmUgcGF0Y2guLi4gYW55IHBpeGVscyB0aGF0IGFyZSB0aGUgc2FtZVxuICAgKiBhcyB0aGUgdG9wLWxlZnQgbW9zdCBwaXhlbCBjb2xvci4gU2FtZSBhcyBQaG90b3Nob3AncyBUcmltIGZlYXR1cmUuXG4gICAqL1xuICB0cmltRWRnZXMoc3RhZ2UpIHtcbiAgICBpZiAoIXN0YWdlLnNyY0N0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNyY0RhdGEgPSBzdGFnZS5zcmNDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHN0YWdlLnNyY1NpemUudywgc3RhZ2Uuc3JjU2l6ZS5oKTtcblxuICAgIC8vIEFsd2F5cyB0cmltIGJ5IHRvcC1sZWZ0IHBpeGVsIGNvbG9yXG4gICAgY29uc3QgdHJpbVBpeGVsID0gZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCAwLCAwKTtcblxuICAgIGxldCBpbnNldFJlY3QgPSB7bDowLCB0OjAsIHI6MCwgYjowfTtcbiAgICBsZXQgeCwgeTtcblxuICAgIC8vIFRyaW0gdG9wXG4gICAgdHJpbVRvcDpcbiAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgIGZvciAoeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgICBpZiAoZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCB4LCB5KSAhPSB0cmltUGl4ZWwpIHtcbiAgICAgICAgICBicmVhayB0cmltVG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc2V0UmVjdC50ID0geTtcbiAgICAvLyBUcmltIGxlZnRcbiAgICB0cmltTGVmdDpcbiAgICBmb3IgKHggPSAwOyB4IDwgc3RhZ2Uuc3JjU2l6ZS53OyB4KyspIHtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgICBpZiAoZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCB4LCB5KSAhPSB0cmltUGl4ZWwpIHtcbiAgICAgICAgICBicmVhayB0cmltTGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnNldFJlY3QubCA9IHg7XG4gICAgLy8gVHJpbSBib3R0b21cbiAgICB0cmltQm90dG9tOlxuICAgIGZvciAoeSA9IHN0YWdlLnNyY1NpemUuaCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICBmb3IgKHggPSAwOyB4IDwgc3RhZ2Uuc3JjU2l6ZS53OyB4KyspIHtcbiAgICAgICAgaWYgKGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgeCwgeSkgIT0gdHJpbVBpeGVsKSB7XG4gICAgICAgICAgYnJlYWsgdHJpbUJvdHRvbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnNldFJlY3QuYiA9IHN0YWdlLnNyY1NpemUuaCAtIHkgLSAxO1xuICAgIC8vIFRyaW0gcmlnaHRcbiAgICB0cmltUmlnaHQ6XG4gICAgZm9yICh4ID0gc3RhZ2Uuc3JjU2l6ZS53IC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgICBpZiAoZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCB4LCB5KSAhPSB0cmltUGl4ZWwpIHtcbiAgICAgICAgICBicmVhayB0cmltUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zZXRSZWN0LnIgPSBzdGFnZS5zcmNTaXplLncgLSB4IC0gMTtcblxuICAgIGlmIChpbnNldFJlY3QubCA8PSAwICYmIGluc2V0UmVjdC50IDw9IDAgJiYgaW5zZXRSZWN0LnIgPD0gMCAmJiBpbnNldFJlY3QuYiA8PSAwKSB7XG4gICAgICAvLyBOby1vcFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIGEgbmV3IHN0YWdlIHdpdGggaW5zZXQgdmFsdWVzXG4gICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgIHc6IHN0YWdlLnNyY1NpemUudyAtIGluc2V0UmVjdC5sIC0gaW5zZXRSZWN0LnIsXG4gICAgICBoOiBzdGFnZS5zcmNTaXplLmggLSBpbnNldFJlY3QudCAtIGluc2V0UmVjdC5iXG4gICAgfTtcblxuICAgIGNvbnN0IHJlY3RzID0ge1xuICAgICAgY29udGVudFJlY3Q6IGNvbnN0cmFpbl8oc2l6ZSwge1xuICAgICAgICB4OiBzdGFnZS5jb250ZW50UmVjdC54IC0gaW5zZXRSZWN0LmwsXG4gICAgICAgIHk6IHN0YWdlLmNvbnRlbnRSZWN0LnkgLSBpbnNldFJlY3QudCxcbiAgICAgICAgdzogc3RhZ2UuY29udGVudFJlY3QudyxcbiAgICAgICAgaDogc3RhZ2UuY29udGVudFJlY3QuaFxuICAgICAgfSksXG4gICAgICBzdHJldGNoUmVjdDogY29uc3RyYWluXyhzaXplLCB7XG4gICAgICAgIHg6IHN0YWdlLnN0cmV0Y2hSZWN0LnggLSBpbnNldFJlY3QubCxcbiAgICAgICAgeTogc3RhZ2Uuc3RyZXRjaFJlY3QueSAtIGluc2V0UmVjdC50LFxuICAgICAgICB3OiBzdGFnZS5zdHJldGNoUmVjdC53LFxuICAgICAgICBoOiBzdGFnZS5zdHJldGNoUmVjdC5oXG4gICAgICB9KSxcbiAgICAgIG9wdGljYWxCb3VuZHNSZWN0OiBjb25zdHJhaW5fKHNpemUsIHtcbiAgICAgICAgeDogc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QueCAtIGluc2V0UmVjdC5sLFxuICAgICAgICB5OiBzdGFnZS5vcHRpY2FsQm91bmRzUmVjdC55IC0gaW5zZXRSZWN0LnQsXG4gICAgICAgIHc6IHN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LncsXG4gICAgICAgIGg6IHN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LmhcbiAgICAgIH0pXG4gICAgfTtcblxuICAgIHN0YWdlLm5hbWUgPSBgJHtzdGFnZS5uYW1lfS1FREdFU19UUklNTUVEYDtcbiAgICBsZXQgbmV3Q3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgIG5ld0N0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgaW5zZXRSZWN0LmwsIGluc2V0UmVjdC50LCBzaXplLncsIHNpemUuaCxcbiAgICAgICAgMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuICAgIHN0YWdlLmxvYWRTb3VyY2VJbWFnZShuZXdDdHgsIHJlY3RzKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJpbXMgZXhjZXNzIHJvd3MgYW5kIGNvbHVtbnMgZnJvbSB0aGUgc3RyZXRjaCByZWdpb24gb2YgdGhlIGdpdmVuXG4gICAqIG5pbmUgcGF0Y2ggc3RhZ2UuXG4gICAqL1xuICB0cmltU3RyZXRjaFJlZ2lvbihzdGFnZSkge1xuICAgIGlmICghc3RhZ2Uuc3JjQ3R4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3JjRGF0YSA9IHN0YWdlLnNyY0N0eC5nZXRJbWFnZURhdGEoMCwgMCwgc3RhZ2Uuc3JjU2l6ZS53LCBzdGFnZS5zcmNTaXplLmgpO1xuXG4gICAgbGV0IGNvbGxhcHNlWCA9IHN0YWdlLnN0cmV0Y2hSZWN0LncgPiA0OyAvLyBnZW5lcmFsbHkgZ29pbmcgdG8gc3RhcnQgYXMgdHJ1ZVxuICAgIGxldCBjb2xsYXBzZVkgPSBzdGFnZS5zdHJldGNoUmVjdC5oID4gNDsgLy8gZ2VuZXJhbGx5IGdvaW5nIHRvIHN0YXJ0IGFzIHRydWVcbiAgICBsZXQgeCwgeTtcblxuICAgIC8vIFNlZSBpZiBjb2xsYXBzZSBpcyBwb3NzaWJsZSBpbiBlaXRoZXIgZGlyZWN0aW9uIGJ5IGNvbXBhcmluZyByb3cvY29sdW1uIHN1bXMuXG4gICAgY29uc3Qgc3VtbWVyID0gbmV3IFN1bW1lcigpO1xuXG4gICAgLy8gU2VlIGlmIGNhbiBiZSBob3Jpem9udGFsbHkgY29sbGFwc2VkLlxuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgbGV0IGZpcnN0U3VtID0gLTE7XG4gICAgZm9yICh4ID0gc3RhZ2Uuc3RyZXRjaFJlY3QueDsgeCA8IChzdGFnZS5zdHJldGNoUmVjdC54ICsgc3RhZ2Uuc3RyZXRjaFJlY3Qudyk7IHgrKykge1xuICAgICAgLy8gQ29tcHV0ZSBjb2x1bW5cbiAgICAgIHN1bW1lci5yZXNldCgpO1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHN0YWdlLnNyY1NpemUuaDsgeSsrKSB7XG4gICAgICAgIHN1bW1lci5hZGROZXh0KGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgeCwgeSkpO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0U3VtID0gc3VtbWVyLmNvbXB1dGUoKTtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoc3VtbWVyLmNvbXB1dGUoKSAhPSBmaXJzdFN1bSkge1xuICAgICAgICBjb2xsYXBzZVggPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3QgPSB0cnVlO1xuICAgIGZvciAoeSA9IHN0YWdlLnN0cmV0Y2hSZWN0Lnk7IHkgPCAoc3RhZ2Uuc3RyZXRjaFJlY3QueSArIHN0YWdlLnN0cmV0Y2hSZWN0LmgpOyB5KyspIHtcbiAgICAgIC8vIENvbXB1dGUgcm93XG4gICAgICBzdW1tZXIucmVzZXQoKTtcbiAgICAgIGZvciAoeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgICBzdW1tZXIuYWRkTmV4dChnZXRQaXhlbF8oc3RhZ2UsIHNyY0RhdGEsIHgsIHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdFN1bSA9IHN1bW1lci5jb21wdXRlKCk7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHN1bW1lci5jb21wdXRlKCkgIT0gZmlyc3RTdW0pIHtcbiAgICAgICAgY29sbGFwc2VZID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29sbGFwc2VYICYmICFjb2xsYXBzZVkpIHtcbiAgICAgIC8vIE5vLW9wXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZml4ZWQgPSB7XG4gICAgICBsOiBzdGFnZS5zdHJldGNoUmVjdC54LFxuICAgICAgdDogc3RhZ2Uuc3RyZXRjaFJlY3QueSxcbiAgICAgIHI6IHN0YWdlLnNyY1NpemUudyAtIHN0YWdlLnN0cmV0Y2hSZWN0LnggLSBzdGFnZS5zdHJldGNoUmVjdC53LFxuICAgICAgYjogc3RhZ2Uuc3JjU2l6ZS5oIC0gc3RhZ2Uuc3RyZXRjaFJlY3QueSAtIHN0YWdlLnN0cmV0Y2hSZWN0LmhcbiAgICB9O1xuXG4gICAgY29uc3QgbWlkZGxlID0ge1xuICAgICAgdzogY29sbGFwc2VYID8gNCA6IHN0YWdlLnN0cmV0Y2hSZWN0LncsXG4gICAgICBoOiBjb2xsYXBzZVkgPyA0IDogc3RhZ2Uuc3RyZXRjaFJlY3QuaFxuICAgIH07XG5cbiAgICBjb25zdCBzaXplID0ge1xuICAgICAgdzogZml4ZWQubCArIG1pZGRsZS53ICsgZml4ZWQucixcbiAgICAgIGg6IGZpeGVkLnQgKyBtaWRkbGUuaCArIGZpeGVkLmJcbiAgICB9O1xuXG4gICAgLy8gUmVkcmF3IGNvbXBvbmVudHNcbiAgICBjb25zdCBjdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG5cbiAgICAvLyBUTFxuICAgIGlmIChmaXhlZC5sICYmIGZpeGVkLnQpXG4gICAgICBjdHguZHJhd0ltYWdlKHN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgMCwgMCwgZml4ZWQubCwgZml4ZWQudCxcbiAgICAgICAgICAwLCAwLCBmaXhlZC5sLCBmaXhlZC50KTtcblxuICAgIC8vIEJMXG4gICAgaWYgKGZpeGVkLmwgJiYgZml4ZWQuYilcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICAwLCBzdGFnZS5zcmNTaXplLmggLSBmaXhlZC5iLCBmaXhlZC5sLCBmaXhlZC5iLFxuICAgICAgICAgIDAsIHNpemUuaCAtIGZpeGVkLmIsIGZpeGVkLmwsIGZpeGVkLmIpO1xuXG4gICAgLy8gVFJcbiAgICBpZiAoZml4ZWQuciAmJiBmaXhlZC50KVxuICAgICAgY3R4LmRyYXdJbWFnZShzdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgIHN0YWdlLnNyY1NpemUudyAtIGZpeGVkLnIsIDAsIGZpeGVkLnIsIGZpeGVkLnQsXG4gICAgICAgICAgc2l6ZS53IC0gZml4ZWQuciwgMCwgZml4ZWQuciwgZml4ZWQudCk7XG5cbiAgICAvLyBCUlxuICAgIGlmIChmaXhlZC5yICYmIGZpeGVkLmIpXG4gICAgICBjdHguZHJhd0ltYWdlKHN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgc3RhZ2Uuc3JjU2l6ZS53IC0gZml4ZWQuciwgc3RhZ2Uuc3JjU2l6ZS5oIC0gZml4ZWQuYiwgZml4ZWQuciwgZml4ZWQuYixcbiAgICAgICAgICBzaXplLncgLSBmaXhlZC5yLCBzaXplLmggLSBmaXhlZC5iLCBmaXhlZC5yLCBmaXhlZC5iKTtcblxuICAgIC8vIFRvcFxuICAgIGlmIChmaXhlZC50KVxuICAgICAgY3R4LmRyYXdJbWFnZShzdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgIGZpeGVkLmwsIDAsIHN0YWdlLnN0cmV0Y2hSZWN0LncsIGZpeGVkLnQsXG4gICAgICAgICAgZml4ZWQubCwgMCwgc2l6ZS53IC0gZml4ZWQubCAtIGZpeGVkLnIsIGZpeGVkLnQpO1xuXG4gICAgLy8gTGVmdFxuICAgIGlmIChmaXhlZC5sKVxuICAgICAgY3R4LmRyYXdJbWFnZShzdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgIDAsIGZpeGVkLnQsIGZpeGVkLmwsIHN0YWdlLnN0cmV0Y2hSZWN0LmgsXG4gICAgICAgICAgMCwgZml4ZWQudCwgZml4ZWQubCwgc2l6ZS5oIC0gZml4ZWQudCAtIGZpeGVkLmIpO1xuXG4gICAgLy8gUmlnaHRcbiAgICBpZiAoZml4ZWQucilcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICBzdGFnZS5zcmNTaXplLncgLSBmaXhlZC5yLCBmaXhlZC50LCBmaXhlZC5yLCBzdGFnZS5zdHJldGNoUmVjdC5oLFxuICAgICAgICAgIHNpemUudyAtIGZpeGVkLnIsIGZpeGVkLnQsIGZpeGVkLnIsIHNpemUuaCAtIGZpeGVkLnQgLSBmaXhlZC5iKTtcblxuICAgIC8vIEJvdHRvbVxuICAgIGlmIChmaXhlZC5iKVxuICAgICAgY3R4LmRyYXdJbWFnZShzdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgIGZpeGVkLmwsIHN0YWdlLnNyY1NpemUuaCAtIGZpeGVkLmIsIHN0YWdlLnN0cmV0Y2hSZWN0LncsIGZpeGVkLmIsXG4gICAgICAgICAgZml4ZWQubCwgc2l6ZS5oIC0gZml4ZWQuYiwgc2l6ZS53IC0gZml4ZWQubCAtIGZpeGVkLnIsIGZpeGVkLmIpO1xuXG4gICAgLy8gTWlkZGxlXG4gICAgY3R4LmRyYXdJbWFnZShzdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICBmaXhlZC5sLCBmaXhlZC50LCBzdGFnZS5zdHJldGNoUmVjdC53LCBzdGFnZS5zdHJldGNoUmVjdC5oLFxuICAgICAgICBmaXhlZC5sLCBmaXhlZC50LCBzaXplLncgLSBmaXhlZC5sIC0gZml4ZWQuciwgc2l6ZS5oIC0gZml4ZWQudCAtIGZpeGVkLmIpO1xuXG4gICAgY29uc3QgcmVjdHMgPSB7XG4gICAgICBzdHJldGNoUmVjdDoge1xuICAgICAgICB4OiBzdGFnZS5zdHJldGNoUmVjdC54LFxuICAgICAgICB5OiBzdGFnZS5zdHJldGNoUmVjdC55LFxuICAgICAgICB3OiBtaWRkbGUudyxcbiAgICAgICAgaDogbWlkZGxlLmhcbiAgICAgIH0sXG4gICAgICBjb250ZW50UmVjdDoge1xuICAgICAgICB4OiBzdGFnZS5jb250ZW50UmVjdC54LFxuICAgICAgICB5OiBzdGFnZS5jb250ZW50UmVjdC55LFxuICAgICAgICB3OiBzdGFnZS5jb250ZW50UmVjdC53ICsgbWlkZGxlLncgLSBzdGFnZS5zdHJldGNoUmVjdC53LFxuICAgICAgICBoOiBzdGFnZS5jb250ZW50UmVjdC5oICsgbWlkZGxlLmggLSBzdGFnZS5zdHJldGNoUmVjdC5oXG4gICAgICB9LFxuICAgICAgb3B0aWNhbEJvdW5kc1JlY3Q6IHtcbiAgICAgICAgeDogc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QueCxcbiAgICAgICAgeTogc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QueSxcbiAgICAgICAgdzogc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QudyArIG1pZGRsZS53IC0gc3RhZ2Uuc3RyZXRjaFJlY3QudyxcbiAgICAgICAgaDogc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QuaCArIG1pZGRsZS5oIC0gc3RhZ2Uuc3RyZXRjaFJlY3QuaFxuICAgICAgfVxuICAgIH07XG5cbiAgICBzdGFnZS5uYW1lID0gYCR7c3RhZ2UubmFtZX0tU1RSRVRDSF9UUklNTUVEYDtcbiAgICBzdGFnZS5sb2FkU291cmNlSW1hZ2UoY3R4LCByZWN0cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBnaXZlbiByZWdpb24uXG4gICAqXG4gICAqIFJlZ2lvbiBzaG91bGQgYmUgb25lIG9mICdzdHJldGNoJywgJ3BhZGRpbmcnLCBvciAnb3B0aWNhbGJvdW5kcydcbiAgICovXG4gIGRldGVjdFJlZ2lvbihzdGFnZSwgcmVnaW9uVG9GaW5kKSB7XG4gICAgaWYgKCFzdGFnZS5zcmNDdHgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHNyY0RhdGEgPSBzdGFnZS5zcmNDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHN0YWdlLnNyY1NpemUudywgc3RhZ2Uuc3JjU2l6ZS5oKTtcblxuICAgIGxldCB4LCB5O1xuXG4gICAgLy8gRmlyc3QgZmluZCBvcHRpY2FsIGJvdW5kc1xuICAgIC8vIFRoaXMgd29ya3MgYnkgdGFraW5nIGFuIGFscGhhIHZhbHVlIGhpc3RvZ3JhbSBhbmQgZmluZGluZyB0d28gbWF4aW1hIHRvIGRldGVybWluZVxuICAgIC8vIGxvdyBhbmQgaGlnaCBhbHBoYXMuXG4gICAgbGV0IGFscGhhSGlzdG9ncmFtID0gW107XG4gICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgICAgbGV0IGFscGhhID0gc3JjRGF0YS5kYXRhWyh5ICogc3RhZ2Uuc3JjU2l6ZS53ICsgeCkgKiA0ICsgM107XG4gICAgICAgIGFscGhhSGlzdG9ncmFtW2FscGhhXSA9IGFscGhhSGlzdG9ncmFtW2FscGhhXSA/IGFscGhhSGlzdG9ncmFtW2FscGhhXSArIDEgOiAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtYXgxID0gMCwgbWF4MUZyZXEgPSAwLCBtYXgyID0gMCwgbWF4MkZyZXEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChhbHBoYUhpc3RvZ3JhbVtpXSA+IG1heDFGcmVxKSB7XG4gICAgICAgIG1heDIgPSBtYXgxO1xuICAgICAgICBtYXgyRnJlcSA9IG1heDFGcmVxO1xuICAgICAgICBtYXgxID0gaTtcbiAgICAgICAgbWF4MUZyZXEgPSBhbHBoYUhpc3RvZ3JhbVtpXTtcbiAgICAgIH0gZWxzZSBpZiAoYWxwaGFIaXN0b2dyYW1baV0gPiBtYXgyRnJlcSkge1xuICAgICAgICBtYXgyID0gaTtcbiAgICAgICAgbWF4MkZyZXEgPSBhbHBoYUhpc3RvZ3JhbVtpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYWxwaGFNaW4gPSAobWF4MSA8IG1heDIpID8gbWF4MSA6IG1heDI7XG4gICAgbGV0IGFscGhhTWF4ID0gKG1heDEgPiBtYXgyKSA/IG1heDEgOiBtYXgyO1xuXG4gICAgY29uc3QgQUxQSEFfVEhSRVNIT0xEID0gNTtcblxuICAgIHZhciBvcHRpY2FsQm91bmRzUmVjdCA9IHtsOi0xLCByOi0xLCB0Oi0xLCBiOi0xfTtcblxuICAgIC8vIEZpbmQgbGVmdCBvcHRpY2FsIGJvdW5kXG4gICAgb2JyTGVmdDpcbiAgICBmb3IgKHggPSAwOyB4IDwgc3RhZ2Uuc3JjU2l6ZS53OyB4KyspIHtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgICB2YXIgYWxwaGEgPSBzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAzXTtcbiAgICAgICAgaWYgKGFscGhhID49IGFscGhhTWF4IC0gQUxQSEFfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgb3B0aWNhbEJvdW5kc1JlY3QubCA9IHg7XG4gICAgICAgICAgYnJlYWsgb2JyTGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIHJpZ2h0IG9wdGljYWwgYm91bmRcbiAgICBvYnJSaWdodDpcbiAgICBmb3IgKHggPSBzdGFnZS5zcmNTaXplLncgLSAxOyB4ID49IDA7IHgtLSkge1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHN0YWdlLnNyY1NpemUuaDsgeSsrKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDNdO1xuICAgICAgICBpZiAoYWxwaGEgPj0gYWxwaGFNYXggLSBBTFBIQV9USFJFU0hPTEQpIHtcbiAgICAgICAgICBvcHRpY2FsQm91bmRzUmVjdC5yID0geDtcbiAgICAgICAgICBicmVhayBvYnJSaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIHRvcCBvcHRpY2FsIGJvdW5kXG4gICAgb2JyVG9wOlxuICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDNdO1xuICAgICAgICBpZiAoYWxwaGEgPj0gYWxwaGFNYXggLSBBTFBIQV9USFJFU0hPTEQpIHtcbiAgICAgICAgICBvcHRpY2FsQm91bmRzUmVjdC50ID0geTtcbiAgICAgICAgICBicmVhayBvYnJUb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBib3R0b20gb3B0aWNhbCBib3VuZFxuICAgIG9ickJvdHRvbTpcbiAgICBmb3IgKHkgPSBzdGFnZS5zcmNTaXplLmggLSAxOyB5ID49IDA7IHktLSkge1xuICAgICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICAgIGxldCBhbHBoYSA9IHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDNdO1xuICAgICAgICBpZiAoYWxwaGEgPj0gYWxwaGFNYXggLSBBTFBIQV9USFJFU0hPTEQpIHtcbiAgICAgICAgICBvcHRpY2FsQm91bmRzUmVjdC5iID0geTtcbiAgICAgICAgICBicmVhayBvYnJCb3R0b207XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmV0dXJuUmVjdDtcblxuICAgIGlmIChvcHRpY2FsQm91bmRzUmVjdC5sID49IDAgJiYgb3B0aWNhbEJvdW5kc1JlY3QuciA+IG9wdGljYWxCb3VuZHNSZWN0LmxcbiAgICAgICAgJiYgb3B0aWNhbEJvdW5kc1JlY3QudCA+PSAwICYmIG9wdGljYWxCb3VuZHNSZWN0LmIgPiBvcHRpY2FsQm91bmRzUmVjdC50KSB7XG4gICAgICBsZXQgcmVjdCA9IHtcbiAgICAgICAgeDogb3B0aWNhbEJvdW5kc1JlY3QubCxcbiAgICAgICAgeTogb3B0aWNhbEJvdW5kc1JlY3QudCxcbiAgICAgICAgdzogb3B0aWNhbEJvdW5kc1JlY3QuciAtIG9wdGljYWxCb3VuZHNSZWN0LmwgKyAxLFxuICAgICAgICBoOiBvcHRpY2FsQm91bmRzUmVjdC5iIC0gb3B0aWNhbEJvdW5kc1JlY3QudCArIDFcbiAgICAgIH07XG5cbiAgICAgIGlmIChyZWdpb25Ub0ZpbmQgPT0gJ29wdGljYWxib3VuZHMnIHx8IHJlZ2lvblRvRmluZCA9PSAncGFkZGluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTmV4dCBmaW5kIHN0cmV0Y2ggcmVnaW9ucy4gT25seSB1c2UgdGhlbSBpZiB0aGV5J3JlIHdpdGhpbiB0aGUgb3B0aWNhbCBib3VuZHNcbiAgICBpZiAocmVnaW9uVG9GaW5kID09ICdzdHJldGNoJykge1xuICAgICAgbGV0IG5ld1N0cmV0Y2hSZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhZ2Uuc3RyZXRjaFJlY3QpO1xuXG4gICAgICBjb25zdCBzdW1tZXIgPSBuZXcgU3VtbWVyKCk7XG4gICAgICBsZXQgc3VtcyA9IFtdO1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHN0YWdlLnNyY1NpemUuaDsgeSsrKSB7XG4gICAgICAgIC8vIENvbXB1dGUgcm93XG4gICAgICAgIHN1bW1lci5yZXNldCgpO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICAgICAgc3VtbWVyLmFkZE5leHQoZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vtcy5wdXNoKHN1bW1lci5jb21wdXRlKCkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmFuZ2VzID0gZ2V0RXF1YWxSYW5nZXNfKHN1bXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICBsZXQgcGFzc2VzVGhyZXNob2xkID0gZmFsc2U7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcm93IGhhcyBhIG1pbmltdW0gYWxwaGFcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gc3JjRGF0YS5kYXRhWyhyYW5nZS5zdGFydCAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDNdO1xuICAgICAgICAgIGlmIChhbHBoYSA+PSBhbHBoYU1heCAtIEFMUEhBX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgcGFzc2VzVGhyZXNob2xkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFzc2VzVGhyZXNob2xkKSB7XG4gICAgICAgICAgbmV3U3RyZXRjaFJlY3QueSA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgIG5ld1N0cmV0Y2hSZWN0LmggPSByYW5nZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAvLyBpbnNldCBhIGJpdCB0byBwcmV2ZW50IHNjYWxpbmcgYXJ0aWZhY3RzXG4gICAgICAgICAgICBuZXdTdHJldGNoUmVjdC55Kys7XG4gICAgICAgICAgICBuZXdTdHJldGNoUmVjdC5oIC09IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN1bW1lci5yZXNldCgpO1xuICAgICAgc3VtcyA9IFtdO1xuICAgICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICAgIC8vIENvbXB1dGUgY29sdW1uXG4gICAgICAgIHN1bW1lci5yZXNldCgpO1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgICAgICBzdW1tZXIuYWRkTmV4dChnZXRQaXhlbF8oc3RhZ2UsIHNyY0RhdGEsIHgsIHkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdW1zLnB1c2goc3VtbWVyLmNvbXB1dGUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJhbmdlcyA9IGdldEVxdWFsUmFuZ2VzXyhzdW1zKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbGV0IHBhc3Nlc1RocmVzaG9sZCA9IGZhbHNlO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNvbHVtbiBoYXMgYSBtaW5pbXVtIGFscGhhXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgICAgIGxldCBhbHBoYSA9IHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHJhbmdlLnN0YXJ0KSAqIDQgKyAzXTtcbiAgICAgICAgICBpZiAoYWxwaGEgPj0gYWxwaGFNYXggLSBBTFBIQV9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIHBhc3Nlc1RocmVzaG9sZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFzc2VzVGhyZXNob2xkKSB7XG4gICAgICAgICAgbmV3U3RyZXRjaFJlY3QueCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgIG5ld1N0cmV0Y2hSZWN0LncgPSByYW5nZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAvLyBpbnNldCBhIGJpdCB0byBwcmV2ZW50IHNjYWxpbmcgYXJ0aWZhY3RzXG4gICAgICAgICAgICBuZXdTdHJldGNoUmVjdC54Kys7XG4gICAgICAgICAgICBuZXdTdHJldGNoUmVjdC53IC09IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdHJldGNoUmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbn07XG5cblxuZnVuY3Rpb24gZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCB4LCB5KSB7XG4gIHJldHVybiAoc3JjRGF0YS5kYXRhWyh5ICogc3RhZ2Uuc3JjU2l6ZS53ICsgeCkgKiA0ICsgMF0gPDwgMTYpIC8vIHJcbiAgICAgICsgKHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDFdIDw8IDgpIC8vIGdcbiAgICAgICsgKHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDJdIDw8IDApIC8vIGJcbiAgICAgICsgKHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDNdIDw8IDI0KTsgLy8gYVxufVxuXG5cbmZ1bmN0aW9uIGNvbnN0cmFpbl8oc2l6ZSwgcmVjdCkge1xuICBpZiAocmVjdC54IDwgMCkge1xuICAgIHJlY3QudyArPSByZWN0Lng7XG4gICAgcmVjdC54ICs9IC1yZWN0Lng7XG4gIH1cbiAgaWYgKHJlY3QueCArIHJlY3QudyA+IHNpemUudykge1xuICAgIHJlY3QudyA9IHNpemUudyAtIHJlY3QueDtcbiAgfVxuICBpZiAocmVjdC55IDwgMCkge1xuICAgIHJlY3QuaCArPSByZWN0Lnk7XG4gICAgcmVjdC55ICs9IC1yZWN0Lnk7XG4gIH1cbiAgaWYgKHJlY3QueSArIHJlY3QuaCA+IHNpemUuaCkge1xuICAgIHJlY3QuaCA9IHNpemUuaCAtIHJlY3QueTtcbiAgfVxuICByZXR1cm4gcmVjdDtcbn1cblxuLy8gRmluZHMgcmFuZ2VzIG9mIGVxdWFsIHZhbHVlcyB3aXRoaW4gYW4gYXJyYXlcbmZ1bmN0aW9uIGdldEVxdWFsUmFuZ2VzXyhhcnIpIHtcbiAgdmFyIGVxdWFsUmFuZ2VzID0gW107XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgc3RhcnRWYWwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICAgIHN0YXJ0VmFsID0gYXJyW2ldO1xuICAgIH0gZWxzZSBpZiAoYXJyW2ldICE9IHN0YXJ0VmFsKSB7XG4gICAgICBpZiAoc3RhcnQgIT0gaSAtIDEpIHtcbiAgICAgICAgZXF1YWxSYW5nZXMucHVzaCh7c3RhcnQ6IHN0YXJ0LCBsZW5ndGg6IGkgLSBzdGFydH0pO1xuICAgICAgfVxuXG4gICAgICBzdGFydCA9IGk7XG4gICAgICBzdGFydFZhbCA9IGFycltpXTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0ICE9IGFyci5sZW5ndGggLSAxKSB7XG4gICAgZXF1YWxSYW5nZXMucHVzaCh7c3RhcnQ6IHN0YXJ0LCBsZW5ndGg6IGFyci5sZW5ndGggLSBzdGFydH0pO1xuICB9XG4gIHJldHVybiBlcXVhbFJhbmdlcy5zb3J0KGZ1bmN0aW9uKHgsIHkpeyByZXR1cm4geS5sZW5ndGggLSB4Lmxlbmd0aDsgfSk7XG59IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWRsZXIzMlxuY29uc3QgTU9EX0FETEVSID0gNjU1MjE7XG5cbmNsYXNzIEFkbGVyMzIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl9hID0gMTtcbiAgICB0aGlzLl9iID0gMDtcbiAgICB0aGlzLl9pbmRleCA9IDA7XG4gIH1cblxuICBhZGROZXh0KHZhbHVlKSB7XG4gICAgdGhpcy5fYSA9ICh0aGlzLl9hICsgdmFsdWUpICUgTU9EX0FETEVSO1xuICAgIHRoaXMuX2IgPSAodGhpcy5fYiArIHRoaXMuX2EpICUgTU9EX0FETEVSO1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2IgPDwgMTYpIHwgdGhpcy5fYTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU3VtbWVyID0gQWRsZXIzMjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge3N0dWRpb30gZnJvbSAnLi4vc3R1ZGlvJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uL2ltYWdlbGliJztcbmltcG9ydCB7QmFzZUdlbmVyYXRvcn0gZnJvbSAnLi9iYXNlZ2VuZXJhdG9yJztcblxuY29uc3QgSUNPTl9TSVpFID0ge3c6IDI0LCBoOiAyNH07XG5jb25zdCBUQVJHRVRfUkVDVCA9IHt4OiAxLCB5OiAxLCB3OiAyMiwgaDogMjJ9O1xuXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uSWNvbkdlbmVyYXRvciBleHRlbmRzIEJhc2VHZW5lcmF0b3Ige1xuICBzZXR1cEZvcm0oKSB7XG4gICAgc3VwZXIuc2V0dXBGb3JtKCk7XG4gICAgJCgnLm91dHB1dHMtcGFuZWwnKS5hdHRyKCdkYXRhLXRoZW1lJywgJ2RhcmsnKTtcblxuICAgIGxldCBuYW1lRmllbGQ7XG4gICAgdGhpcy5mb3JtID0gbmV3IHN0dWRpby5Gb3JtKHtcbiAgICAgIGlkOiAnaWNvbmZvcm0nLFxuICAgICAgY29udGFpbmVyOiAnI2lucHV0cy1mb3JtJyxcbiAgICAgIGZpZWxkczogW1xuICAgICAgICBuZXcgc3R1ZGlvLkltYWdlRmllbGQoJ3NvdXJjZScsIHtcbiAgICAgICAgICB0aXRsZTogJ1NvdXJjZScsXG4gICAgICAgICAgaGVscFRleHQ6ICdNdXN0IGJlIHRyYW5zcGFyZW50JyxcbiAgICAgICAgICBtYXhGaW5hbFNpemU6IHsgdzogMTI4LCBoOiAxMjggfSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWVDbGlwYXJ0OiAnYWNfdW5pdCcsXG4gICAgICAgICAgZHJvcFRhcmdldDogZG9jdW1lbnQuYm9keVxuICAgICAgICB9KSxcbiAgICAgICAgKG5hbWVGaWVsZCA9IG5ldyBzdHVkaW8uVGV4dEZpZWxkKCduYW1lJywge1xuICAgICAgICAgIG5ld0dyb3VwOiB0cnVlLFxuICAgICAgICAgIHRpdGxlOiAnTmFtZScsXG4gICAgICAgICAgaGVscFRleHQ6ICdVc2VkIHdoZW4gZ2VuZXJhdGluZyBaSVAgZmlsZXMuJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdpY19zdGF0X2V4YW1wbGUnXG4gICAgICAgIH0pKVxuICAgICAgXVxuICAgIH0pO1xuICAgIHRoaXMuZm9ybS5vbkNoYW5nZShmaWVsZCA9PiB7XG4gICAgICBsZXQgdmFsdWVzID0gdGhpcy5mb3JtLmdldFZhbHVlcygpO1xuICAgICAgaWYgKCghZmllbGQgfHwgZmllbGQuaWRfID09ICdzb3VyY2UnKVxuICAgICAgICAgICYmIHZhbHVlcy5zb3VyY2UgJiYgdmFsdWVzLnNvdXJjZS5uYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gJ2ljX3N0YXRfJyArIHN0dWRpby5VdGlsLnNhbml0aXplUmVzb3VyY2VOYW1lKHZhbHVlcy5zb3VyY2UubmFtZSk7XG4gICAgICAgIGlmIChuYW1lICE9IG5hbWVGaWVsZC5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgbmFtZUZpZWxkLnNldFZhbHVlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVnZW5lcmF0ZURlYm91bmNlZF8oKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlZ2VuZXJhdGUoKSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcblxuICAgIHRoaXMuemlwcGVyLmNsZWFyKCk7XG4gICAgdGhpcy56aXBwZXIuc2V0WmlwRmlsZW5hbWUoYCR7dmFsdWVzLm5hbWV9LnppcGApO1xuXG4gICAgdGhpcy5kZW5zaXRpZXMuZm9yRWFjaChkZW5zaXR5ID0+IHtcbiAgICAgIGxldCBtdWx0ID0gc3R1ZGlvLlV0aWwuZ2V0TXVsdEJhc2VNZHBpKGRlbnNpdHkpO1xuICAgICAgbGV0IGljb25TaXplID0gc3R1ZGlvLlV0aWwubXVsdFJvdW5kKElDT05fU0laRSwgbXVsdCk7XG5cbiAgICAgIGxldCBvdXRDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuICAgICAgbGV0IHRtcEN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChpY29uU2l6ZSk7XG5cbiAgICAgIGlmICh2YWx1ZXMuc291cmNlLmN0eCkge1xuICAgICAgICBsZXQgc3JjQ3R4ID0gdmFsdWVzLnNvdXJjZS5jdHg7XG4gICAgICAgIGltYWdlbGliLkRyYXdpbmcuZHJhd0NlbnRlckluc2lkZShcbiAgICAgICAgICAgIHRtcEN0eCxcbiAgICAgICAgICAgIHNyY0N0eCxcbiAgICAgICAgICAgIHN0dWRpby5VdGlsLm11bHQoVEFSR0VUX1JFQ1QsIG11bHQpLFxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHc6IHNyY0N0eC5jYW52YXMud2lkdGgsIGg6IHNyY0N0eC5jYW52YXMuaGVpZ2h0fSk7XG4gICAgICB9XG5cbiAgICAgIGltYWdlbGliLkVmZmVjdHMuZngoW1xuICAgICAgICB7ZWZmZWN0OiAnZmlsbC1jb2xvcicsIGNvbG9yOiAnI2ZmZid9XG4gICAgICBdLCBvdXRDdHgsIHRtcEN0eCwgaWNvblNpemUpO1xuXG4gICAgICB0aGlzLnppcHBlci5hZGQoe1xuICAgICAgICBuYW1lOiBgcmVzL2RyYXdhYmxlLSR7ZGVuc2l0eX0vJHt2YWx1ZXMubmFtZX0ucG5nYCxcbiAgICAgICAgY2FudmFzOiBvdXRDdHguY2FudmFzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zZXRJbWFnZUZvclNsb3RfKGRlbnNpdHksIG91dEN0eC5jYW52YXMudG9EYXRhVVJMKCkpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtkZWZhdWx0IGFzIHRpbnljb2xvcn0gZnJvbSAndGlueWNvbG9yMic7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZvcm0gZmllbGQgYW5kIGl0cyBhc3NvY2lhdGVkIFVJIGVsZW1lbnRzLiBUaGlzIHNob3VsZCBiZVxuICogYnJva2VuIG91dCBpbnRvIGEgbW9yZSBNVkMtbGlrZSBhcmNoaXRlY3R1cmUgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpZWxkIHtcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhIG5ldyBmaWVsZCB3aXRoIHRoZSBnaXZlbiBJRCBhbmQgcGFyYW1ldGVycy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpZCwgcGFyYW1zKSB7XG4gICAgdGhpcy5pZF8gPSBpZDtcbiAgICB0aGlzLnBhcmFtc18gPSBwYXJhbXM7XG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZm9ybSBvd25lciBvZiB0aGUgZmllbGQuIEludGVybmFsbHkgY2FsbGVkIGJ5XG4gICAqIHtAbGluayBzdHVkaW8uZm9ybXMuRm9ybX0uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3R1ZGlvLmZvcm1zLkZvcm19IGZvcm0gVGhlIG93bmVyIGZvcm0uXG4gICAqL1xuICBzZXRGb3JtXyhmb3JtKSB7XG4gICAgdGhpcy5mb3JtXyA9IGZvcm07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvbXBsZXRlIElELlxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICovXG4gIGdldExvbmdJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtXy5pZF8gKyAnLScgKyB0aGlzLmlkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBJRCBmb3IgdGhlIGZvcm0ncyBVSSBlbGVtZW50IChvciBjb250YWluZXIpLlxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICovXG4gIGdldEh0bWxJZCgpIHtcbiAgICByZXR1cm4gJ19mcm0tJyArIHRoaXMuZ2V0TG9uZ0lkKCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBVSSBlbGVtZW50cyBmb3IgYSBmb3JtIGZpZWxkIGNvbnRhaW5lci4gTm90IHZlcnkgcG9ydGFibGVcbiAgICogb3V0c2lkZSB0aGUgQXNzZXQgU3R1ZGlvIFVJLiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZW4gYnkgZGVzY2VuZGVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgZGVzdGluYXRpb24gZWxlbWVudCB0byBjb250YWluIHRoZVxuICAgKiBmaWVsZC5cbiAgICovXG4gIGNyZWF0ZVVpKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lciA9ICQoY29udGFpbmVyKTtcbiAgICB0aGlzLmJhc2VFbF8gPSAkKCc8ZGl2PicpXG4gICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1vdXRlcicpXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLnBhcmFtc18ubmV3R3JvdXAgPyAnaXMtbmV3LWdyb3VwJyA6ICcnKVxuICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICQoJzxsYWJlbD4nKVxuICAgICAgICAgICAgLmF0dHIoJ2ZvcicsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgICAgICAudGV4dCh0aGlzLnBhcmFtc18udGl0bGUpXG4gICAgICAgICAgICAuYXBwZW5kKCQoJzxkaXY+JylcbiAgICAgICAgICAgICAgLmFkZENsYXNzKCdmb3JtLWZpZWxkLWhlbHAtdGV4dCcpXG4gICAgICAgICAgICAgIC5jc3MoJ2Rpc3BsYXknLCB0aGlzLnBhcmFtc18uaGVscFRleHQgPyAnJyA6ICdub25lJylcbiAgICAgICAgICAgICAgLmh0bWwodGhpcy5wYXJhbXNfLmhlbHBUZXh0KSlcbiAgICAgICAgKVxuICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICQoJzxkaXY+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1jb250YWluZXInKVxuICAgICAgICApXG4gICAgICAgIC5hcHBlbmRUbyhjb250YWluZXIpO1xuICAgIHJldHVybiB0aGlzLmJhc2VFbF87XG4gIH1cblxuICBnZXRFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZvcm0gZmllbGQuXG4gICAqL1xuICBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gZW5hYmxlZDtcbiAgICBpZiAodGhpcy5iYXNlRWxfKSB7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmJhc2VFbF8ucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFzZUVsXy5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBUZXh0RmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gIGNyZWF0ZVVpKGNvbnRhaW5lcikge1xuICAgIHZhciBmaWVsZENvbnRhaW5lciA9ICQoJy5mb3JtLWZpZWxkLWNvbnRhaW5lcicsIHN1cGVyLmNyZWF0ZVVpKGNvbnRhaW5lcikpO1xuXG4gICAgdGhpcy5lbF8gPSAkKCc8aW5wdXQ+JylcbiAgICAgICAgLmF0dHIoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIC5hdHRyKCdwbGFjZWhvbGRlcicsIHRoaXMucGFyYW1zXy5wbGFjZWhvbGRlcilcbiAgICAgICAgLmFkZENsYXNzKCdmb3JtLWZpZWxkLXRleHQnKVxuICAgICAgICAudmFsKHRoaXMuZ2V0VmFsdWUoKSlcbiAgICAgICAgLm9uKCdpbnB1dCcsIGV2ID0+IHtcbiAgICAgICAgICB2YXIgb2xkVmFsID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHZhciBuZXdWYWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpLnZhbCgpO1xuICAgICAgICAgIGlmIChvbGRWYWwgIT0gbmV3VmFsKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKG5ld1ZhbCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuYXBwZW5kVG8oZmllbGRDb250YWluZXIpO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcmFtc18uZGVmYXVsdFZhbHVlIHx8ICcnO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBzZXRWYWx1ZSh2YWwsIHBhdXNlVWkpIHtcbiAgICB0aGlzLnZhbHVlXyA9IHZhbDtcbiAgICBpZiAoIXBhdXNlVWkpIHtcbiAgICAgIHRoaXMuZWxfLnZhbCh2YWwpO1xuICAgIH1cbiAgICB0aGlzLmZvcm1fLm5vdGlmeUNoYW5nZWRfKHRoaXMpO1xuICB9XG5cbiAgc2VyaWFsaXplVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIGRlc2VyaWFsaXplVmFsdWUocykge1xuICAgIHRoaXMuc2V0VmFsdWUocyk7XG4gIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgQXV0b2NvbXBsZXRlVGV4dEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICBjcmVhdGVVaShjb250YWluZXIpIHtcbiAgICB2YXIgZmllbGRDb250YWluZXIgPSAkKCcuZm9ybS1maWVsZC1jb250YWluZXInLCBzdXBlci5jcmVhdGVVaShjb250YWluZXIpKTtcblxuICAgIHZhciBkYXRhbGlzdElkID0gdGhpcy5nZXRIdG1sSWQoKSArICctZGF0YWxpc3QnO1xuXG4gICAgdGhpcy5lbF8gPSAkKCc8aW5wdXQ+JylcbiAgICAgICAgLmF0dHIoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIC5hdHRyKCdwbGFjZWhvbGRlcicsIHRoaXMucGFyYW1zXy5wbGFjZWhvbGRlcilcbiAgICAgICAgLmFkZENsYXNzKCdmb3JtLWZpZWxkLXRleHQnKVxuICAgICAgICAuYXR0cignbGlzdCcsIGRhdGFsaXN0SWQpXG4gICAgICAgIC52YWwodGhpcy5nZXRWYWx1ZSgpKVxuICAgICAgICAub24oJ2lucHV0JywgZXYgPT4gdGhpcy5zZXRWYWx1ZSgkKGV2LmN1cnJlbnRUYXJnZXQpLnZhbCgpLCB0cnVlKSlcbiAgICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcblxuICAgIHRoaXMuZGF0YWxpc3RFbF8gPSAkKCc8ZGF0YWxpc3Q+JylcbiAgICAgICAgLmF0dHIoJ2lkJywgZGF0YWxpc3RJZClcbiAgICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyh0aGlzLnBhcmFtc18ub3B0aW9ucyk7XG4gIH1cblxuICBzZXRPcHRpb25zKG9wdGlvbnMgPSBbXSkge1xuICAgIHRoaXMuZGF0YWxpc3RFbF8uZW1wdHkoKTtcbiAgICBvcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHRoaXMuZGF0YWxpc3RFbF8uYXBwZW5kKCQoJzxvcHRpb24+JykuYXR0cigndmFsdWUnLCBvcHRpb24pKSk7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWUgfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbCwgcGF1c2VVaSkge1xuICAgIHRoaXMudmFsdWVfID0gdmFsO1xuICAgIGlmICghcGF1c2VVaSkge1xuICAgICAgJCh0aGlzLmVsXykudmFsKHZhbCk7XG4gICAgfVxuICAgIHRoaXMuZm9ybV8ubm90aWZ5Q2hhbmdlZF8odGhpcyk7XG4gIH1cblxuICBzZXJpYWxpemVWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgZGVzZXJpYWxpemVWYWx1ZShzKSB7XG4gICAgdGhpcy5zZXRWYWx1ZShzKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBDb2xvckZpZWxkIGV4dGVuZHMgRmllbGQge1xuICBjcmVhdGVVaShjb250YWluZXIpIHtcbiAgICB2YXIgZmllbGRDb250YWluZXIgPSAkKCcuZm9ybS1maWVsZC1jb250YWluZXInLCBzdXBlci5jcmVhdGVVaShjb250YWluZXIpKTtcblxuICAgIHRoaXMuZWxfID0gJCgnPGlucHV0PicpXG4gICAgICAgIC5hdHRyKCd0eXBlJywgJ3RleHQnKVxuICAgICAgICAuYXR0cignaWQnLCB0aGlzLmdldEh0bWxJZCgpKVxuICAgICAgICAuYXBwZW5kVG8oZmllbGRDb250YWluZXIpO1xuXG4gICAgbGV0IHVwZGF0ZV8gPSBjb2xvciA9PiB0aGlzLnNldFZhbHVlKGNvbG9yLCB0cnVlKTtcblxuICAgIHRoaXMuZWxfLnNwZWN0cnVtKHtcbiAgICAgIGNvbG9yOiB0aGlzLmdldFZhbHVlKCkudG9SZ2JTdHJpbmcoKSxcbiAgICAgIHNob3dJbnB1dDogdHJ1ZSxcbiAgICAgIHNob3dQYWxldHRlOiB0cnVlLFxuICAgICAgc2hvd0FscGhhOiB0aGlzLnBhcmFtc18uYWxwaGEsXG4gICAgICBwcmVmZXJyZWRGb3JtYXQ6ICdoZXgnLFxuICAgICAgcGFsZXR0ZTogW1xuICAgICAgICBbJyNmZmZmZmYnLCAnIzAwMDAwMCddLFxuICAgICAgICBbJyNmNDQzMzYnLCAnI2U5MWU2MyddLFxuICAgICAgICBbJyM5YzI3YjAnLCAnIzY3M2FiNyddLFxuICAgICAgICBbJyMzZjUxYjUnLCAnIzIxOTZmMyddLFxuICAgICAgICBbJyMwM2E5ZjQnLCAnIzAwYmNkNCddLFxuICAgICAgICBbJyMwMDk2ODgnLCAnIzRjYWY1MCddLFxuICAgICAgICBbJyM4YmMzNGEnLCAnI2NkZGMzOSddLFxuICAgICAgICBbJyNmZmViM2InLCAnI2ZmYzEwNyddLFxuICAgICAgICBbJyNmZjk4MDAnLCAnI2ZmNTcyMiddLFxuICAgICAgICBbJyM5ZTllOWUnLCAnIzYwN2Q4YiddXG4gICAgICBdLFxuICAgICAgbG9jYWxTdG9yYWdlS2V5OiAncmVjZW50Y29sb3JzJyxcbiAgICAgIHNob3dJbml0aWFsOiB0cnVlLFxuICAgICAgc2hvd0J1dHRvbnM6IGZhbHNlLFxuICAgICAgY2hhbmdlOiB1cGRhdGVfLFxuICAgICAgbW92ZTogdXBkYXRlX1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVfIHx8IHRpbnljb2xvcih0aGlzLnBhcmFtc18uZGVmYXVsdFZhbHVlIHx8ICcjMDAwJyk7XG4gIH1cblxuICBzZXRWYWx1ZSh2YWwsIHBhdXNlVWkpIHtcbiAgICB0aGlzLnZhbHVlXyA9ICh2YWwuaGFzT3duUHJvcGVydHkoJ19yJykpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogdGlueWNvbG9yKHZhbCB8fCB0aGlzLnBhcmFtc18uZGVmYXVsdFZhbHVlIHx8ICcjMDAwJyk7XG4gICAgaWYgKCFwYXVzZVVpKSB7XG4gICAgICB0aGlzLmVsXy5zcGVjdHJ1bSgnc2V0JywgdGhpcy52YWx1ZV8udG9SZ2JTdHJpbmcoKSk7XG4gICAgfVxuICAgIHRoaXMuZm9ybV8ubm90aWZ5Q2hhbmdlZF8odGhpcyk7XG4gIH1cblxuICBzZXJpYWxpemVWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpLnRvUmdiU3RyaW5nKCk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKHMpIHtcbiAgICB0aGlzLnNldFZhbHVlKHMpO1xuICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIEVudW1GaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgY3JlYXRlVWkoY29udGFpbmVyKSB7XG4gICAgbGV0IGZpZWxkQ29udGFpbmVyID0gJCgnLmZvcm0tZmllbGQtY29udGFpbmVyJywgc3VwZXIuY3JlYXRlVWkoY29udGFpbmVyKSk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXNfLmJ1dHRvbnMpIHtcbiAgICAgIHRoaXMuZWxfID0gJCgnPGRpdj4nKVxuICAgICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgICAgLmFkZENsYXNzKCdmb3JtLWZpZWxkLWJ1dHRvbnNldCcpXG4gICAgICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXyA9ICQoJzxkaXY+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0tZmllbGQtc2VsZWN0JylcbiAgICAgICAgICAuYXR0cignaWQnLCB0aGlzLmdldEh0bWxJZCgpKVxuICAgICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICAgIHRoaXMuc2VsZWN0RWxfID0gJCgnPHNlbGVjdD4nKVxuICAgICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgICAgLm9uKCdpbnB1dCcsIGV2ID0+IHRoaXMuc2V0VmFsdWVJbnRlcm5hbF8oJChldi5jdXJyZW50VGFyZ2V0KS52YWwoKSwgdHJ1ZSkpXG4gICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldE9wdGlvbnModGhpcy5wYXJhbXNfLm9wdGlvbnMpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IChvcHRpb25zIHx8IFtdKS5tYXAob3B0aW9uID0+XG4gICAgICAgICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgPyB7aWQ6IG9wdGlvbiwgdGl0bGU6IFN0cmluZyhvcHRpb24pfVxuICAgICAgICAgICAgOiBvcHRpb24pO1xuXG4gICAgaWYgKHRoaXMucGFyYW1zXy5idXR0b25zKSB7XG4gICAgICB0aGlzLmVsXy5lbXB0eSgpO1xuICAgICAgKG9wdGlvbnMgfHwgW10pLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgJCgnPGlucHV0PicpXG4gICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0SHRtbElkKCksXG4gICAgICAgICAgICAgIGlkOiBgJHt0aGlzLmdldEh0bWxJZCgpfS0ke29wdGlvbi5pZH1gLFxuICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjaGFuZ2UnLCBldiA9PiB0aGlzLnNldFZhbHVlSW50ZXJuYWxfKCQoZXYuY3VycmVudFRhcmdldCkudmFsKCksIGZhbHNlKSlcbiAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsXyk7XG4gICAgICAgICQoJzxsYWJlbD4nKVxuICAgICAgICAgICAgLmF0dHIoJ2ZvcicsIGAke3RoaXMuZ2V0SHRtbElkKCl9LSR7b3B0aW9uLmlkfWApXG4gICAgICAgICAgICAuYXR0cigndGFiaW5kZXgnLCAwKVxuICAgICAgICAgICAgLmh0bWwob3B0aW9uLnRpdGxlKVxuICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdEVsXy5lbXB0eSgpO1xuICAgICAgKG9wdGlvbnMgfHwgW10pLmZvckVhY2gob3B0aW9uID0+XG4gICAgICAgICAgJCgnPG9wdGlvbj4nKVxuICAgICAgICAgICAgICAuYXR0cigndmFsdWUnLCBvcHRpb24uaWQpXG4gICAgICAgICAgICAgIC50ZXh0KG9wdGlvbi50aXRsZSlcbiAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuc2VsZWN0RWxfKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRWYWx1ZUludGVybmFsXyh0aGlzLmdldFZhbHVlKCkpO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJhbXNfLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucGFyYW1zXy5vcHRpb25zICYmIHRoaXMucGFyYW1zXy5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3RPcHRpb24gPSB0aGlzLnBhcmFtc18ub3B0aW9uc1swXTtcbiAgICAgICAgdmFsdWUgPSAoJ2lkJyBpbiBmaXJzdE9wdGlvbikgPyBmaXJzdE9wdGlvbi5pZCA6IFN0cmluZyhmaXJzdE9wdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbCwgcGF1c2VVaSkge1xuICAgIHRoaXMuc2V0VmFsdWVJbnRlcm5hbF8odmFsLCBwYXVzZVVpKTtcbiAgfVxuXG4gIHNldFZhbHVlSW50ZXJuYWxfKHZhbCwgcGF1c2VVaSkge1xuICAgIC8vIE5vdGUsIHRoaXMgbmVlZHMgdG8gYmUgaXRzIG93biBmdW5jdGlvbiBiZWNhdXNlIHNldFZhbHVlIGdldHNcbiAgICAvLyBvdmVycmlkZGVuIGluIEJvb2xlYW5GaWVsZCBhbmQgd2UgbmVlZCBhY2Nlc3MgdG8gdGhpcyBtZXRob2RcbiAgICAvLyBmcm9tIGNyZWF0ZVVpLlxuICAgIHRoaXMudmFsdWVfID0gdmFsO1xuICAgIGlmICghcGF1c2VVaSkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zXy5idXR0b25zKSB7XG4gICAgICAgIHRoaXMuZWxfLmZpbmQoJ2lucHV0JykuZWFjaCgoaSwgZWwpID0+XG4gICAgICAgICAgICAkKGVsKS5wcm9wKCdjaGVja2VkJywgJChlbCkudmFsKCkgPT0gdmFsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdEVsXy52YWwodmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mb3JtXy5ub3RpZnlDaGFuZ2VkXyh0aGlzKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKHMpIHtcbiAgICB0aGlzLnNldFZhbHVlKHMpO1xuICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIEJvb2xlYW5GaWVsZCBleHRlbmRzIEVudW1GaWVsZCB7XG4gIGNvbnN0cnVjdG9yKGlkLCBwYXJhbXMpIHtcbiAgICBzdXBlcihpZCwgcGFyYW1zKTtcbiAgICBwYXJhbXMub3B0aW9ucyA9IFtcbiAgICAgIHsgaWQ6ICcxJywgdGl0bGU6IHBhcmFtcy5vblRleHQgfHwgJ1llcycgfSxcbiAgICAgIHsgaWQ6ICcwJywgdGl0bGU6IHBhcmFtcy5vZmZUZXh0IHx8ICdObycgfVxuICAgIF07XG4gICAgcGFyYW1zLmRlZmF1bHRWYWx1ZSA9IHBhcmFtcy5kZWZhdWx0VmFsdWUgPyAnMScgOiAnMCc7XG4gICAgcGFyYW1zLmJ1dHRvbnMgPSB0cnVlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFZhbHVlKCkgPT0gJzEnO1xuICB9XG5cbiAgc2V0VmFsdWUodmFsLCBwYXVzZVVpKSB7XG4gICAgc3VwZXIuc2V0VmFsdWUodmFsID8gJzEnIDogJzAnLCBwYXVzZVVpKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCkgPyAnMScgOiAnMCc7XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKHMpIHtcbiAgICB0aGlzLnNldFZhbHVlKHMgPT0gJzEnKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBSYW5nZUZpZWxkIGV4dGVuZHMgRmllbGQge1xuICBjcmVhdGVVaShjb250YWluZXIpIHtcbiAgICB2YXIgZmllbGRDb250YWluZXIgPSAkKCcuZm9ybS1maWVsZC1jb250YWluZXInLCBzdXBlci5jcmVhdGVVaShjb250YWluZXIpKTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgdGhpcy5lbF8gPSAkKCc8ZGl2PicpXG4gICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1yYW5nZScpXG4gICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICB0aGlzLnJhbmdlRWxfID0gJCgnPGlucHV0PicpXG4gICAgICAgIC5hdHRyKCd0eXBlJywgJ3JhbmdlJylcbiAgICAgICAgLmF0dHIoJ21pbicsIHRoaXMucGFyYW1zXy5taW4gfHwgMClcbiAgICAgICAgLmF0dHIoJ21heCcsIHRoaXMucGFyYW1zXy5tYXggfHwgMTAwKVxuICAgICAgICAuYXR0cignc3RlcCcsIHRoaXMucGFyYW1zXy5zdGVwIHx8IDEpXG4gICAgICAgIC5vbignaW5wdXQnLCAoKSA9PiB0aGlzLnNldFZhbHVlKE51bWJlcih0aGlzLnJhbmdlRWxfLnZhbCgpKSB8fCAwLCB0cnVlKSlcbiAgICAgICAgLnZhbCh0aGlzLmdldFZhbHVlKCkpXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsXyk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXNfLnRleHRGbiB8fCB0aGlzLnBhcmFtc18uc2hvd1RleHQpIHtcbiAgICAgIHRoaXMucGFyYW1zXy50ZXh0Rm4gPSB0aGlzLnBhcmFtc18udGV4dEZuIHx8IChkID0+IGQpO1xuICAgICAgdGhpcy50ZXh0RWxfID0gJCgnPGRpdj4nKVxuICAgICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1yYW5nZS10ZXh0JylcbiAgICAgICAgICAudGV4dCh0aGlzLnBhcmFtc18udGV4dEZuKHRoaXMuZ2V0VmFsdWUoKSkpXG4gICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcbiAgICB9XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInKVxuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbCwgcGF1c2VVaSkge1xuICAgIHRoaXMudmFsdWVfID0gdmFsO1xuICAgIGlmICghcGF1c2VVaSkge1xuICAgICAgdGhpcy5yYW5nZUVsXy52YWwodmFsKTtcbiAgICB9XG5cdFx0aWYgKHRoaXMudGV4dEVsXykge1xuXHRcdCAgdGhpcy50ZXh0RWxfLnRleHQodGhpcy5wYXJhbXNfLnRleHRGbih2YWwpKTtcblx0ICB9XG5cdFx0dGhpcy5mb3JtXy5ub3RpZnlDaGFuZ2VkXyh0aGlzKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKHMpIHtcbiAgICB0aGlzLnNldFZhbHVlKE51bWJlcihzKSk7IC8vIGRvbid0IHVzZSBwYXJzZUludCBub3IgcGFyc2VGbG9hdFxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBkZWZpbmluZyBhIGRhdGEgZW50cnkgZm9ybSBmb3IgdXNlIGluIHRoZSBBc3NldCBTdHVkaW8uXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JtIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZm9ybSB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtcy5pbnB1dHNdIEEgbGlzdCBvZiBpbnB1dHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHRoaXMuaWRfID0gcGFyYW1zLmlkO1xuICAgIHRoaXMucGFyYW1zXyA9IHBhcmFtcztcbiAgICB0aGlzLmZpZWxkc18gPSBwYXJhbXMuZmllbGRzO1xuICAgIHRoaXMuZmllbGRzXy5mb3JFYWNoKGZpZWxkID0+IGZpZWxkLnNldEZvcm1fKHRoaXMpKTtcbiAgICB0aGlzLmZpZWxkc18uZm9yRWFjaChmaWVsZCA9PiBmaWVsZC5jcmVhdGVVaShwYXJhbXMuY29udGFpbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBvbmNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIG9uQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gKHRoaXMuY2hhbmdlTGlzdGVuZXJzXyB8fCBbXSkuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoYXQgdGhlIGZvcm0gY29udGVudHMgaGF2ZSBjaGFuZ2VkO1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm90aWZ5Q2hhbmdlZF8oZmllbGQpIHtcbiAgICBpZiAodGhpcy5wYXVzZU5vdGlmeV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKHRoaXMuY2hhbmdlTGlzdGVuZXJzXyB8fCBbXSkuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihmaWVsZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWVzIG9mIHRoZSBmb3JtIGZpZWxkcywgYXMgYW4gb2JqZWN0LlxuICAgKiBAdHlwZSBPYmplY3RcbiAgICovXG4gIGdldFZhbHVlcygpIHtcbiAgICBsZXQgdmFsdWVzID0ge307XG4gICAgdGhpcy5maWVsZHNfLmZvckVhY2goZmllbGQgPT4gdmFsdWVzW2ZpZWxkLmlkX10gPSBmaWVsZC5nZXRWYWx1ZSgpKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBzZXJpYWxpemVkIHZhbHVlcyBvZiB0aGUgZm9ybSBmaWVsZHMsIGFzIGFuIG9iamVjdC5cbiAgICogQWxsIHZhbHVlcyBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0IGFyZSBlaXRoZXIgc3RyaW5ncyBvciBvYmplY3RzLlxuICAgKiBAdHlwZSBPYmplY3RcbiAgICovXG4gIGdldFZhbHVlc1NlcmlhbGl6ZWQoKSB7XG4gICAgbGV0IHZhbHVlcyA9IHt9O1xuICAgIHRoaXMuZmllbGRzXy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGZpZWxkLnNlcmlhbGl6ZVZhbHVlID8gZmllbGQuc2VyaWFsaXplVmFsdWUoKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlc1tmaWVsZC5pZF9dID0gZmllbGQuc2VyaWFsaXplVmFsdWUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZm9ybSBmaWVsZCB2YWx1ZXMgZm9yIHRoZSBrZXkvdmFsdWUgcGFpcnMgaW4gdGhlIGdpdmVuIG9iamVjdC5cbiAgICogVmFsdWVzIG11c3QgYmUgc2VyaWFsaXplZCBmb3JtcyBvZiB0aGUgZm9ybSB2YWx1ZXMuIFRoZSBmb3JtIG11c3QgYmVcbiAgICogaW5pdGlhbGl6ZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAqL1xuICBzZXRWYWx1ZXNTZXJpYWxpemVkKHNlcmlhbGl6ZWRWYWx1ZXMpIHtcbiAgICB0aGlzLnBhdXNlTm90aWZ5XyA9IHRydWU7XG4gICAgdGhpcy5maWVsZHNfXG4gICAgICAgIC5maWx0ZXIoZmllbGQgPT4gZmllbGQuaWRfIGluIHNlcmlhbGl6ZWRWYWx1ZXMgJiYgZmllbGQuZGVzZXJpYWxpemVWYWx1ZSlcbiAgICAgICAgLmZvckVhY2goZmllbGQgPT4gZmllbGQuZGVzZXJpYWxpemVWYWx1ZShzZXJpYWxpemVkVmFsdWVzW2ZpZWxkLmlkX10pKTtcbiAgICB0aGlzLnBhdXNlTm90aWZ5XyA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5Q2hhbmdlZF8obnVsbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1V0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBjb25zdCBIYXNoID0ge1xuICBiaW5kRm9ybVRvRG9jdW1lbnRIYXNoKGZvcm0pIHtcbiAgICBpZiAodGhpcy5ib3VuZEZvcm1fKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdhbHJlYWR5IGJvdW5kIHRvIGEgZm9ybScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRGb3JtXyA9IGZvcm07XG5cbiAgICBmb3JtLm9uQ2hhbmdlKFV0aWwuZGVib3VuY2UoMTAwLCAoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRIYXNoXyA9IHBhcmFtc1RvSGFzaF8oZm9ybS5nZXRWYWx1ZXNTZXJpYWxpemVkKCkpO1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgJyMnICsgdGhpcy5jdXJyZW50SGFzaF8pO1xuICAgIH0pKTtcblxuICAgIGxldCBtYXliZVVwZGF0ZUhhc2hfID0gKCkgPT4ge1xuICAgICAgLy8gRG9uJ3QgdXNlIGRvY3VtZW50LmxvY2F0aW9uLmhhc2ggYmVjYXVzZSBpdCBhdXRvbWF0aWNhbGx5XG4gICAgICAvLyByZXNvbHZlcyBVUkktZXNjYXBlZCBlbnRpdGllcy5cbiAgICAgIGxldCBuZXdIYXNoID0gcGFyYW1zVG9IYXNoXyhoYXNoVG9QYXJhbXNfKFxuICAgICAgICAgIChkb2N1bWVudC5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jLiovKSB8fCBbJyddKVswXSkpO1xuICAgICAgaWYgKG5ld0hhc2ggIT0gdGhpcy5jdXJyZW50SGFzaF8pIHtcbiAgICAgICAgZm9ybS5zZXRWYWx1ZXNTZXJpYWxpemVkKGhhc2hUb1BhcmFtc18obmV3SGFzaCkpO1xuICAgICAgICB0aGlzLmN1cnJlbnRIYXNoXyA9IG5ld0hhc2g7XG4gICAgICB9XG4gICAgfTtcblxuICAgICQod2luZG93KS5vbignaGFzaGNoYW5nZScsIG1heWJlVXBkYXRlSGFzaF8pO1xuXG4gICAgbWF5YmVVcGRhdGVIYXNoXygpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBoYXNoVG9QYXJhbXNfKGhhc2gpIHtcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIGhhc2ggPSBoYXNoLnJlcGxhY2UoL15bPyNdLywgJycpO1xuXG4gIGhhc2guc3BsaXQoJyYnKS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBsZXQgW3BhdGgsIHZhbF0gPSBlbnRyeS5zcGxpdCgnPScsIDIpO1xuICAgIHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQocGF0aCB8fCAnJyk7XG4gICAgdmFsID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbCB8fCAnJyk7XG5cbiAgICAvLyBNb3N0IG9mIHRoZSB0aW1lIHBhdGggPT0ga2V5LCBidXQgZm9yIG9iamVjdHMgbGlrZSBhLmI9MSwgd2UgbmVlZCB0b1xuICAgIC8vIGRlc2NlbmQgaW50byB0aGUgaGllcmFjaHkuXG4gICAgbGV0IHBhdGhBcnIgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IG9iaiA9IHBhcmFtcztcbiAgICBwYXRoQXJyLnNsaWNlKDAsIC0xKS5mb3JFYWNoKHBhdGhQYXJ0ID0+IHtcbiAgICAgIG9ialtwYXRoUGFydF0gPSBvYmpbcGF0aFBhcnRdIHx8IHt9O1xuICAgICAgb2JqID0gb2JqW3BhdGhQYXJ0XTtcbiAgICB9KTtcbiAgICBsZXQga2V5ID0gcGF0aEFycltwYXRoQXJyLmxlbmd0aCAtIDFdO1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAvLyBIYW5kbGUgYXJyYXkgdmFsdWVzLlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gW29ialtrZXldLCB2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHBhcmFtc1RvSGFzaF8ocGFyYW1zLCBwcmVmaXgpIHtcbiAgY29uc3QgaGFzaEFyciA9IFtdO1xuICBjb25zdCBrZXlQYXRoXyA9IGsgPT4gZW5jb2RlVVJJQ29tcG9uZW50KChwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJykgKyBrKTtcbiAgY29uc3QgcHVzaEtleVZhbHVlXyA9IChrLCB2KSA9PiB7XG4gICAgaWYgKHYgPT09IGZhbHNlKSB2ID0gMDtcbiAgICBpZiAodiA9PT0gdHJ1ZSkgIHYgPSAxO1xuICAgIGhhc2hBcnIucHVzaChrZXlQYXRoXyhrKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2LnRvU3RyaW5nKCkpKTtcbiAgfTtcblxuICBmb3IgKGxldCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgbGV0IHZhbCA9IHBhcmFtc1trZXldO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKHYgPT4gcHVzaEtleVZhbHVlXyhrZXksIHYpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT0gJ29iamVjdCcpIHtcbiAgICAgIGhhc2hBcnIucHVzaChwYXJhbXNUb0hhc2hfKHZhbCwga2V5UGF0aF8oa2V5KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoS2V5VmFsdWVfKGtleSwgdmFsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGFzaEFyci5qb2luKCcmJyk7XG59IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjbGlwYXJ0TmFtZXMgPSBbXG4gICczZF9yb3RhdGlvbicsXG4gICdhY191bml0JyxcbiAgJ2FjY2Vzc19hbGFybScsXG4gICdhY2Nlc3NfYWxhcm1zJyxcbiAgJ2FjY2Vzc190aW1lJyxcbiAgJ2FjY2Vzc2liaWxpdHknLFxuICAnYWNjZXNzaWJsZScsXG4gICdhY2NvdW50X2JhbGFuY2UnLFxuICAnYWNjb3VudF9iYWxhbmNlX3dhbGxldCcsXG4gICdhY2NvdW50X2JveCcsXG4gICdhY2NvdW50X2NpcmNsZScsXG4gICdhZGInLFxuICAnYWRkJyxcbiAgJ2FkZF9hX3Bob3RvJyxcbiAgJ2FkZF9hbGFybScsXG4gICdhZGRfYWxlcnQnLFxuICAnYWRkX2JveCcsXG4gICdhZGRfY2lyY2xlJyxcbiAgJ2FkZF9jaXJjbGVfb3V0bGluZScsXG4gICdhZGRfbG9jYXRpb24nLFxuICAnYWRkX3Nob3BwaW5nX2NhcnQnLFxuICAnYWRkX3RvX3Bob3RvcycsXG4gICdhZGRfdG9fcXVldWUnLFxuICAnYWRqdXN0JyxcbiAgJ2FpcmxpbmVfc2VhdF9mbGF0JyxcbiAgJ2FpcmxpbmVfc2VhdF9mbGF0X2FuZ2xlZCcsXG4gICdhaXJsaW5lX3NlYXRfaW5kaXZpZHVhbF9zdWl0ZScsXG4gICdhaXJsaW5lX3NlYXRfbGVncm9vbV9leHRyYScsXG4gICdhaXJsaW5lX3NlYXRfbGVncm9vbV9ub3JtYWwnLFxuICAnYWlybGluZV9zZWF0X2xlZ3Jvb21fcmVkdWNlZCcsXG4gICdhaXJsaW5lX3NlYXRfcmVjbGluZV9leHRyYScsXG4gICdhaXJsaW5lX3NlYXRfcmVjbGluZV9ub3JtYWwnLFxuICAnYWlycGxhbmVtb2RlX2FjdGl2ZScsXG4gICdhaXJwbGFuZW1vZGVfaW5hY3RpdmUnLFxuICAnYWlycGxheScsXG4gICdhaXJwb3J0X3NodXR0bGUnLFxuICAnYWxhcm0nLFxuICAnYWxhcm1fYWRkJyxcbiAgJ2FsYXJtX29mZicsXG4gICdhbGFybV9vbicsXG4gICdhbGJ1bScsXG4gICdhbGxfaW5jbHVzaXZlJyxcbiAgJ2FsbF9vdXQnLFxuICAnYW5kcm9pZCcsXG4gICdhbm5vdW5jZW1lbnQnLFxuICAnYXBwcycsXG4gICdhcmNoaXZlJyxcbiAgJ2Fycm93X2JhY2snLFxuICAnYXJyb3dfZG93bndhcmQnLFxuICAnYXJyb3dfZHJvcF9kb3duJyxcbiAgJ2Fycm93X2Ryb3BfZG93bl9jaXJjbGUnLFxuICAnYXJyb3dfZHJvcF91cCcsXG4gICdhcnJvd19mb3J3YXJkJyxcbiAgJ2Fycm93X3Vwd2FyZCcsXG4gICdhcnRfdHJhY2snLFxuICAnYXNwZWN0X3JhdGlvJyxcbiAgJ2Fzc2Vzc21lbnQnLFxuICAnYXNzaWdubWVudCcsXG4gICdhc3NpZ25tZW50X2luZCcsXG4gICdhc3NpZ25tZW50X2xhdGUnLFxuICAnYXNzaWdubWVudF9yZXR1cm4nLFxuICAnYXNzaWdubWVudF9yZXR1cm5lZCcsXG4gICdhc3NpZ25tZW50X3R1cm5lZF9pbicsXG4gICdhc3Npc3RhbnQnLFxuICAnYXNzaXN0YW50X3Bob3RvJyxcbiAgJ2F0dGFjaF9maWxlJyxcbiAgJ2F0dGFjaF9tb25leScsXG4gICdhdHRhY2htZW50JyxcbiAgJ2F1ZGlvdHJhY2snLFxuICAnYXV0b3JlbmV3JyxcbiAgJ2F2X3RpbWVyJyxcbiAgJ2JhY2tzcGFjZScsXG4gICdiYWNrdXAnLFxuICAnYmF0dGVyeV9hbGVydCcsXG4gICdiYXR0ZXJ5X2NoYXJnaW5nX2Z1bGwnLFxuICAnYmF0dGVyeV9mdWxsJyxcbiAgJ2JhdHRlcnlfc3RkJyxcbiAgJ2JhdHRlcnlfdW5rbm93bicsXG4gICdiZWFjaF9hY2Nlc3MnLFxuICAnYmVlbmhlcmUnLFxuICAnYmxvY2snLFxuICAnYmx1ZXRvb3RoJyxcbiAgJ2JsdWV0b290aF9hdWRpbycsXG4gICdibHVldG9vdGhfY29ubmVjdGVkJyxcbiAgJ2JsdWV0b290aF9kaXNhYmxlZCcsXG4gICdibHVldG9vdGhfc2VhcmNoaW5nJyxcbiAgJ2JsdXJfY2lyY3VsYXInLFxuICAnYmx1cl9saW5lYXInLFxuICAnYmx1cl9vZmYnLFxuICAnYmx1cl9vbicsXG4gICdib29rJyxcbiAgJ2Jvb2ttYXJrJyxcbiAgJ2Jvb2ttYXJrX2JvcmRlcicsXG4gICdib3JkZXJfYWxsJyxcbiAgJ2JvcmRlcl9ib3R0b20nLFxuICAnYm9yZGVyX2NsZWFyJyxcbiAgJ2JvcmRlcl9jb2xvcicsXG4gICdib3JkZXJfaG9yaXpvbnRhbCcsXG4gICdib3JkZXJfaW5uZXInLFxuICAnYm9yZGVyX2xlZnQnLFxuICAnYm9yZGVyX291dGVyJyxcbiAgJ2JvcmRlcl9yaWdodCcsXG4gICdib3JkZXJfc3R5bGUnLFxuICAnYm9yZGVyX3RvcCcsXG4gICdib3JkZXJfdmVydGljYWwnLFxuICAnYnJhbmRpbmdfd2F0ZXJtYXJrJyxcbiAgJ2JyaWdodG5lc3NfMScsXG4gICdicmlnaHRuZXNzXzInLFxuICAnYnJpZ2h0bmVzc18zJyxcbiAgJ2JyaWdodG5lc3NfNCcsXG4gICdicmlnaHRuZXNzXzUnLFxuICAnYnJpZ2h0bmVzc182JyxcbiAgJ2JyaWdodG5lc3NfNycsXG4gICdicmlnaHRuZXNzX2F1dG8nLFxuICAnYnJpZ2h0bmVzc19oaWdoJyxcbiAgJ2JyaWdodG5lc3NfbG93JyxcbiAgJ2JyaWdodG5lc3NfbWVkaXVtJyxcbiAgJ2Jyb2tlbl9pbWFnZScsXG4gICdicnVzaCcsXG4gICdidWJibGVfY2hhcnQnLFxuICAnYnVnX3JlcG9ydCcsXG4gICdidWlsZCcsXG4gICdidXJzdF9tb2RlJyxcbiAgJ2J1c2luZXNzJyxcbiAgJ2J1c2luZXNzX2NlbnRlcicsXG4gICdjYWNoZWQnLFxuICAnY2FrZScsXG4gICdjYWxsJyxcbiAgJ2NhbGxfZW5kJyxcbiAgJ2NhbGxfbWFkZScsXG4gICdjYWxsX21lcmdlJyxcbiAgJ2NhbGxfbWlzc2VkJyxcbiAgJ2NhbGxfbWlzc2VkX291dGdvaW5nJyxcbiAgJ2NhbGxfcmVjZWl2ZWQnLFxuICAnY2FsbF9zcGxpdCcsXG4gICdjYWxsX3RvX2FjdGlvbicsXG4gICdjYW1lcmEnLFxuICAnY2FtZXJhX2FsdCcsXG4gICdjYW1lcmFfZW5oYW5jZScsXG4gICdjYW1lcmFfZnJvbnQnLFxuICAnY2FtZXJhX3JlYXInLFxuICAnY2FtZXJhX3JvbGwnLFxuICAnY2FuY2VsJyxcbiAgJ2NhcmRfZ2lmdGNhcmQnLFxuICAnY2FyZF9tZW1iZXJzaGlwJyxcbiAgJ2NhcmRfdHJhdmVsJyxcbiAgJ2Nhc2lubycsXG4gICdjYXN0JyxcbiAgJ2Nhc3RfY29ubmVjdGVkJyxcbiAgJ2NlbnRlcl9mb2N1c19zdHJvbmcnLFxuICAnY2VudGVyX2ZvY3VzX3dlYWsnLFxuICAnY2hhbmdlX2hpc3RvcnknLFxuICAnY2hhdCcsXG4gICdjaGF0X2J1YmJsZScsXG4gICdjaGF0X2J1YmJsZV9vdXRsaW5lJyxcbiAgJ2NoZWNrJyxcbiAgJ2NoZWNrX2JveCcsXG4gICdjaGVja19ib3hfb3V0bGluZV9ibGFuaycsXG4gICdjaGVja19jaXJjbGUnLFxuICAnY2hldnJvbl9sZWZ0JyxcbiAgJ2NoZXZyb25fcmlnaHQnLFxuICAnY2hpbGRfY2FyZScsXG4gICdjaGlsZF9mcmllbmRseScsXG4gICdjaHJvbWVfcmVhZGVyX21vZGUnLFxuICAnY2xhc3MnLFxuICAnY2xlYXInLFxuICAnY2xlYXJfYWxsJyxcbiAgJ2Nsb3NlJyxcbiAgJ2Nsb3NlZF9jYXB0aW9uJyxcbiAgJ2Nsb3VkJyxcbiAgJ2Nsb3VkX2NpcmNsZScsXG4gICdjbG91ZF9kb25lJyxcbiAgJ2Nsb3VkX2Rvd25sb2FkJyxcbiAgJ2Nsb3VkX29mZicsXG4gICdjbG91ZF9xdWV1ZScsXG4gICdjbG91ZF91cGxvYWQnLFxuICAnY29kZScsXG4gICdjb2xsZWN0aW9ucycsXG4gICdjb2xsZWN0aW9uc19ib29rbWFyaycsXG4gICdjb2xvcl9sZW5zJyxcbiAgJ2NvbG9yaXplJyxcbiAgJ2NvbW1lbnQnLFxuICAnY29tcGFyZScsXG4gICdjb21wYXJlX2Fycm93cycsXG4gICdjb21wdXRlcicsXG4gICdjb25maXJtYXRpb25fbnVtYmVyJyxcbiAgJ2NvbnRhY3RfbWFpbCcsXG4gICdjb250YWN0X3Bob25lJyxcbiAgJ2NvbnRhY3RzJyxcbiAgJ2NvbnRlbnRfY29weScsXG4gICdjb250ZW50X2N1dCcsXG4gICdjb250ZW50X3Bhc3RlJyxcbiAgJ2NvbnRyb2xfcG9pbnQnLFxuICAnY29udHJvbF9wb2ludF9kdXBsaWNhdGUnLFxuICAnY29weXJpZ2h0JyxcbiAgJ2NyZWF0ZScsXG4gICdjcmVhdGVfbmV3X2ZvbGRlcicsXG4gICdjcmVkaXRfY2FyZCcsXG4gICdjcm9wJyxcbiAgJ2Nyb3BfMTZfOScsXG4gICdjcm9wXzNfMicsXG4gICdjcm9wXzVfNCcsXG4gICdjcm9wXzdfNScsXG4gICdjcm9wX2RpbicsXG4gICdjcm9wX2ZyZWUnLFxuICAnY3JvcF9sYW5kc2NhcGUnLFxuICAnY3JvcF9vcmlnaW5hbCcsXG4gICdjcm9wX3BvcnRyYWl0JyxcbiAgJ2Nyb3Bfcm90YXRlJyxcbiAgJ2Nyb3Bfc3F1YXJlJyxcbiAgJ2Rhc2hib2FyZCcsXG4gICdkYXRhX3VzYWdlJyxcbiAgJ2RhdGVfcmFuZ2UnLFxuICAnZGVoYXplJyxcbiAgJ2RlbGV0ZScsXG4gICdkZWxldGVfZm9yZXZlcicsXG4gICdkZWxldGVfc3dlZXAnLFxuICAnZGVzY3JpcHRpb24nLFxuICAnZGVza3RvcF9tYWMnLFxuICAnZGVza3RvcF93aW5kb3dzJyxcbiAgJ2RldGFpbHMnLFxuICAnZGV2ZWxvcGVyX2JvYXJkJyxcbiAgJ2RldmVsb3Blcl9tb2RlJyxcbiAgJ2RldmljZV9odWInLFxuICAnZGV2aWNlcycsXG4gICdkZXZpY2VzX290aGVyJyxcbiAgJ2RpYWxlcl9zaXAnLFxuICAnZGlhbHBhZCcsXG4gICdkaXJlY3Rpb25zJyxcbiAgJ2RpcmVjdGlvbnNfYmlrZScsXG4gICdkaXJlY3Rpb25zX2JvYXQnLFxuICAnZGlyZWN0aW9uc19idXMnLFxuICAnZGlyZWN0aW9uc19jYXInLFxuICAnZGlyZWN0aW9uc19yYWlsd2F5JyxcbiAgJ2RpcmVjdGlvbnNfcnVuJyxcbiAgJ2RpcmVjdGlvbnNfc3Vid2F5JyxcbiAgJ2RpcmVjdGlvbnNfdHJhbnNpdCcsXG4gICdkaXJlY3Rpb25zX3dhbGsnLFxuICAnZGlzY19mdWxsJyxcbiAgJ2RucycsXG4gICdkb19ub3RfZGlzdHVyYicsXG4gICdkb19ub3RfZGlzdHVyYl9hbHQnLFxuICAnZG9fbm90X2Rpc3R1cmJfb2ZmJyxcbiAgJ2RvX25vdF9kaXN0dXJiX29uJyxcbiAgJ2RvY2snLFxuICAnZG9tYWluJyxcbiAgJ2RvbmUnLFxuICAnZG9uZV9hbGwnLFxuICAnZG9udXRfbGFyZ2UnLFxuICAnZG9udXRfc21hbGwnLFxuICAnZHJhZnRzJyxcbiAgJ2RyYWdfaGFuZGxlJyxcbiAgJ2RyaXZlX2V0YScsXG4gICdkdnInLFxuICAnZWRpdCcsXG4gICdlZGl0X2xvY2F0aW9uJyxcbiAgJ2VqZWN0JyxcbiAgJ2VtYWlsJyxcbiAgJ2VuaGFuY2VkX2VuY3J5cHRpb24nLFxuICAnZXF1YWxpemVyJyxcbiAgJ2Vycm9yJyxcbiAgJ2Vycm9yX291dGxpbmUnLFxuICAnZXVyb19zeW1ib2wnLFxuICAnZXZfc3RhdGlvbicsXG4gICdldmVudCcsXG4gICdldmVudF9hdmFpbGFibGUnLFxuICAnZXZlbnRfYnVzeScsXG4gICdldmVudF9ub3RlJyxcbiAgJ2V2ZW50X3NlYXQnLFxuICAnZXhpdF90b19hcHAnLFxuICAnZXhwYW5kX2xlc3MnLFxuICAnZXhwYW5kX21vcmUnLFxuICAnZXhwbGljaXQnLFxuICAnZXhwbG9yZScsXG4gICdleHBvc3VyZScsXG4gICdleHBvc3VyZV9uZWdfMScsXG4gICdleHBvc3VyZV9uZWdfMicsXG4gICdleHBvc3VyZV9wbHVzXzEnLFxuICAnZXhwb3N1cmVfcGx1c18yJyxcbiAgJ2V4cG9zdXJlX3plcm8nLFxuICAnZXh0ZW5zaW9uJyxcbiAgJ2ZhY2UnLFxuICAnZmFzdF9mb3J3YXJkJyxcbiAgJ2Zhc3RfcmV3aW5kJyxcbiAgJ2Zhdm9yaXRlJyxcbiAgJ2Zhdm9yaXRlX2JvcmRlcicsXG4gICdmZWF0dXJlZF9wbGF5X2xpc3QnLFxuICAnZmVhdHVyZWRfdmlkZW8nLFxuICAnZmVlZGJhY2snLFxuICAnZmliZXJfZHZyJyxcbiAgJ2ZpYmVyX21hbnVhbF9yZWNvcmQnLFxuICAnZmliZXJfbmV3JyxcbiAgJ2ZpYmVyX3BpbicsXG4gICdmaWJlcl9zbWFydF9yZWNvcmQnLFxuICAnZmlsZV9kb3dubG9hZCcsXG4gICdmaWxlX3VwbG9hZCcsXG4gICdmaWx0ZXInLFxuICAnZmlsdGVyXzEnLFxuICAnZmlsdGVyXzInLFxuICAnZmlsdGVyXzMnLFxuICAnZmlsdGVyXzQnLFxuICAnZmlsdGVyXzUnLFxuICAnZmlsdGVyXzYnLFxuICAnZmlsdGVyXzcnLFxuICAnZmlsdGVyXzgnLFxuICAnZmlsdGVyXzknLFxuICAnZmlsdGVyXzlfcGx1cycsXG4gICdmaWx0ZXJfYl9hbmRfdycsXG4gICdmaWx0ZXJfY2VudGVyX2ZvY3VzJyxcbiAgJ2ZpbHRlcl9kcmFtYScsXG4gICdmaWx0ZXJfZnJhbWVzJyxcbiAgJ2ZpbHRlcl9oZHInLFxuICAnZmlsdGVyX2xpc3QnLFxuICAnZmlsdGVyX25vbmUnLFxuICAnZmlsdGVyX3RpbHRfc2hpZnQnLFxuICAnZmlsdGVyX3ZpbnRhZ2UnLFxuICAnZmluZF9pbl9wYWdlJyxcbiAgJ2ZpbmRfcmVwbGFjZScsXG4gICdmaW5nZXJwcmludCcsXG4gICdmaXJzdF9wYWdlJyxcbiAgJ2ZpdG5lc3NfY2VudGVyJyxcbiAgJ2ZsYWcnLFxuICAnZmxhcmUnLFxuICAnZmxhc2hfYXV0bycsXG4gICdmbGFzaF9vZmYnLFxuICAnZmxhc2hfb24nLFxuICAnZmxpZ2h0JyxcbiAgJ2ZsaWdodF9sYW5kJyxcbiAgJ2ZsaWdodF90YWtlb2ZmJyxcbiAgJ2ZsaXAnLFxuICAnZmxpcF90b19iYWNrJyxcbiAgJ2ZsaXBfdG9fZnJvbnQnLFxuICAnZm9sZGVyJyxcbiAgJ2ZvbGRlcl9vcGVuJyxcbiAgJ2ZvbGRlcl9zaGFyZWQnLFxuICAnZm9sZGVyX3NwZWNpYWwnLFxuICAnZm9udF9kb3dubG9hZCcsXG4gICdmb3JtYXRfYWxpZ25fY2VudGVyJyxcbiAgJ2Zvcm1hdF9hbGlnbl9qdXN0aWZ5JyxcbiAgJ2Zvcm1hdF9hbGlnbl9sZWZ0JyxcbiAgJ2Zvcm1hdF9hbGlnbl9yaWdodCcsXG4gICdmb3JtYXRfYm9sZCcsXG4gICdmb3JtYXRfY2xlYXInLFxuICAnZm9ybWF0X2NvbG9yX2ZpbGwnLFxuICAnZm9ybWF0X2NvbG9yX3Jlc2V0JyxcbiAgJ2Zvcm1hdF9jb2xvcl90ZXh0JyxcbiAgJ2Zvcm1hdF9pbmRlbnRfZGVjcmVhc2UnLFxuICAnZm9ybWF0X2luZGVudF9pbmNyZWFzZScsXG4gICdmb3JtYXRfbGluZV9zcGFjaW5nJyxcbiAgJ2Zvcm1hdF9saXN0X2J1bGxldGVkJyxcbiAgJ2Zvcm1hdF9saXN0X251bWJlcmVkJyxcbiAgJ2Zvcm1hdF9wYWludCcsXG4gICdmb3JtYXRfcXVvdGUnLFxuICAnZm9ybWF0X3NoYXBlcycsXG4gICdmb3JtYXRfc2l6ZScsXG4gICdmb3JtYXRfc3RyaWtldGhyb3VnaCcsXG4gICdmb3JtYXRfdGV4dGRpcmVjdGlvbl9sX3RvX3InLFxuICAnZm9ybWF0X3RleHRkaXJlY3Rpb25fcl90b19sJyxcbiAgJ2Zvcm1hdF91bmRlcmxpbmVkJyxcbiAgJ2ZvcnVtJyxcbiAgJ2ZvcndhcmQnLFxuICAnZm9yd2FyZF8xMCcsXG4gICdmb3J3YXJkXzMwJyxcbiAgJ2ZvcndhcmRfNScsXG4gICdmcmVlX2JyZWFrZmFzdCcsXG4gICdmdWxsc2NyZWVuJyxcbiAgJ2Z1bGxzY3JlZW5fZXhpdCcsXG4gICdmdW5jdGlvbnMnLFxuICAnZ190cmFuc2xhdGUnLFxuICAnZ2FtZXBhZCcsXG4gICdnYW1lcycsXG4gICdnYXZlbCcsXG4gICdnZXN0dXJlJyxcbiAgJ2dldF9hcHAnLFxuICAnZ2lmJyxcbiAgJ2dvbGZfY291cnNlJyxcbiAgJ2dwc19maXhlZCcsXG4gICdncHNfbm90X2ZpeGVkJyxcbiAgJ2dwc19vZmYnLFxuICAnZ3JhZGUnLFxuICAnZ3JhZGllbnQnLFxuICAnZ3JhaW4nLFxuICAnZ3JpZF9vZmYnLFxuICAnZ3JpZF9vbicsXG4gICdncm91cCcsXG4gICdncm91cF9hZGQnLFxuICAnZ3JvdXBfd29yaycsXG4gICdoZCcsXG4gICdoZHJfb2ZmJyxcbiAgJ2hkcl9vbicsXG4gICdoZHJfc3Ryb25nJyxcbiAgJ2hkcl93ZWFrJyxcbiAgJ2hlYWRzZXQnLFxuICAnaGVhbGluZycsXG4gICdoZWFyaW5nJyxcbiAgJ2hlbHAnLFxuICAnaGVscF9vdXRsaW5lJyxcbiAgJ2hpZ2hfcXVhbGl0eScsXG4gICdoaWdobGlnaHQnLFxuICAnaGlnaGxpZ2h0X29mZicsXG4gICdoaXN0b3J5JyxcbiAgJ2hvbWUnLFxuICAnaG90X3R1YicsXG4gICdob3RlbCcsXG4gICdob3VyZ2xhc3NfZW1wdHknLFxuICAnaG91cmdsYXNzX2Z1bGwnLFxuICAnaHR0cCcsXG4gICdodHRwcycsXG4gICdpbWFnZScsXG4gICdpbWFnZV9hc3BlY3RfcmF0aW8nLFxuICAnaW1wb3J0X2NvbnRhY3RzJyxcbiAgJ2ltcG9ydF9leHBvcnQnLFxuICAnaW1wb3J0YW50X2RldmljZXMnLFxuICAnaW5ib3gnLFxuICAnaW5kZXRlcm1pbmF0ZV9jaGVja19ib3gnLFxuICAnaW5mbycsXG4gICdpbmZvX291dGxpbmUnLFxuICAnaW5wdXQnLFxuICAnaW5zZXJ0X2NoYXJ0JyxcbiAgJ2luc2VydF9jb21tZW50JyxcbiAgJ2luc2VydF9kcml2ZV9maWxlJyxcbiAgJ2luc2VydF9lbW90aWNvbicsXG4gICdpbnNlcnRfaW52aXRhdGlvbicsXG4gICdpbnNlcnRfbGluaycsXG4gICdpbnNlcnRfcGhvdG8nLFxuICAnaW52ZXJ0X2NvbG9ycycsXG4gICdpbnZlcnRfY29sb3JzX29mZicsXG4gICdpc28nLFxuICAna2V5Ym9hcmQnLFxuICAna2V5Ym9hcmRfYXJyb3dfZG93bicsXG4gICdrZXlib2FyZF9hcnJvd19sZWZ0JyxcbiAgJ2tleWJvYXJkX2Fycm93X3JpZ2h0JyxcbiAgJ2tleWJvYXJkX2Fycm93X3VwJyxcbiAgJ2tleWJvYXJkX2JhY2tzcGFjZScsXG4gICdrZXlib2FyZF9jYXBzbG9jaycsXG4gICdrZXlib2FyZF9oaWRlJyxcbiAgJ2tleWJvYXJkX3JldHVybicsXG4gICdrZXlib2FyZF90YWInLFxuICAna2V5Ym9hcmRfdm9pY2UnLFxuICAna2l0Y2hlbicsXG4gICdsYWJlbCcsXG4gICdsYWJlbF9vdXRsaW5lJyxcbiAgJ2xhbmRzY2FwZScsXG4gICdsYW5ndWFnZScsXG4gICdsYXB0b3AnLFxuICAnbGFwdG9wX2Nocm9tZWJvb2snLFxuICAnbGFwdG9wX21hYycsXG4gICdsYXB0b3Bfd2luZG93cycsXG4gICdsYXN0X3BhZ2UnLFxuICAnbGF1bmNoJyxcbiAgJ2xheWVycycsXG4gICdsYXllcnNfY2xlYXInLFxuICAnbGVha19hZGQnLFxuICAnbGVha19yZW1vdmUnLFxuICAnbGVucycsXG4gICdsaWJyYXJ5X2FkZCcsXG4gICdsaWJyYXJ5X2Jvb2tzJyxcbiAgJ2xpZ2h0YnVsYl9vdXRsaW5lJyxcbiAgJ2xpbmVfc3R5bGUnLFxuICAnbGluZV93ZWlnaHQnLFxuICAnbGluZWFyX3NjYWxlJyxcbiAgJ2xpbmsnLFxuICAnbGlua2VkX2NhbWVyYScsXG4gICdsaXN0JyxcbiAgJ2xpdmVfaGVscCcsXG4gICdsaXZlX3R2JyxcbiAgJ2xvY2FsX2FjdGl2aXR5JyxcbiAgJ2xvY2FsX2FpcnBvcnQnLFxuICAnbG9jYWxfYXRtJyxcbiAgJ2xvY2FsX2JhcicsXG4gICdsb2NhbF9jYWZlJyxcbiAgJ2xvY2FsX2Nhcl93YXNoJyxcbiAgJ2xvY2FsX2NvbnZlbmllbmNlX3N0b3JlJyxcbiAgJ2xvY2FsX2RpbmluZycsXG4gICdsb2NhbF9kcmluaycsXG4gICdsb2NhbF9mbG9yaXN0JyxcbiAgJ2xvY2FsX2dhc19zdGF0aW9uJyxcbiAgJ2xvY2FsX2dyb2Nlcnlfc3RvcmUnLFxuICAnbG9jYWxfaG9zcGl0YWwnLFxuICAnbG9jYWxfaG90ZWwnLFxuICAnbG9jYWxfbGF1bmRyeV9zZXJ2aWNlJyxcbiAgJ2xvY2FsX2xpYnJhcnknLFxuICAnbG9jYWxfbWFsbCcsXG4gICdsb2NhbF9tb3ZpZXMnLFxuICAnbG9jYWxfb2ZmZXInLFxuICAnbG9jYWxfcGFya2luZycsXG4gICdsb2NhbF9waGFybWFjeScsXG4gICdsb2NhbF9waG9uZScsXG4gICdsb2NhbF9waXp6YScsXG4gICdsb2NhbF9wbGF5JyxcbiAgJ2xvY2FsX3Bvc3Rfb2ZmaWNlJyxcbiAgJ2xvY2FsX3ByaW50c2hvcCcsXG4gICdsb2NhbF9zZWUnLFxuICAnbG9jYWxfc2hpcHBpbmcnLFxuICAnbG9jYWxfdGF4aScsXG4gICdsb2NhdGlvbl9jaXR5JyxcbiAgJ2xvY2F0aW9uX2Rpc2FibGVkJyxcbiAgJ2xvY2F0aW9uX29mZicsXG4gICdsb2NhdGlvbl9vbicsXG4gICdsb2NhdGlvbl9zZWFyY2hpbmcnLFxuICAnbG9jaycsXG4gICdsb2NrX29wZW4nLFxuICAnbG9ja19vdXRsaW5lJyxcbiAgJ2xvb2tzJyxcbiAgJ2xvb2tzXzMnLFxuICAnbG9va3NfNCcsXG4gICdsb29rc181JyxcbiAgJ2xvb2tzXzYnLFxuICAnbG9va3Nfb25lJyxcbiAgJ2xvb2tzX3R3bycsXG4gICdsb29wJyxcbiAgJ2xvdXBlJyxcbiAgJ2xvd19wcmlvcml0eScsXG4gICdsb3lhbHR5JyxcbiAgJ21haWwnLFxuICAnbWFpbF9vdXRsaW5lJyxcbiAgJ21hcCcsXG4gICdtYXJrdW5yZWFkJyxcbiAgJ21hcmt1bnJlYWRfbWFpbGJveCcsXG4gICdtZW1vcnknLFxuICAnbWVudScsXG4gICdtZXJnZV90eXBlJyxcbiAgJ21lc3NhZ2UnLFxuICAnbW1zJyxcbiAgJ21vZGVfY29tbWVudCcsXG4gICdtb2RlX2VkaXQnLFxuICAnbW9uZXRpemF0aW9uX29uJyxcbiAgJ21vbmV5X29mZicsXG4gICdtb25vY2hyb21lX3Bob3RvcycsXG4gICdtb29kJyxcbiAgJ21vb2RfYmFkJyxcbiAgJ21vcmUnLFxuICAnbW9yZV9ob3JpeicsXG4gICdtb3JlX3ZlcnQnLFxuICAnbW90b3JjeWNsZScsXG4gICdtb3VzZScsXG4gICdtb3ZlX3RvX2luYm94JyxcbiAgJ21vdmllJyxcbiAgJ21vdmllX2NyZWF0aW9uJyxcbiAgJ21vdmllX2ZpbHRlcicsXG4gICdtdWx0aWxpbmVfY2hhcnQnLFxuICAnbXlfbG9jYXRpb24nLFxuICAnbmF0dXJlJyxcbiAgJ25hdHVyZV9wZW9wbGUnLFxuICAnbmF2aWdhdGVfYmVmb3JlJyxcbiAgJ25hdmlnYXRlX25leHQnLFxuICAnbmF2aWdhdGlvbicsXG4gICduZWFyX21lJyxcbiAgJ25ldHdvcmtfY2VsbCcsXG4gICduZXR3b3JrX2NoZWNrJyxcbiAgJ25ldHdvcmtfbG9ja2VkJyxcbiAgJ25ldHdvcmtfd2lmaScsXG4gICduZXdfcmVsZWFzZXMnLFxuICAnbmV4dF93ZWVrJyxcbiAgJ25mYycsXG4gICdub19lbmNyeXB0aW9uJyxcbiAgJ25vX3NpbScsXG4gICdub3RfaW50ZXJlc3RlZCcsXG4gICdub3RlJyxcbiAgJ25vdGUnLFxuICAnbm90ZV9hZGQnLFxuICAnbm90aWZpY2F0aW9ucycsXG4gICdub3RpZmljYXRpb25zX2FjdGl2ZScsXG4gICdub3RpZmljYXRpb25zX25vbmUnLFxuICAnbm90aWZpY2F0aW9uc19vZmYnLFxuICAnbm90aWZpY2F0aW9uc19wYXVzZWQnLFxuICAnb2ZmbGluZV9waW4nLFxuICAnb25kZW1hbmRfdmlkZW8nLFxuICAnb3BhY2l0eScsXG4gICdvcGVuX2luX2Jyb3dzZXInLFxuICAnb3Blbl9pbl9uZXcnLFxuICAnb3Blbl93aXRoJyxcbiAgJ3BhZ2VzJyxcbiAgJ3BhZ2V2aWV3JyxcbiAgJ3BhbGV0dGUnLFxuICAncGFuX3Rvb2wnLFxuICAncGFub3JhbWEnLFxuICAncGFub3JhbWFfZmlzaF9leWUnLFxuICAncGFub3JhbWFfaG9yaXpvbnRhbCcsXG4gICdwYW5vcmFtYV92ZXJ0aWNhbCcsXG4gICdwYW5vcmFtYV93aWRlX2FuZ2xlJyxcbiAgJ3BhcnR5X21vZGUnLFxuICAncGF1c2UnLFxuICAncGF1c2VfY2lyY2xlX2ZpbGxlZCcsXG4gICdwYXVzZV9jaXJjbGVfb3V0bGluZScsXG4gICdwYXltZW50JyxcbiAgJ3Blb3BsZScsXG4gICdwZW9wbGVfb3V0bGluZScsXG4gICdwZXJtX2NvbnRhY3RfY2FsZW5kYXInLFxuICAncGVybV9kYXRhX3NldHRpbmcnLFxuICAncGVybV9kZXZpY2VfaW5mb3JtYXRpb24nLFxuICAncGVybV9pZGVudGl0eScsXG4gICdwZXJtX21lZGlhJyxcbiAgJ3Blcm1fcGhvbmVfbXNnJyxcbiAgJ3Blcm1fc2Nhbl93aWZpJyxcbiAgJ3BlcnNvbicsXG4gICdwZXJzb25fYWRkJyxcbiAgJ3BlcnNvbl9vdXRsaW5lJyxcbiAgJ3BlcnNvbl9waW4nLFxuICAncGVyc29uX3Bpbl9jaXJjbGUnLFxuICAncGVyc29uYWxfdmlkZW8nLFxuICAncGV0cycsXG4gICdwaG9uZScsXG4gICdwaG9uZV9hbmRyb2lkJyxcbiAgJ3Bob25lX2JsdWV0b290aF9zcGVha2VyJyxcbiAgJ3Bob25lX2ZvcndhcmRlZCcsXG4gICdwaG9uZV9pbl90YWxrJyxcbiAgJ3Bob25lX2lwaG9uZScsXG4gICdwaG9uZV9sb2NrZWQnLFxuICAncGhvbmVfbWlzc2VkJyxcbiAgJ3Bob25lX3BhdXNlZCcsXG4gICdwaG9uZWxpbmsnLFxuICAncGhvbmVsaW5rX2VyYXNlJyxcbiAgJ3Bob25lbGlua19sb2NrJyxcbiAgJ3Bob25lbGlua19vZmYnLFxuICAncGhvbmVsaW5rX3JpbmcnLFxuICAncGhvbmVsaW5rX3NldHVwJyxcbiAgJ3Bob3RvJyxcbiAgJ3Bob3RvX2FsYnVtJyxcbiAgJ3Bob3RvX2NhbWVyYScsXG4gICdwaG90b19maWx0ZXInLFxuICAncGhvdG9fbGlicmFyeScsXG4gICdwaG90b19zaXplX3NlbGVjdF9hY3R1YWwnLFxuICAncGhvdG9fc2l6ZV9zZWxlY3RfbGFyZ2UnLFxuICAncGhvdG9fc2l6ZV9zZWxlY3Rfc21hbGwnLFxuICAncGljdHVyZV9hc19wZGYnLFxuICAncGljdHVyZV9pbl9waWN0dXJlJyxcbiAgJ3BpY3R1cmVfaW5fcGljdHVyZV9hbHQnLFxuICAncGllX2NoYXJ0JyxcbiAgJ3BpZV9jaGFydF9vdXRsaW5lZCcsXG4gICdwaW5fZHJvcCcsXG4gICdwbGFjZScsXG4gICdwbGF5X2Fycm93JyxcbiAgJ3BsYXlfY2lyY2xlX2ZpbGxlZCcsXG4gICdwbGF5X2NpcmNsZV9vdXRsaW5lJyxcbiAgJ3BsYXlfZm9yX3dvcmsnLFxuICAncGxheWxpc3RfYWRkJyxcbiAgJ3BsYXlsaXN0X2FkZF9jaGVjaycsXG4gICdwbGF5bGlzdF9wbGF5JyxcbiAgJ3BsdXNfb25lJyxcbiAgJ3BvbGwnLFxuICAncG9seW1lcicsXG4gICdwb29sJyxcbiAgJ3BvcnRhYmxlX3dpZmlfb2ZmJyxcbiAgJ3BvcnRyYWl0JyxcbiAgJ3Bvd2VyJyxcbiAgJ3Bvd2VyX2lucHV0JyxcbiAgJ3Bvd2VyX3NldHRpbmdzX25ldycsXG4gICdwcmVnbmFudF93b21hbicsXG4gICdwcmVzZW50X3RvX2FsbCcsXG4gICdwcmludCcsXG4gICdwcmlvcml0eV9oaWdoJyxcbiAgJ3B1Ymxpc2gnLFxuICAncXVlcnlfYnVpbGRlcicsXG4gICdxdWVzdGlvbl9hbnN3ZXInLFxuICAncXVldWUnLFxuICAncXVldWVfcGxheV9uZXh0JyxcbiAgJ3JhZGlvJyxcbiAgJ3JhZGlvX2J1dHRvbl9jaGVja2VkJyxcbiAgJ3JhZGlvX2J1dHRvbl91bmNoZWNrZWQnLFxuICAncmF0ZV9yZXZpZXcnLFxuICAncmVjZWlwdCcsXG4gICdyZWNlbnRfYWN0b3JzJyxcbiAgJ3JlY29yZF92b2ljZV9vdmVyJyxcbiAgJ3JlZGVlbScsXG4gICdyZWRvJyxcbiAgJ3JlZnJlc2gnLFxuICAncmVtb3ZlJyxcbiAgJ3JlbW92ZV9jaXJjbGUnLFxuICAncmVtb3ZlX2NpcmNsZV9vdXRsaW5lJyxcbiAgJ3JlbW92ZV9mcm9tX3F1ZXVlJyxcbiAgJ3JlbW92ZV9yZWRfZXllJyxcbiAgJ3JlbW92ZV9zaG9wcGluZ19jYXJ0JyxcbiAgJ3Jlb3JkZXInLFxuICAncmVwZWF0JyxcbiAgJ3JlcGVhdF9vbmUnLFxuICAncmVwbGF5JyxcbiAgJ3JlcGxheV8xMCcsXG4gICdyZXBsYXlfMzAnLFxuICAncmVwbGF5XzUnLFxuICAncmVwbHknLFxuICAncmVwbHlfYWxsJyxcbiAgJ3JlcG9ydCcsXG4gICdyZXBvcnRfcHJvYmxlbScsXG4gICdyZXN0YXVyYW50JyxcbiAgJ3Jlc3RhdXJhbnRfbWVudScsXG4gICdyZXN0b3JlJyxcbiAgJ3Jlc3RvcmVfcGFnZScsXG4gICdyaW5nX3ZvbHVtZScsXG4gICdyb29tJyxcbiAgJ3Jvb21fc2VydmljZScsXG4gICdyb3RhdGVfOTBfZGVncmVlc19jY3cnLFxuICAncm90YXRlX2xlZnQnLFxuICAncm90YXRlX3JpZ2h0JyxcbiAgJ3JvdW5kZWRfY29ybmVyJyxcbiAgJ3JvdXRlcicsXG4gICdyb3dpbmcnLFxuICAncnNzX2ZlZWQnLFxuICAncnZfaG9va3VwJyxcbiAgJ3J2X2hvb2t1cCcsXG4gICdzYXRlbGxpdGUnLFxuICAnc2F2ZScsXG4gICdzY2FubmVyJyxcbiAgJ3NjaGVkdWxlJyxcbiAgJ3NjaG9vbCcsXG4gICdzY3JlZW5fbG9ja19sYW5kc2NhcGUnLFxuICAnc2NyZWVuX2xvY2tfcG9ydHJhaXQnLFxuICAnc2NyZWVuX2xvY2tfcm90YXRpb24nLFxuICAnc2NyZWVuX3JvdGF0aW9uJyxcbiAgJ3NjcmVlbl9zaGFyZScsXG4gICdzZF9jYXJkJyxcbiAgJ3NkX3N0b3JhZ2UnLFxuICAnc2VhcmNoJyxcbiAgJ3NlY3VyaXR5JyxcbiAgJ3NlbGVjdF9hbGwnLFxuICAnc2VuZCcsXG4gICdzZW50aW1lbnRfZGlzc2F0aXNmaWVkJyxcbiAgJ3NlbnRpbWVudF9uZXV0cmFsJyxcbiAgJ3NlbnRpbWVudF9zYXRpc2ZpZWQnLFxuICAnc2VudGltZW50X3ZlcnlfZGlzc2F0aXNmaWVkJyxcbiAgJ3NlbnRpbWVudF92ZXJ5X3NhdGlzZmllZCcsXG4gICdzZXR0aW5ncycsXG4gICdzZXR0aW5nc19hcHBsaWNhdGlvbnMnLFxuICAnc2V0dGluZ3NfYmFja3VwX3Jlc3RvcmUnLFxuICAnc2V0dGluZ3NfYmx1ZXRvb3RoJyxcbiAgJ3NldHRpbmdzX2JyaWdodG5lc3MnLFxuICAnc2V0dGluZ3NfY2VsbCcsXG4gICdzZXR0aW5nc19ldGhlcm5ldCcsXG4gICdzZXR0aW5nc19pbnB1dF9hbnRlbm5hJyxcbiAgJ3NldHRpbmdzX2lucHV0X2NvbXBvbmVudCcsXG4gICdzZXR0aW5nc19pbnB1dF9jb21wb3NpdGUnLFxuICAnc2V0dGluZ3NfaW5wdXRfaGRtaScsXG4gICdzZXR0aW5nc19pbnB1dF9zdmlkZW8nLFxuICAnc2V0dGluZ3Nfb3ZlcnNjYW4nLFxuICAnc2V0dGluZ3NfcGhvbmUnLFxuICAnc2V0dGluZ3NfcG93ZXInLFxuICAnc2V0dGluZ3NfcmVtb3RlJyxcbiAgJ3NldHRpbmdzX3N5c3RlbV9kYXlkcmVhbScsXG4gICdzZXR0aW5nc192b2ljZScsXG4gICdzaGFyZScsXG4gICdzaG9wJyxcbiAgJ3Nob3BfdHdvJyxcbiAgJ3Nob3BwaW5nX2Jhc2tldCcsXG4gICdzaG9wcGluZ19jYXJ0JyxcbiAgJ3Nob3J0X3RleHQnLFxuICAnc2hvd19jaGFydCcsXG4gICdzaHVmZmxlJyxcbiAgJ3NpZ25hbF9jZWxsdWxhcl80X2JhcicsXG4gICdzaWduYWxfY2VsbHVsYXJfY29ubmVjdGVkX25vX2ludGVybmV0XzRfYmFyJyxcbiAgJ3NpZ25hbF9jZWxsdWxhcl9ub19zaW0nLFxuICAnc2lnbmFsX2NlbGx1bGFyX251bGwnLFxuICAnc2lnbmFsX2NlbGx1bGFyX29mZicsXG4gICdzaWduYWxfd2lmaV80X2JhcicsXG4gICdzaWduYWxfd2lmaV80X2Jhcl9sb2NrJyxcbiAgJ3NpZ25hbF93aWZpX29mZicsXG4gICdzaW1fY2FyZCcsXG4gICdzaW1fY2FyZF9hbGVydCcsXG4gICdza2lwX25leHQnLFxuICAnc2tpcF9wcmV2aW91cycsXG4gICdzbGlkZXNob3cnLFxuICAnc2xvd19tb3Rpb25fdmlkZW8nLFxuICAnc21hcnRwaG9uZScsXG4gICdzbW9rZV9mcmVlJyxcbiAgJ3Ntb2tpbmdfcm9vbXMnLFxuICAnc21zJyxcbiAgJ3Ntc19mYWlsZWQnLFxuICAnc25vb3plJyxcbiAgJ3NvcnQnLFxuICAnc29ydF9ieV9hbHBoYScsXG4gICdzcGEnLFxuICAnc3BhY2VfYmFyJyxcbiAgJ3NwZWFrZXInLFxuICAnc3BlYWtlcl9ncm91cCcsXG4gICdzcGVha2VyX25vdGVzJyxcbiAgJ3NwZWFrZXJfbm90ZXNfb2ZmJyxcbiAgJ3NwZWFrZXJfcGhvbmUnLFxuICAnc3BlbGxjaGVjaycsXG4gICdzdGFyJyxcbiAgJ3N0YXJfYm9yZGVyJyxcbiAgJ3N0YXJfaGFsZicsXG4gICdzdGFycycsXG4gICdzdGF5X2N1cnJlbnRfbGFuZHNjYXBlJyxcbiAgJ3N0YXlfY3VycmVudF9wb3J0cmFpdCcsXG4gICdzdGF5X3ByaW1hcnlfbGFuZHNjYXBlJyxcbiAgJ3N0YXlfcHJpbWFyeV9wb3J0cmFpdCcsXG4gICdzdG9wJyxcbiAgJ3N0b3Bfc2NyZWVuX3NoYXJlJyxcbiAgJ3N0b3JhZ2UnLFxuICAnc3RvcmUnLFxuICAnc3RvcmVfbWFsbF9kaXJlY3RvcnknLFxuICAnc3RyYWlnaHRlbicsXG4gICdzdHJlZXR2aWV3JyxcbiAgJ3N0cmlrZXRocm91Z2hfcycsXG4gICdzdHlsZScsXG4gICdzdWJkaXJlY3RvcnlfYXJyb3dfbGVmdCcsXG4gICdzdWJkaXJlY3RvcnlfYXJyb3dfcmlnaHQnLFxuICAnc3ViamVjdCcsXG4gICdzdWJzY3JpcHRpb25zJyxcbiAgJ3N1YnRpdGxlcycsXG4gICdzdWJ3YXknLFxuICAnc3VwZXJ2aXNvcl9hY2NvdW50JyxcbiAgJ3N1cnJvdW5kX3NvdW5kJyxcbiAgJ3N3YXBfY2FsbHMnLFxuICAnc3dhcF9ob3JpeicsXG4gICdzd2FwX3ZlcnQnLFxuICAnc3dhcF92ZXJ0aWNhbF9jaXJjbGUnLFxuICAnc3dpdGNoX2NhbWVyYScsXG4gICdzd2l0Y2hfdmlkZW8nLFxuICAnc3luYycsXG4gICdzeW5jX2Rpc2FibGVkJyxcbiAgJ3N5bmNfcHJvYmxlbScsXG4gICdzeXN0ZW1fdXBkYXRlJyxcbiAgJ3N5c3RlbV91cGRhdGVfYWx0JyxcbiAgJ3RhYicsXG4gICd0YWJfdW5zZWxlY3RlZCcsXG4gICd0YWJsZXQnLFxuICAndGFibGV0X2FuZHJvaWQnLFxuICAndGFibGV0X21hYycsXG4gICd0YWdfZmFjZXMnLFxuICAndGFwX2FuZF9wbGF5JyxcbiAgJ3RlcnJhaW4nLFxuICAndGV4dF9maWVsZHMnLFxuICAndGV4dF9mb3JtYXQnLFxuICAndGV4dHNtcycsXG4gICd0ZXh0dXJlJyxcbiAgJ3RoZWF0ZXJzJyxcbiAgJ3RodW1iX2Rvd24nLFxuICAndGh1bWJfdXAnLFxuICAndGh1bWJzX3VwX2Rvd24nLFxuICAndGltZV90b19sZWF2ZScsXG4gICd0aW1lbGFwc2UnLFxuICAndGltZWxpbmUnLFxuICAndGltZXInLFxuICAndGltZXJfMTAnLFxuICAndGltZXJfMycsXG4gICd0aW1lcl9vZmYnLFxuICAndGl0bGUnLFxuICAndG9jJyxcbiAgJ3RvZGF5JyxcbiAgJ3RvbGwnLFxuICAndG9uYWxpdHknLFxuICAndG91Y2hfYXBwJyxcbiAgJ3RveXMnLFxuICAndHJhY2tfY2hhbmdlcycsXG4gICd0cmFpbicsXG4gICd0cmFtJyxcbiAgJ3RyYW5zZmVyX3dpdGhpbl9hX3N0YXRpb24nLFxuICAndHJhbnNmb3JtJyxcbiAgJ3RyYW5zbGF0ZScsXG4gICd0cmVuZGluZ19kb3duJyxcbiAgJ3RyZW5kaW5nX2ZsYXQnLFxuICAndHJlbmRpbmdfdXAnLFxuICAndHVuZScsXG4gICd0dXJuZWRfaW4nLFxuICAndHVybmVkX2luX25vdCcsXG4gICd0dicsXG4gICd1bmFyY2hpdmUnLFxuICAndW5kbycsXG4gICd1bmZvbGRfbGVzcycsXG4gICd1bmZvbGRfbW9yZScsXG4gICd1cGRhdGUnLFxuICAndXNiJyxcbiAgJ3ZlcmlmaWVkX3VzZXInLFxuICAndmVydGljYWxfYWxpZ25fYm90dG9tJyxcbiAgJ3ZlcnRpY2FsX2FsaWduX2NlbnRlcicsXG4gICd2ZXJ0aWNhbF9hbGlnbl90b3AnLFxuICAndmlicmF0aW9uJyxcbiAgJ3ZpZGVvX2NhbGwnLFxuICAndmlkZW9fbGFiZWwnLFxuICAndmlkZW9fbGlicmFyeScsXG4gICd2aWRlb2NhbScsXG4gICd2aWRlb2NhbV9vZmYnLFxuICAndmlkZW9nYW1lX2Fzc2V0JyxcbiAgJ3ZpZXdfYWdlbmRhJyxcbiAgJ3ZpZXdfYXJyYXknLFxuICAndmlld19jYXJvdXNlbCcsXG4gICd2aWV3X2NvbHVtbicsXG4gICd2aWV3X2NvbWZ5JyxcbiAgJ3ZpZXdfY29tcGFjdCcsXG4gICd2aWV3X2RheScsXG4gICd2aWV3X2hlYWRsaW5lJyxcbiAgJ3ZpZXdfbGlzdCcsXG4gICd2aWV3X21vZHVsZScsXG4gICd2aWV3X3F1aWx0JyxcbiAgJ3ZpZXdfc3RyZWFtJyxcbiAgJ3ZpZXdfd2VlaycsXG4gICd2aWduZXR0ZScsXG4gICd2aXNpYmlsaXR5JyxcbiAgJ3Zpc2liaWxpdHlfb2ZmJyxcbiAgJ3ZvaWNlX2NoYXQnLFxuICAndm9pY2VtYWlsJyxcbiAgJ3ZvbHVtZV9kb3duJyxcbiAgJ3ZvbHVtZV9tdXRlJyxcbiAgJ3ZvbHVtZV9vZmYnLFxuICAndm9sdW1lX3VwJyxcbiAgJ3Zwbl9rZXknLFxuICAndnBuX2xvY2snLFxuICAnd2FsbHBhcGVyJyxcbiAgJ3dhcm5pbmcnLFxuICAnd2F0Y2gnLFxuICAnd2F0Y2hfbGF0ZXInLFxuICAnd2JfYXV0bycsXG4gICd3Yl9jbG91ZHknLFxuICAnd2JfaW5jYW5kZXNjZW50JyxcbiAgJ3diX2lyaWRlc2NlbnQnLFxuICAnd2Jfc3VubnknLFxuICAnd2MnLFxuICAnd2ViJyxcbiAgJ3dlYl9hc3NldCcsXG4gICd3ZWVrZW5kJyxcbiAgJ3doYXRzaG90JyxcbiAgJ3dpZGdldHMnLFxuICAnd2lmaScsXG4gICd3aWZpX2xvY2snLFxuICAnd2lmaV90ZXRoZXJpbmcnLFxuICAnd29yaycsXG4gICd3cmFwX3RleHQnLFxuICAneW91dHViZV9zZWFyY2hlZF9mb3InLFxuICAnem9vbV9pbicsXG4gICd6b29tX291dCcsXG4gICd6b29tX291dF9tYXAnLFxuXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2RlZmF1bHQgYXMgV2ViRm9udH0gZnJvbSAnd2ViZm9udGxvYWRlcic7XG5cbmltcG9ydCB7RmllbGQsIFRleHRGaWVsZCwgUmFuZ2VGaWVsZCwgQm9vbGVhbkZpZWxkLCBBdXRvY29tcGxldGVUZXh0RmllbGQsIEVudW1GaWVsZH0gZnJvbSAnLi9maWVsZHMnO1xuaW1wb3J0IHtGb3JtfSBmcm9tICcuL2Zvcm1zJztcbmltcG9ydCB7VXRpbH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uL2ltYWdlbGliJztcbmltcG9ydCB7Y2xpcGFydE5hbWVzfSBmcm9tICcuL2ltYWdlZmllbGQtY2xpcGFydCc7XG5cblxuY29uc3QgV0VCX0ZPTlRTX0FQSV9LRVkgPSAnQUl6YVN5QXRTZTh3bFhQQ1VhTFE0TFR5UEtwYnpCQlBKQXpFWG1VJztcbmNvbnN0IFdFQl9GT05UU19BUElfVVJMID0gYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL3dlYmZvbnRzL3YxL3dlYmZvbnRzP2tleT0ke1dFQl9GT05UU19BUElfS0VZfSZmaWVsZHM9aXRlbXMoZmFtaWx5KWA7XG5jb25zdCBXRUJfRk9OVFNfQ0FDSEVfVElNRSA9IDYwICogNjAgKiAxMDAwOyAvLyAxIGhvdXJcblxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmb3JtIGZpZWxkIGZvciBpbWFnZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZUZpZWxkIGV4dGVuZHMgRmllbGQge1xuICBjb25zdHJ1Y3RvcihpZCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoaWQsIHBhcmFtcyk7XG4gICAgdGhpcy52YWx1ZVR5cGVfID0gbnVsbDtcbiAgICB0aGlzLnRleHRQYXJhbXNfID0ge307XG4gICAgdGhpcy5pbWFnZVBhcmFtc18gPSB7fTtcbiAgICB0aGlzLnNwYWNlRm9ybVZhbHVlc18gPSB7fTsgLy8gY2FjaGVcbiAgfVxuXG4gIGNyZWF0ZVVpKGNvbnRhaW5lcikge1xuICAgIHZhciBmaWVsZFVJID0gc3VwZXIuY3JlYXRlVWkoY29udGFpbmVyKTtcbiAgICB2YXIgZmllbGRDb250YWluZXIgPSAkKCcuZm9ybS1maWVsZC1jb250YWluZXInLCBmaWVsZFVJKTtcblxuICAgIC8vIFNldCB1cCBkcmFnK2Ryb3Agb24gdGhlIGVudGlyZSBmaWVsZCBjb250YWluZXJcbiAgICBmaWVsZFVJLmFkZENsYXNzKCdmb3JtLWZpZWxkLWltYWdlJyk7XG4gICAgdGhpcy5zZXR1cERyb3BUYXJnZXRfKGZpZWxkVUkpO1xuXG4gICAgLy8gQ3JlYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICB0aGlzLmVsXyA9ICQoJzxkaXY+JylcbiAgICAgICAgLmF0dHIoJ2lkJywgdGhpcy5nZXRIdG1sSWQoKSlcbiAgICAgICAgLmFkZENsYXNzKCdmb3JtLWZpZWxkLWJ1dHRvbnNldCcpXG4gICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICB2YXIgdHlwZXM7XG4gICAgaWYgKHRoaXMucGFyYW1zXy5pbWFnZU9ubHkpIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICBbJ2ltYWdlJywgJ1NlbGVjdCBpbWFnZSddXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgWydpbWFnZScsICdJbWFnZSddLFxuICAgICAgICBbJ2NsaXBhcnQnLCAnQ2xpcGFydCddLFxuICAgICAgICBbJ3RleHQnLCAnVGV4dCddXG4gICAgICBdO1xuICAgIH1cblxuICAgIHZhciB0eXBlRWxzID0ge307XG5cbiAgICB0eXBlcy5mb3JFYWNoKChbaWQsIGxhYmVsXSkgPT4ge1xuICAgICAgJCgnPGlucHV0PicpXG4gICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0SHRtbElkKCksXG4gICAgICAgICAgICBpZDogYCR7dGhpcy5nZXRIdG1sSWQoKX0tJHtpZH1gLFxuICAgICAgICAgICAgdmFsdWU6IGlkXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXBwZW5kVG8odGhpcy5lbF8pO1xuICAgICAgdHlwZUVsc1tpZF0gPSAkKCc8bGFiZWw+JylcbiAgICAgICAgICAuYXR0cignZm9yJywgYCR7dGhpcy5nZXRIdG1sSWQoKX0tJHtpZH1gKVxuICAgICAgICAgIC5hdHRyKCd0YWJpbmRleCcsIDApXG4gICAgICAgICAgLnRleHQobGFiZWwpXG4gICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcbiAgICB9KTtcblxuICAgIC8vIFByZXBhcmUgVUkgZm9yIHRoZSAnaW1hZ2UnIHR5cGVcbiAgICB0aGlzLmZpbGVFbF8gPSAkKCc8aW5wdXQ+JylcbiAgICAgICAgLmFkZENsYXNzKCdmb3JtLWltYWdlLWhpZGRlbi1maWxlLWZpZWxkJylcbiAgICAgICAgLmF0dHIoe1xuICAgICAgICAgIGlkOiB0aGlzLmdldEh0bWxJZCgpLFxuICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICBhY2NlcHQ6ICdpbWFnZS8qJ1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICBJbWFnZUZpZWxkLmxvYWRJbWFnZUZyb21GaWxlTGlzdCh0aGlzLmZpbGVFbF8uZ2V0KDApLmZpbGVzKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVUeXBlXygnaW1hZ2UnKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VQYXJhbXNfID0gcmV0O1xuICAgICAgICAgICAgdGhpcy52YWx1ZUZpbGVuYW1lXyA9IHJldC5uYW1lLnJlcGxhY2UoL1xcLlteLl0rPyQvLCAnJyk7IC8vIGJhc2VuYW1lXG4gICAgICAgICAgICB0aGlzLnJlbmRlclZhbHVlQW5kTm90aWZ5Q2hhbmdlZF8oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcblxuICAgIHR5cGVFbHMuaW1hZ2UuY2xpY2soZXZ0ID0+IHtcbiAgICAgIHRoaXMuZmlsZUVsXy50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgdGhpcy5zZXRWYWx1ZVR5cGVfKG51bGwpO1xuICAgICAgdGhpcy5yZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8vIFByZXBhcmUgVUkgZm9yIHRoZSAnY2xpcGFydCcgdHlwZVxuICAgIGlmICghdGhpcy5wYXJhbXNfLmltYWdlT25seSkge1xuICAgICAgbGV0IGNsaXBhcnRQYXJhbXNFbCA9ICQoJzxkaXY+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0taW1hZ2UtdHlwZS1wYXJhbXMgZm9ybS1pbWFnZS10eXBlLXBhcmFtcy1jbGlwYXJ0IGlzLWhpZGRlbicpXG4gICAgICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcblxuICAgICAgbGV0IGNsaXBhcnRMaXN0RWwgPSAkKCc8ZGl2PicpXG4gICAgICAgICAgLmFkZENsYXNzKCdmb3JtLWltYWdlLWNsaXBhcnQtbGlzdCcpXG4gICAgICAgICAgLmFkZENsYXNzKCdjYW5jZWwtcGFyZW50LXNjcm9sbCcpXG4gICAgICAgICAgLmFwcGVuZFRvKGNsaXBhcnRQYXJhbXNFbCk7XG5cbiAgICAgIGNsaXBhcnROYW1lcy5mb3JFYWNoKGNsaXBhcnRTcmMgPT4ge1xuICAgICAgICAkKCc8ZGl2PicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0taW1hZ2UtY2xpcGFydC1pdGVtJylcbiAgICAgICAgICAgIC5hdHRyKCdkYXRhLW5hbWUnLCBjbGlwYXJ0U3JjKVxuICAgICAgICAgICAgLmF0dHIoJ3RpdGxlJywgY2xpcGFydFNyYylcbiAgICAgICAgICAgIC50ZXh0KGNsaXBhcnRTcmMpXG4gICAgICAgICAgICAuY2xpY2soKCkgPT4gdGhpcy5sb2FkQ2xpcGFydF8oY2xpcGFydFNyYykpXG4gICAgICAgICAgICAuYXBwZW5kVG8oY2xpcGFydExpc3RFbCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kY2xpcGFydEl0ZW1zID0gY2xpcGFydExpc3RFbC5maW5kKCcuZm9ybS1pbWFnZS1jbGlwYXJ0LWl0ZW0nKTtcblxuICAgICAgbGV0IGNsaXBhcnRGaWx0ZXJFbCA9ICQoJzxpbnB1dD4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0taW1hZ2UtY2xpcGFydC1maWx0ZXInKVxuICAgICAgICAuYXR0cigncGxhY2Vob2xkZXInLCAnRmluZCBjbGlwYXJ0JylcbiAgICAgICAgLm9uKCdpbnB1dCcsIGV2ID0+IHtcbiAgICAgICAgICBsZXQgJGZpbHRlciA9ICQoZXYuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgbGV0IHZhbCA9ICRmaWx0ZXIudmFsKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXlxcd10rL2csICcnKTtcbiAgICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgdGhpcy4kY2xpcGFydEl0ZW1zLnNob3coKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kY2xpcGFydEl0ZW1zLmVhY2goKF8sIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgJChpdGVtKS50b2dnbGUoJChpdGVtKS5hdHRyKCd0aXRsZScpLmluZGV4T2YodmFsKSA+PSAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnByZXBlbmRUbyhjbGlwYXJ0UGFyYW1zRWwpO1xuXG4gICAgICB2YXIgY2xpcGFydEF0dHJpYnV0aW9uRWwgPSAkKCc8ZGl2PicpXG4gICAgICAgICAgLmFkZENsYXNzKCdmb3JtLWltYWdlLWNsaXBhcnQtYXR0cmlidXRpb24nKVxuICAgICAgICAgIC5odG1sKGBcbiAgICAgICAgICAgICAgRm9yIGNsaXBhcnQgc291cmNlcywgdmlzaXRcbiAgICAgICAgICAgICAgPGEgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgICAgY2xhc3M9XCJleHRlcm5hbC1saW5rXCJcbiAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvbWF0ZXJpYWwtZGVzaWduLWljb25zXCI+XG4gICAgICAgICAgICAgIE1hdGVyaWFsIERlc2lnbiBJY29ucyBvbiBHaXRIdWI8L2E+XG4gICAgICAgICAgICAgIGApXG4gICAgICAgICAgLmFwcGVuZFRvKGNsaXBhcnRQYXJhbXNFbCk7XG5cbiAgICAgIHR5cGVFbHMuY2xpcGFydC5jbGljayhldnQgPT4ge1xuICAgICAgICB0aGlzLnNldFZhbHVlVHlwZV8oJ2NsaXBhcnQnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJlcGFyZSBVSSBmb3IgdGhlICd0ZXh0JyB0eXBlXG4gICAgICB2YXIgdGV4dFBhcmFtc0VsID0gJCgnPGRpdj4nKVxuICAgICAgICAgIC5hZGRDbGFzcygnZm9ybS1zdWJmb3JtIGZvcm0taW1hZ2UtdHlwZS1wYXJhbXMgZm9ybS1pbWFnZS10eXBlLXBhcmFtcy10ZXh0IGlzLWhpZGRlbicpXG4gICAgICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcblxuICAgICAgbGV0IGZvbnRGYW1pbHlGaWVsZDtcbiAgICAgIHRoaXMudGV4dEZvcm1fID0gbmV3IEZvcm0oe1xuICAgICAgICBpZDogYCR7dGhpcy5mb3JtXy5pZF99LSR7dGhpcy5pZF99LXRleHRmb3JtYCxcbiAgICAgICAgY29udGFpbmVyOiB0ZXh0UGFyYW1zRWwsXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIG5ldyBUZXh0RmllbGQoJ3RleHQnLCB7XG4gICAgICAgICAgICB0aXRsZTogJ1RleHQnLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIChmb250RmFtaWx5RmllbGQgPSBuZXcgRW51bUZpZWxkKCdmb250Jywge1xuICAgICAgICAgICAgdGl0bGU6ICdGb250JyxcbiAgICAgICAgICAgIGhlbHBUZXh0OiAnRnJvbSBmb250cy5nb29nbGUuY29tJ1xuICAgICAgICAgIH0pKVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9hZEdvb2dsZVdlYkZvbnRzTGlzdF8oKS50aGVuKGZvbnRzID0+IGZvbnRGYW1pbHlGaWVsZC5zZXRPcHRpb25zKFsnJ10uY29uY2F0KGZvbnRzKSkpO1xuXG4gICAgICBsZXQgdHJ5TG9hZFdlYkZvbnREZWJvdW5jZWRfID0gVXRpbC5kZWJvdW5jZSg1MDAsICgpID0+IHRoaXMudHJ5TG9hZFdlYkZvbnRfKCkpO1xuICAgICAgdGhpcy50ZXh0Rm9ybV8ub25DaGFuZ2UoKCkgPT4ge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy50ZXh0Rm9ybV8uZ2V0VmFsdWVzKCk7XG4gICAgICAgIHRoaXMudGV4dFBhcmFtc18udGV4dCA9IHZhbHVlc1sndGV4dCddO1xuICAgICAgICB0aGlzLnRleHRQYXJhbXNfLmZvbnRTdGFjayA9IHZhbHVlc1snZm9udCddXG4gICAgICAgICAgICA/IHZhbHVlc1snZm9udCddIDogJ1JvYm90bywgc2Fucy1zZXJpZic7XG4gICAgICAgIHRoaXMudmFsdWVGaWxlbmFtZV8gPSB2YWx1ZXNbJ3RleHQnXTtcbiAgICAgICAgdHJ5TG9hZFdlYkZvbnREZWJvdW5jZWRfKCk7XG4gICAgICAgIHRoaXMucmVuZGVyVmFsdWVBbmROb3RpZnlDaGFuZ2VkXygpO1xuICAgICAgfSk7XG5cbiAgICAgIHR5cGVFbHMudGV4dC5jbGljayhldnQgPT4ge1xuICAgICAgICB0aGlzLnNldFZhbHVlVHlwZV8oJ3RleHQnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc3BhY2luZyBzdWJmb3JtXG4gICAgaWYgKCF0aGlzLnBhcmFtc18ubm9UcmltRm9ybSkge1xuICAgICAgbGV0IHNwYWNlRm9ybUNvbnRhaW5lciA9ICQoJzxkaXY+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0tc3ViZm9ybScpXG4gICAgICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuc3BhY2VGb3JtVmFsdWVzXyA9IHt9O1xuICAgICAgdGhpcy5zcGFjZUZvcm1fID0gbmV3IEZvcm0oe1xuICAgICAgICBpZDogYCR7dGhpcy5mb3JtXy5pZF99LSR7dGhpcy5pZF99LXNwYWNlZm9ybWAsXG4gICAgICAgIGNvbnRhaW5lcjogc3BhY2VGb3JtQ29udGFpbmVyLFxuICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAodGhpcy5zcGFjZUZvcm1UcmltRmllbGRfID0gbmV3IEJvb2xlYW5GaWVsZCgndHJpbScsIHtcbiAgICAgICAgICAgIHRpdGxlOiAnVHJpbSB3aGl0ZXNwYWNlJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIG9mZlRleHQ6IGBEb24ndCB0cmltYCxcbiAgICAgICAgICAgIG9uVGV4dDogJ1RyaW0nXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgICh0aGlzLnNwYWNlRm9ybVBhZGRpbmdGaWVsZF8gPSBuZXcgUmFuZ2VGaWVsZCgncGFkJywge1xuICAgICAgICAgICAgdGl0bGU6ICdQYWRkaW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGhpcy5wYXJhbXNfLmRlZmF1bHRWYWx1ZVBhZGRpbmcgfHwgMCxcbiAgICAgICAgICAgIG1pbjogLTAuMSxcbiAgICAgICAgICAgIG1heDogMC41LCAvLyAxLzIgb2YgbWluKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgICAgICBzdGVwOiAwLjA1LFxuICAgICAgICAgICAgdGV4dEZuKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh2ICogMTAwKS50b0ZpeGVkKDApICsgJyUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSxcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNwYWNlRm9ybV8ub25DaGFuZ2UoKCkgPT4ge1xuICAgICAgICB0aGlzLnNwYWNlRm9ybVZhbHVlc18gPSB0aGlzLnNwYWNlRm9ybV8uZ2V0VmFsdWVzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyVmFsdWVBbmROb3RpZnlDaGFuZ2VkXygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNwYWNlRm9ybVZhbHVlc18gPSB0aGlzLnNwYWNlRm9ybV8uZ2V0VmFsdWVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3BhY2VGb3JtVmFsdWVzXyA9IHt9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBpbWFnZSBwcmV2aWV3IGVsZW1lbnRcbiAgICBpZiAoIXRoaXMucGFyYW1zXy5ub1ByZXZpZXcpIHtcbiAgICAgIHRoaXMuaW1hZ2VQcmV2aWV3XyA9ICQoJzxjYW52YXM+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0taW1hZ2UtcHJldmlldycpXG4gICAgICAgICAgLmhpZGUoKVxuICAgICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lci5wYXJlbnQoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWVDbGlwYXJ0KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlVHlwZV8pIHtcbiAgICAgICAgICB0aGlzLmxvYWRDbGlwYXJ0Xyh0aGlzLnBhcmFtc18uZGVmYXVsdFZhbHVlQ2xpcGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwRHJvcFRhcmdldF8oZWwpIHtcbiAgICBsZXQgJGVsID0gdGhpcy5wYXJhbXNfLmRyb3BUYXJnZXRcbiAgICAgICAgPyAkKHRoaXMucGFyYW1zXy5kcm9wVGFyZ2V0KVxuICAgICAgICA6ICQoZWwpO1xuICAgIGxldCBlbnRlckxlYXZlVGltZW91dDtcblxuICAgICRlbFxuICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0tZmllbGQtZHJvcC10YXJnZXQnKVxuICAgICAgICAub24oJ2RyYWdlbnRlcicsIGV2ID0+IHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmIChlbnRlckxlYXZlVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVudGVyTGVhdmVUaW1lb3V0KTtcbiAgICAgICAgICAgIGVudGVyTGVhdmVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgJGVsLmFkZENsYXNzKCdkcmFnLWhvdmVyJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2xlYXZlJywgZXYgPT4ge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKGVudGVyTGVhdmVUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZW50ZXJMZWF2ZVRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnRlckxlYXZlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gJGVsLnJlbW92ZUNsYXNzKCdkcmFnLWhvdmVyJyksIDEwMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ292ZXInLCBldiA9PiB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoZW50ZXJMZWF2ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlbnRlckxlYXZlVGltZW91dCk7XG4gICAgICAgICAgICBlbnRlckxlYXZlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJvcCcsIGV2ID0+IHtcbiAgICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoJ2RyYWctaG92ZXInKTtcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIEltYWdlRmllbGQubG9hZEltYWdlRnJvbUZpbGVMaXN0KGV2Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKVxuICAgICAgICAgICAgICAudGhlbihyZXQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVR5cGVfKCdpbWFnZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VQYXJhbXNfID0gcmV0O1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVGaWxlbmFtZV8gPSByZXQubmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZhbHVlQW5kTm90aWZ5Q2hhbmdlZF8oKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICB9XG5cbiAgbG9hZEdvb2dsZVdlYkZvbnRzTGlzdF8oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICgnYXNzZXRTdHVkaW9XZWJGb250c0NhY2hlJyBpbiBsb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgbGV0IHtmZXRjaFRpbWUsIGZvbnRzfSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmFzc2V0U3R1ZGlvV2ViRm9udHNDYWNoZSk7XG4gICAgICAgIGlmIChOdW1iZXIobmV3IERhdGUoKSkgLSBmZXRjaFRpbWUgPCBXRUJfRk9OVFNfQ0FDSEVfVElNRSkge1xuICAgICAgICAgIC8vIHVzZSBjYWNoZVxuICAgICAgICAgIHJlc29sdmUoZm9udHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6IFdFQl9GT05UU19BUElfVVJMLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICBsZXQgZm9udHMgPSBkYXRhLml0ZW1zLm1hcChpdGVtID0+IGl0ZW0uZmFtaWx5KTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLmFzc2V0U3R1ZGlvV2ViRm9udHNDYWNoZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBmZXRjaFRpbWU6IE51bWJlcihuZXcgRGF0ZSgpKSxcbiAgICAgICAgICBmb250c1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzb2x2ZShmb250cyk7XG4gICAgICB9LCBlID0+IHJlamVjdChlKSk7XG4gICAgfSk7XG4gIH1cblxuICB0cnlMb2FkV2ViRm9udF8oKSB7XG4gICAgbGV0IGRlc2lyZWRGb250ID0gdGhpcy50ZXh0Rm9ybV8uZ2V0VmFsdWVzKCkuZm9udDtcbiAgICBpZiAodGhpcy5sb2FkZWRXZWJGb250XyA9PSBkZXNpcmVkRm9udCB8fCAhZGVzaXJlZEZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBXZWJGb250LmxvYWQoe1xuICAgICAgZ29vZ2xlOiB7XG4gICAgICAgIGZhbWlsaWVzOiBbZGVzaXJlZEZvbnRdXG4gICAgICB9LFxuICAgICAgYWN0aXZlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9hZGVkV2ViRm9udF8gPSBkZXNpcmVkRm9udDtcbiAgICAgICAgdGhpcy5yZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRWYWx1ZVR5cGVfKHR5cGUpIHtcbiAgICB0aGlzLnZhbHVlVHlwZV8gPSB0eXBlO1xuICAgICQoJ2lucHV0JywgdGhpcy5lbF8pLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgJCgnLmZvcm0taW1hZ2UtdHlwZS1wYXJhbXMnLCB0aGlzLmVsXy5wYXJlbnQoKSkuYWRkQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICAkKCcjJyArIHRoaXMuZ2V0SHRtbElkKCkgKyAnLScgKyB0eXBlKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG4gICAgICAkKCcuZm9ybS1pbWFnZS10eXBlLXBhcmFtcy0nICsgdHlwZSwgdGhpcy5lbF8ucGFyZW50KCkpLnJlbW92ZUNsYXNzKCdpcy1oaWRkZW4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zcGFjZUZvcm1fKSB7XG4gICAgICB0aGlzLnNwYWNlRm9ybVRyaW1GaWVsZF8uc2V0RW5hYmxlZCh0cnVlKTtcbiAgICAgIHRoaXMuc3BhY2VGb3JtUGFkZGluZ0ZpZWxkXy5zZXRFbmFibGVkKHRydWUpO1xuICAgICAgaWYgKHR5cGUgPT0gJ2NsaXBhcnQnKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtc18uY2xpcGFydE5vVHJpbVBhZGRpbmcpIHtcbiAgICAgICAgICB0aGlzLnNwYWNlRm9ybVRyaW1GaWVsZF8uc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgdGhpcy5zcGFjZUZvcm1UcmltRmllbGRfLnNldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLnNwYWNlRm9ybVBhZGRpbmdGaWVsZF8uc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgdGhpcy5zcGFjZUZvcm1QYWRkaW5nRmllbGRfLnNldFZhbHVlKDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICAgIHRoaXMuc3BhY2VGb3JtVHJpbUZpZWxkXy5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgdGhpcy5zcGFjZUZvcm1UcmltRmllbGRfLnNldFZhbHVlKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWRDbGlwYXJ0XyhjbGlwYXJ0U3JjKSB7XG4gICAgdGhpcy4kY2xpcGFydEl0ZW1zLnJlbW92ZUNsYXNzKCdpcy1zZWxlY3RlZCcpO1xuICAgIHRoaXMuJGNsaXBhcnRJdGVtcy5maWx0ZXIoYFtkYXRhLW5hbWU9XCIke2NsaXBhcnRTcmN9XCJdYCkuYWRkQ2xhc3MoJ2lzLXNlbGVjdGVkJyk7XG5cbiAgICB0aGlzLnNldFZhbHVlVHlwZV8oJ2NsaXBhcnQnKTtcbiAgICB0aGlzLmNsaXBhcnRTcmNfID0gY2xpcGFydFNyYztcbiAgICB0aGlzLnZhbHVlRmlsZW5hbWVfID0gY2xpcGFydFNyYztcbiAgICB0aGlzLnJlbmRlclZhbHVlQW5kTm90aWZ5Q2hhbmdlZF8oKTtcbiAgfVxuXG4gIGNsZWFyVmFsdWUoKSB7XG4gICAgdGhpcy52YWx1ZVR5cGVfID0gbnVsbDtcbiAgICB0aGlzLnZhbHVlRmlsZW5hbWVfID0gbnVsbDtcbiAgICB0aGlzLnZhbHVlQ3R4XyA9IG51bGw7XG4gICAgdGhpcy52YWx1ZU9yaWdJbWdfID0gbnVsbDtcbiAgICB0aGlzLmZpbGVFbF8udmFsKCcnKTtcbiAgICBpZiAodGhpcy5pbWFnZVByZXZpZXdfKSB7XG4gICAgICB0aGlzLmltYWdlUHJldmlld18uaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjdHg6IHRoaXMudmFsdWVDdHhfLFxuICAgICAgb3JpZ0ltZzogdGhpcy52YWx1ZU9yaWdJbWdfLFxuICAgICAgdHlwZTogdGhpcy52YWx1ZVR5cGVfLFxuICAgICAgbmFtZTogdGhpcy52YWx1ZUZpbGVuYW1lX1xuICAgIH07XG4gIH1cblxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGFzeW5jaHJvbm91c1xuICByZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVR5cGVfKSB7XG4gICAgICB0aGlzLnZhbHVlQ3R4XyA9IG51bGw7XG4gICAgICB0aGlzLnZhbHVlT3JpZ0ltZ18gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlclRpbWVvdXRfKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZW5kZXJUaW1lb3V0Xyk7XG4gICAgICB0aGlzLnJlbmRlclRpbWVvdXRfID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJpbmdfKSB7XG4gICAgICB0aGlzLnJlbmRlclRpbWVvdXRfID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlbmRlclZhbHVlQW5kTm90aWZ5Q2hhbmdlZF8oKSwgMTAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmluZ18gPSB0cnVlO1xuXG4gICAgdGhpcy5yZW5kZXJTb3VyY2VfKClcbiAgICAgICAgLnRoZW4oKHtjdHgsIHNpemV9KSA9PiB7XG4gICAgICAgICAgdGhpcy5jb21wdXRlVHJpbVJlY3RfKGN0eCwgc2l6ZSlcbiAgICAgICAgICAgICAgLnRoZW4odHJpbVJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwYWQgPSB0aGlzLnNwYWNlRm9ybVZhbHVlc18ucGFkIHx8IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhZFB4ID0gTWF0aC5yb3VuZChwYWQgKiBNYXRoLm1pbih0cmltUmVjdC53LCB0cmltUmVjdC5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUN0eF8gPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgdzogdHJpbVJlY3QudyArIHBhZFB4ICogMixcbiAgICAgICAgICAgICAgICAgIGg6IHRyaW1SZWN0LmggKyBwYWRQeCAqIDJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ3R4Xy5kcmF3SW1hZ2UoY3R4LmNhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgdHJpbVJlY3QueCwgdHJpbVJlY3QueSwgdHJpbVJlY3QudywgdHJpbVJlY3QuaCxcbiAgICAgICAgICAgICAgICAgICAgcGFkUHgsIHBhZFB4LCB0cmltUmVjdC53LCB0cmltUmVjdC5oKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmltYWdlUHJldmlld18pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VQcmV2aWV3Xy5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMudmFsdWVDdHhfLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnZhbHVlQ3R4Xy5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgbGV0IHByZXZpZXdDdHggPSB0aGlzLmltYWdlUHJldmlld18uZ2V0KDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICBwcmV2aWV3Q3R4LmRyYXdJbWFnZSh0aGlzLnZhbHVlQ3R4Xy5jYW52YXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZVByZXZpZXdfLnNob3coKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmluZ18gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1fLm5vdGlmeUNoYW5nZWRfKHRoaXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6ICcgKyBlKTtcbiAgICAgICAgICB0aGlzLnJlbmRlcmluZ18gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gIH1cblxuICByZW5kZXJTb3VyY2VfKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGJhc2UgaW1hZ2UgKHRleHQsIGNsaXBhcnQsIG9yIGltYWdlKVxuICAgICAgc3dpdGNoICh0aGlzLnZhbHVlVHlwZV8pIHtcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAvLyBjYXNlICdjbGlwYXJ0JzpcbiAgICAgICAgICBpZiAodGhpcy5pbWFnZVBhcmFtc18udXJpKSB7XG4gICAgICAgICAgICBVdGlsLmxvYWRJbWFnZUZyb21VcmkodGhpcy5pbWFnZVBhcmFtc18udXJpKVxuICAgICAgICAgICAgICAgIC50aGVuKGltZyA9PiB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlT3JpZ0ltZ18gPSBpbWc7XG4gICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdzogaW1nLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaDogaW1nLm5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbWFnZVBhcmFtc18uaXNTdmcgJiYgdGhpcy5wYXJhbXNfLm1heEZpbmFsU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHc6IHRoaXMucGFyYW1zXy5tYXhGaW5hbFNpemUudyxcbiAgICAgICAgICAgICAgICAgICAgICBoOiB0aGlzLnBhcmFtc18ubWF4RmluYWxTaXplLmhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG4gICAgICAgICAgICAgICAgICBpbWFnZWxpYi5EcmF3aW5nLmNvcHkoY3R4LCBpbWcsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7Y3R4LCBzaXplfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCgnbm8gdXJpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NsaXBhcnQnOlxuICAgICAgICAgIHZhciBzaXplID0geyB3OiAxNTM2LCBoOiAxNTM2IH07XG4gICAgICAgICAgdmFyIGN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChzaXplKTtcbiAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY2xpcGFydFNyY187XG5cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuICAgICAgICAgIGN0eC5mb250ID0gYCR7c2l6ZS5ofXB4LyR7c2l6ZS5ofXB4ICdNYXRlcmlhbCBJY29ucydgO1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIDAsIHNpemUuaCk7XG5cbiAgICAgICAgICByZXNvbHZlKHtjdHgsIHNpemV9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICB2YXIgc2l6ZSA9IHsgdzogNjE0NCwgaDogMTUzNiB9O1xuICAgICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gc2l6ZS5oICogMC43NTtcbiAgICAgICAgICB2YXIgY3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0UGFyYW1zXy50ZXh0IHx8ICcnO1xuICAgICAgICAgIHRleHQgPSAnICcgKyB0ZXh0ICsgJyAnO1xuXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICAgICAgICBjdHguZm9udCA9IGBib2xkICR7dGV4dEhlaWdodH1weC8ke3NpemUuaH1weCAke3RoaXMudGV4dFBhcmFtc18uZm9udFN0YWNrfWA7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgMCwgdGV4dEhlaWdodCk7XG4gICAgICAgICAgc2l6ZS53ID0gTWF0aC5jZWlsKE1hdGgubWluKGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCwgc2l6ZS53KSB8fCBzaXplLncpO1xuXG4gICAgICAgICAgcmVzb2x2ZSh7Y3R4LCBzaXplfSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWplY3QoJ05vIHZhbHVlIHR5cGUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbXB1dGVUcmltUmVjdF8oY3R4LCBzaXplKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnNwYWNlRm9ybVZhbHVlc18udHJpbSkge1xuICAgICAgICBpZiAodGhpcy50cmltUHJvbWlzZV8gJiYgdGhpcy50cmltUHJvbWlzZV8ud29ya2VyKSB7XG4gICAgICAgICAgdGhpcy50cmltUHJvbWlzZV8ud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmltUHJvbWlzZV8gPSBpbWFnZWxpYi5BbmFseXNpcy5nZXRUcmltUmVjdChjdHgsIHNpemUsIDEpXG4gICAgICAgICAgICAudGhlbih0cmltUmVjdCA9PiB7XG4gICAgICAgICAgICAgIGxldCBwYWQgPSBNYXRoLm1pbihzaXplLncsIHNpemUuaCkgKiAuMDE7XG4gICAgICAgICAgICAgIC8vIHBhZCBhIGxpdHRsZSBiaXQgdG8gYXZvaWQgZWRnZSBhcnRpZmFjdHNcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0cmltUmVjdCwge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgubWF4KE1hdGguZmxvb3IodHJpbVJlY3QueCAtIHBhZCksIDApLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KE1hdGguZmxvb3IodHJpbVJlY3QueSAtIHBhZCksIDApLFxuICAgICAgICAgICAgICAgIHc6IE1hdGguY2VpbCh0cmltUmVjdC53ICsgcGFkICogMiksXG4gICAgICAgICAgICAgICAgaDogTWF0aC5jZWlsKHRyaW1SZWN0LmggKyBwYWQgKiAyKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdHJpbVJlY3QudyA9IE1hdGgubWluKHRyaW1SZWN0LncsIHNpemUudyAtIHRyaW1SZWN0LngpO1xuICAgICAgICAgICAgICB0cmltUmVjdC5oID0gTWF0aC5taW4odHJpbVJlY3QuaCwgc2l6ZS5oIC0gdHJpbVJlY3QueSk7XG4gICAgICAgICAgICAgIHJlc29sdmUodHJpbVJlY3QpO1xuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoeyB4OiAwLCB5OiAwLCB3OiBzaXplLncsIGg6IHNpemUuaCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNlcmlhbGl6ZVZhbHVlKCkge1xuICAgIGxldCB2YWxzID0ge1xuICAgICAgdHlwZTogdGhpcy52YWx1ZVR5cGVfLFxuICAgICAgY2xpcGFydDogKHRoaXMudmFsdWVUeXBlXyA9PSAnY2xpcGFydCcpID8gdGhpcy5jbGlwYXJ0U3JjXyA6IG51bGwsXG4gICAgICB0ZXh0OiAodGhpcy52YWx1ZVR5cGVfID09ICd0ZXh0JykgPyB0aGlzLnRleHRGb3JtXy5nZXRWYWx1ZXNTZXJpYWxpemVkKCkgOiBudWxsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNwYWNlRm9ybV8pIHtcbiAgICAgIHZhbHMuc3BhY2UgPSB0aGlzLnNwYWNlRm9ybV8uZ2V0VmFsdWVzU2VyaWFsaXplZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxzO1xuICB9XG5cbiAgZGVzZXJpYWxpemVWYWx1ZShvKSB7XG4gICAgaWYgKG8udHlwZSkge1xuICAgICAgdGhpcy5zZXRWYWx1ZVR5cGVfKG8udHlwZSk7XG4gICAgfVxuICAgIGlmIChvLnNwYWNlKSB7XG4gICAgICB0aGlzLnNwYWNlRm9ybV8uc2V0VmFsdWVzU2VyaWFsaXplZChvLnNwYWNlKTtcbiAgICAgIHRoaXMuc3BhY2VGb3JtVmFsdWVzXyA9IHRoaXMuc3BhY2VGb3JtXy5nZXRWYWx1ZXMoKTtcbiAgICB9XG4gICAgaWYgKG8uY2xpcGFydCAmJiB0aGlzLnZhbHVlVHlwZV8gPT0gJ2NsaXBhcnQnKSB7XG4gICAgICB0aGlzLmxvYWRDbGlwYXJ0XyhvLmNsaXBhcnQpO1xuICAgIH1cbiAgICBpZiAoby50ZXh0ICYmIHRoaXMudmFsdWVUeXBlXyA9PSAndGV4dCcpIHtcbiAgICAgIHRoaXMudGV4dEZvcm1fLnNldFZhbHVlc1NlcmlhbGl6ZWQoby50ZXh0KTtcbiAgICAgIHRoaXMudHJ5TG9hZFdlYkZvbnRfKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTG9hZHMgdGhlIGZpcnN0IHZhbGlkIGltYWdlIGZyb20gYSBGaWxlTGlzdCAoZS5nLiBkcmFnICsgZHJvcCBzb3VyY2UpLCBhcyBhIGRhdGEgVVJJLiBUaGlzIG1ldGhvZFxuICogd2lsbCB0aHJvdyBhbiBhbGVydCgpIGluIGNhc2Ugb2YgZXJyb3JzIGFuZCBjYWxsIGJhY2sgd2l0aCBudWxsLlxuICogQHBhcmFtIHtGaWxlTGlzdH0gZmlsZUxpc3QgVGhlIEZpbGVMaXN0IHRvIGxvYWQuXG4gKiBAcmV0dXJuIFJldHVybnMgYSBwcm9taXNlLCB3aXRoIG9iamVjdCBjb250YWluaW5nICd1cmknIGZpZWxkIHJlcHJlc2VudGluZ1xuICogICAgICB0aGUgbG9hZGVkIGltYWdlLiBUaGVyZSB3aWxsIGFsc28gYmUgYSAnbmFtZScgZmllbGQgaW5kaWNhdGluZyB0aGUgZmlsZSBuYW1lLCBpZiBvbmVcbiAqICAgICAgaXMgYXZhaWxhYmxlLlxuICovXG5JbWFnZUZpZWxkLmxvYWRJbWFnZUZyb21GaWxlTGlzdCA9IGZ1bmN0aW9uKGZpbGVMaXN0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmlsZUxpc3QgPSBmaWxlTGlzdCB8fCBbXTtcblxuICAgIGxldCBmaWxlID0gQXJyYXkuZnJvbShmaWxlTGlzdCkuZmluZChmaWxlID0+IEltYWdlRmllbGQuaXNWYWxpZEZpbGVfKGZpbGUpKTtcblxuICAgIGlmICghZmlsZSkge1xuICAgICAgYWxlcnQoJ1BsZWFzZSBjaG9vc2UgYSB2YWxpZCBpbWFnZSBmaWxlIChQTkcsIEpQRywgR0lGLCBTVkcsIGV0Yy4pJyk7XG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBpc1N2ZyA9IGZpbGUudHlwZSA9PSAnaW1hZ2Uvc3ZnK3htbCc7XG5cbiAgICBsZXQgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAvLyBDbG9zdXJlIHRvIGNhcHR1cmUgdGhlIGZpbGUgaW5mb3JtYXRpb24uXG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSBlID0+IHJlc29sdmUoe1xuICAgICAgaXNTdmcsXG4gICAgICB1cmk6IGUudGFyZ2V0LnJlc3VsdCxcbiAgICAgIG5hbWU6IGZpbGUubmFtZVxuICAgIH0pO1xuXG4gICAgZmlsZVJlYWRlci5vbmVycm9yID0gZSA9PiB7XG4gICAgICBzd2l0Y2ggKGUudGFyZ2V0LmVycm9yLmNvZGUpIHtcbiAgICAgICAgY2FzZSBlLnRhcmdldC5lcnJvci5OT1RfRk9VTkRfRVJSOlxuICAgICAgICAgIGFsZXJ0KCdGaWxlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGUudGFyZ2V0LmVycm9yLk5PVF9SRUFEQUJMRV9FUlI6XG4gICAgICAgICAgYWxlcnQoJ0ZpbGUgaXMgbm90IHJlYWRhYmxlJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBlLnRhcmdldC5lcnJvci5BQk9SVF9FUlI6XG4gICAgICAgICAgYnJlYWs7IC8vIG5vb3BcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFsZXJ0KCdBbiBlcnJvciBvY2N1cnJlZCByZWFkaW5nIHRoaXMgZmlsZS4nKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICB9O1xuXG4gICAgZmlsZVJlYWRlci5vbmFib3J0ID0gZSA9PiB7XG4gICAgICBhbGVydCgnRmlsZSByZWFkIGNhbmNlbGxlZCcpO1xuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICB9O1xuXG4gICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICB9KTtcbn07XG5cbkltYWdlRmllbGQuaXNWYWxpZEZpbGVfID0gZmlsZSA9PiAhIWZpbGUudHlwZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eaW1hZ2VcXC8vKTtcblxuLy8gUHJldmVudCBzY3JvbGxpbmcgZm9yIGNsaXBhcnQgcGVyIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYwMDQ1NFxuJChkb2N1bWVudCkucmVhZHkoKCkgPT4ge1xuICAkKCcuY2FuY2VsLXBhcmVudC1zY3JvbGwnKS5vbignbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCcsIGUgPT4ge1xuICAgIGxldCBkZWx0YSA9IGUub3JpZ2luYWxFdmVudC53aGVlbERlbHRhIHx8IC1lLm9yaWdpbmFsRXZlbnQuZGV0YWlsO1xuICAgIGUuY3VycmVudFRhcmdldC5zY3JvbGxUb3AgLT0gZGVsdGE7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn0pO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Rm9ybX0gZnJvbSAnLi9mb3Jtcyc7XG5pbXBvcnQge0ZpZWxkLCBUZXh0RmllbGQsIEF1dG9jb21wbGV0ZVRleHRGaWVsZCwgQ29sb3JGaWVsZCwgRW51bUZpZWxkLFxuICAgICAgICBCb29sZWFuRmllbGQsIFJhbmdlRmllbGR9IGZyb20gJy4vZmllbGRzJztcbmltcG9ydCB7SW1hZ2VGaWVsZH0gZnJvbSAnLi9pbWFnZWZpZWxkJztcbmltcG9ydCB7SGFzaH0gZnJvbSAnLi9oYXNoJztcbmltcG9ydCB7VXRpbH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7WmlwfSBmcm9tICcuL3ppcCc7XG5cbmV4cG9ydCBjb25zdCBzdHVkaW8gPSB7XG4gIEF1dG9jb21wbGV0ZVRleHRGaWVsZCxcbiAgQm9vbGVhbkZpZWxkLFxuICBDb2xvckZpZWxkLFxuICBFbnVtRmllbGQsXG4gIEZpZWxkLFxuICBGb3JtLFxuICBIYXNoLFxuICBJbWFnZUZpZWxkLFxuICBSYW5nZUZpZWxkLFxuICBUZXh0RmllbGQsXG4gIFV0aWwsXG4gIFppcCxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFV0aWwgPSB7XG4gIGdldE11bHRCYXNlTWRwaShkZW5zaXR5KSB7XG4gICAgc3dpdGNoIChkZW5zaXR5KSB7XG4gICAgICBjYXNlICd4eHhoZHBpJzogcmV0dXJuIDQuMDA7XG4gICAgICBjYXNlICAneHhoZHBpJzogcmV0dXJuIDMuMDA7XG4gICAgICBjYXNlICAgJ3hoZHBpJzogcmV0dXJuIDIuMDA7XG4gICAgICBjYXNlICAgICdoZHBpJzogcmV0dXJuIDEuNTA7XG4gICAgICBjYXNlICAgJ3R2ZHBpJzogcmV0dXJuIDEuMzMxMjU7XG4gICAgICBjYXNlICAgICdtZHBpJzogcmV0dXJuIDEuMDA7XG4gICAgICBjYXNlICAgICdsZHBpJzogcmV0dXJuIDAuNzU7XG4gICAgfVxuICAgIHJldHVybiAxLjA7XG4gIH0sXG5cbiAgZ2V0RHBpRm9yRGVuc2l0eShkZW5zaXR5KSB7XG4gICAgc3dpdGNoIChkZW5zaXR5KSB7XG4gICAgICBjYXNlICd4eHhoZHBpJzogcmV0dXJuIDY0MDtcbiAgICAgIGNhc2UgICd4eGhkcGknOiByZXR1cm4gNDgwO1xuICAgICAgY2FzZSAgICd4aGRwaSc6IHJldHVybiAzMjA7XG4gICAgICBjYXNlICAgICdoZHBpJzogcmV0dXJuIDI0MDtcbiAgICAgIGNhc2UgICAndHZkcGknOiByZXR1cm4gMjEzO1xuICAgICAgY2FzZSAgICAnbWRwaSc6IHJldHVybiAxNjA7XG4gICAgICBjYXNlICAgICdsZHBpJzogcmV0dXJuIDEyMDtcbiAgICB9XG4gICAgcmV0dXJuIDE2MDtcbiAgfSxcblxuICBtdWx0KHMsIG11bHQpIHtcbiAgICBsZXQgZCA9IHt9O1xuICAgIGZvciAobGV0IGsgaW4gcykge1xuICAgICAgZFtrXSA9IHNba10gKiBtdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfSxcblxuICBtdWx0Um91bmQocywgbXVsdCkge1xuICAgIGxldCBkID0ge307XG4gICAgZm9yIChsZXQgayBpbiBzKSB7XG4gICAgICBkW2tdID0gTWF0aC5yb3VuZChzW2tdICogbXVsdCk7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9LFxuXG4gIHNhbml0aXplUmVzb3VyY2VOYW1lKHMpIHtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1tcXHMtXFwuXS9nLCAnXycpLnJlcGxhY2UoL1teXFx3X10vZywgJycpO1xuICB9LFxuXG4gIC8vIFRPRE86IHN1cHBvcnQgU2FmYXJpXG4gIGRvd25sb2FkRmlsZShjb250ZW50LCBmaWxlbmFtZSkge1xuICAgIGxldCBhbmNob3IgPSAkKCc8YT4nKS5oaWRlKCkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgbGV0IGJsb2IgPSBjb250ZW50O1xuICAgIGlmICghKGNvbnRlbnQgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwge3R5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nfSk7XG4gICAgfVxuICAgIGxldCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBhbmNob3IuYXR0cih7XG4gICAgICBocmVmOiB1cmwsXG4gICAgICBkb3dubG9hZDogZmlsZW5hbWVcbiAgICB9KTtcbiAgICBhbmNob3IuZ2V0KDApLmNsaWNrKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhbmNob3IucmVtb3ZlKCk7XG4gICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgIH0sIDUwMDApO1xuICB9LFxuXG4gIGxvYWRJbWFnZUZyb21VcmkodXJpKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XG4gICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdCgpO1xuICAgICAgaW1nLnNyYyA9IHVyaTtcbiAgICB9KTtcbiAgfSxcblxuICBkZWJ1Z0N0eChjdHgpIHtcbiAgICBpZiAoVXRpbC5kZWJ1Z0N0eC4kbGFzdEVsKSB7XG4gICAgICBVdGlsLmRlYnVnQ3R4LiRsYXN0RWwucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgVXRpbC5kZWJ1Z0N0eC4kbGFzdEVsID0gJCgnPGltZz4nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgekluZGV4OiAxMDAsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDAsIDAsIDAuNSknLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3NyYycsIGN0eC5jYW52YXMudG9EYXRhVVJMKCkpXG4gICAgICAgIC5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgfSxcblxuICBkZWJvdW5jZShkZWxheSwgZm4pIHtcbiAgICBsZXQgdGltZW91dDtcblxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBmbiguLi5hcmdzKVxuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xuICB9LFxufTsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtkZWZhdWx0IGFzIHppcGpzfSBmcm9tICd6aXBqcy1icm93c2VyaWZ5JztcbmltcG9ydCB7VXRpbH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkw7XG5cblxuZXhwb3J0IGNvbnN0IFppcCA9IHtcbiAgY3JlYXRlRG93bmxvYWRpZnlaaXBCdXR0b24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRG93bmxvYWRaaXBCdXR0b24oZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cblxuY2xhc3MgRG93bmxvYWRaaXBCdXR0b24ge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5maWxlU3BlY3NfID0gW107XG4gICAgdGhpcy5lbF8gPSBlbGVtZW50O1xuICAgIHRoaXMuZWxfLmNsaWNrKCgpID0+IHRoaXMuZ2VuZXJhdGVBbmREb3dubG9hZFppcEZpbGVfKCkpO1xuICAgIHRoaXMudXBkYXRlVUlfKCk7XG4gIH1cblxuICBzZXRaaXBGaWxlbmFtZSh6aXBGaWxlbmFtZSkge1xuICAgIHRoaXMuemlwRmlsZW5hbWVfID0gemlwRmlsZW5hbWU7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmZpbGVTcGVjc18gPSBbXTtcbiAgICB0aGlzLnVwZGF0ZVVJXygpO1xuICB9XG5cbiAgYWRkKHNwZWMpIHtcbiAgICB0aGlzLmZpbGVTcGVjc18ucHVzaChzcGVjKTtcbiAgICB0aGlzLnVwZGF0ZVVJXygpO1xuICB9XG5cbiAgdXBkYXRlVUlfKCkge1xuICAgIGlmICh0aGlzLmZpbGVTcGVjc18ubGVuZ3RoICYmICF0aGlzLmdlbmVyYXRpbmdfKSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXy5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGdlbmVyYXRlQW5kRG93bmxvYWRaaXBGaWxlXygpIHtcbiAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLnppcEZpbGVuYW1lXyB8fCAnb3V0cHV0LnppcCc7XG4gICAgaWYgKCF0aGlzLmZpbGVTcGVjc18ubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc0dlbmVyYXRpbmdfID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZVVJXygpO1xuXG4gICAgemlwanMuY3JlYXRlV3JpdGVyKG5ldyB6aXBqcy5CbG9iV3JpdGVyKCksIHdyaXRlciA9PiB7XG4gICAgICBsZXQgaSA9IC0xO1xuICAgICAgbGV0IG5leHRGaWxlXyA9ICgpID0+IHtcbiAgICAgICAgKytpO1xuICAgICAgICBpZiAoaSA+PSB0aGlzLmZpbGVTcGVjc18ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gY2xvc2VcbiAgICAgICAgICB3cml0ZXIuY2xvc2UoYmxvYiA9PiBVdGlsLmRvd25sb2FkRmlsZShibG9iLCBmaWxlbmFtZSkpO1xuICAgICAgICAgIHRoaXMuaXNHZW5lcmF0aW5nXyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudXBkYXRlVUlfKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgbmV4dCBmaWxlXG4gICAgICAgICAgbGV0IGZpbGVTcGVjID0gdGhpcy5maWxlU3BlY3NfW2ldO1xuICAgICAgICAgIHdyaXRlci5hZGQoXG4gICAgICAgICAgICAgIGZpbGVTcGVjLm5hbWUsXG4gICAgICAgICAgICAgIGZpbGVTcGVjLmNhbnZhc1xuICAgICAgICAgICAgICAgICAgPyBuZXcgemlwanMuRGF0YTY0VVJJUmVhZGVyKGZpbGVTcGVjLmNhbnZhcy50b0RhdGFVUkwoKSlcbiAgICAgICAgICAgICAgICAgIDogbmV3IHppcGpzLlRleHRSZWFkZXIoZmlsZVNwZWMudGV4dERhdGEpLFxuICAgICAgICAgICAgICBuZXh0RmlsZV8pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbmV4dEZpbGVfKCk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB0aGlzLmlzR2VuZXJhdGluZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMudXBkYXRlVUlfKCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgNC4wLjVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB1bmRlZmluZWQ7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHt9KS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciByID0gcmVxdWlyZTtcbiAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB1bmRlZmluZWQ7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBfYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIF9yZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxudmFyIEdFVF9USEVOX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ocHJvbWlzZSkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gR0VUX1RIRU5fRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJCA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkID09PSBHRVRfVEhFTl9FUlJPUikge1xuICAgICAgX3JlamVjdChwcm9taXNlLCBHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgfSBlbHNlIGlmICh0aGVuJCQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgZ2V0VGhlbih2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHVuZGVmaW5lZCxcbiAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gRXJyb3JPYmplY3QoKSB7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xufVxuXG52YXIgVFJZX0NBVENIX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgcmV0dXJuIFRSWV9DQVRDSF9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB1bmRlZmluZWQsXG4gICAgICBlcnJvciA9IHVuZGVmaW5lZCxcbiAgICAgIHN1Y2NlZWRlZCA9IHVuZGVmaW5lZCxcbiAgICAgIGZhaWxlZCA9IHVuZGVmaW5lZDtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB2YWx1ZSA9IHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgaWYgKHZhbHVlID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgX3JlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgdGhpcy5fZW51bWVyYXRlKCk7XG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIHZhciBfaW5wdXQgPSB0aGlzLl9pbnB1dDtcblxuICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fZWFjaEVudHJ5KF9pbnB1dFtpXSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICB2YXIgcmVzb2x2ZSQkID0gYy5yZXNvbHZlO1xuXG4gIGlmIChyZXNvbHZlJCQgPT09IHJlc29sdmUpIHtcbiAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSkge1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUkJChlbnRyeSk7XG4gICAgICB9KSwgaSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQoZW50cnkpLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBpKSB7XG4gIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgfSk7XG59O1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICB9XG59XG5cblByb21pc2UuYWxsID0gYWxsO1xuUHJvbWlzZS5yYWNlID0gcmFjZTtcblByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcblByb21pc2UuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZS5fYXNhcCA9IGFzYXA7XG5cblByb21pc2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUHJvbWlzZSxcblxuICAvKipcbiAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBDaGFpbmluZ1xuICAgIC0tLS0tLS0tXG4gIFxuICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgIH0pO1xuICBcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICB9KTtcbiAgICBgYGBcbiAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQXNzaW1pbGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tXG4gIFxuICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IHJlc3VsdDtcbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IGF1dGhvciwgYm9va3M7XG4gIFxuICAgIHRyeSB7XG4gICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgXG4gICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICBcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kQXV0aG9yKCkuXG4gICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIHRoZW5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgdGhlbjogdGhlbixcblxuICAvKipcbiAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgXG4gICAgYGBganNcbiAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICB9XG4gIFxuICAgIC8vIHN5bmNocm9ub3VzXG4gICAgdHJ5IHtcbiAgICAgIGZpbmRBdXRob3IoKTtcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9XG4gIFxuICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgY2F0Y2hcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICAnY2F0Y2gnOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgdmFyIGxvY2FsID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgaWYgKFApIHtcbiAgICAgICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2U7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5cbnJldHVybiBQcm9taXNlO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIFRpbnlDb2xvciB2MS40LjFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZ3JpbnMvVGlueUNvbG9yXG4vLyBCcmlhbiBHcmluc3RlYWQsIE1JVCBMaWNlbnNlXG5cbihmdW5jdGlvbihNYXRoKSB7XG5cbnZhciB0cmltTGVmdCA9IC9eXFxzKy8sXG4gICAgdHJpbVJpZ2h0ID0gL1xccyskLyxcbiAgICB0aW55Q291bnRlciA9IDAsXG4gICAgbWF0aFJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICBtYXRoTWluID0gTWF0aC5taW4sXG4gICAgbWF0aE1heCA9IE1hdGgubWF4LFxuICAgIG1hdGhSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuZnVuY3Rpb24gdGlueWNvbG9yIChjb2xvciwgb3B0cykge1xuXG4gICAgY29sb3IgPSAoY29sb3IpID8gY29sb3IgOiAnJztcbiAgICBvcHRzID0gb3B0cyB8fCB7IH07XG5cbiAgICAvLyBJZiBpbnB1dCBpcyBhbHJlYWR5IGEgdGlueWNvbG9yLCByZXR1cm4gaXRzZWxmXG4gICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgdGlueWNvbG9yKSB7XG4gICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBhcmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGNhbGwgdXNpbmcgbmV3IGluc3RlYWRcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgdGlueWNvbG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IGlucHV0VG9SR0IoY29sb3IpO1xuICAgIHRoaXMuX29yaWdpbmFsSW5wdXQgPSBjb2xvcixcbiAgICB0aGlzLl9yID0gcmdiLnIsXG4gICAgdGhpcy5fZyA9IHJnYi5nLFxuICAgIHRoaXMuX2IgPSByZ2IuYixcbiAgICB0aGlzLl9hID0gcmdiLmEsXG4gICAgdGhpcy5fcm91bmRBID0gbWF0aFJvdW5kKDEwMCp0aGlzLl9hKSAvIDEwMCxcbiAgICB0aGlzLl9mb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCByZ2IuZm9ybWF0O1xuICAgIHRoaXMuX2dyYWRpZW50VHlwZSA9IG9wdHMuZ3JhZGllbnRUeXBlO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHRoZSByYW5nZSBvZiBbMCwyNTVdIGNvbWUgYmFjayBpbiBbMCwxXS5cbiAgICAvLyBQb3RlbnRpYWxseSBsb3NlIGEgbGl0dGxlIGJpdCBvZiBwcmVjaXNpb24gaGVyZSwgYnV0IHdpbGwgZml4IGlzc3VlcyB3aGVyZVxuICAgIC8vIC41IGdldHMgaW50ZXJwcmV0ZWQgYXMgaGFsZiBvZiB0aGUgdG90YWwsIGluc3RlYWQgb2YgaGFsZiBvZiAxXG4gICAgLy8gSWYgaXQgd2FzIHN1cHBvc2VkIHRvIGJlIDEyOCwgdGhpcyB3YXMgYWxyZWFkeSB0YWtlbiBjYXJlIG9mIGJ5IGBpbnB1dFRvUmdiYFxuICAgIGlmICh0aGlzLl9yIDwgMSkgeyB0aGlzLl9yID0gbWF0aFJvdW5kKHRoaXMuX3IpOyB9XG4gICAgaWYgKHRoaXMuX2cgPCAxKSB7IHRoaXMuX2cgPSBtYXRoUm91bmQodGhpcy5fZyk7IH1cbiAgICBpZiAodGhpcy5fYiA8IDEpIHsgdGhpcy5fYiA9IG1hdGhSb3VuZCh0aGlzLl9iKTsgfVxuXG4gICAgdGhpcy5fb2sgPSByZ2Iub2s7XG4gICAgdGhpcy5fdGNfaWQgPSB0aW55Q291bnRlcisrO1xufVxuXG50aW55Y29sb3IucHJvdG90eXBlID0ge1xuICAgIGlzRGFyazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJyaWdodG5lc3MoKSA8IDEyODtcbiAgICB9LFxuICAgIGlzTGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEYXJrKCk7XG4gICAgfSxcbiAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29rO1xuICAgIH0sXG4gICAgZ2V0T3JpZ2luYWxJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxJbnB1dDtcbiAgICB9LFxuICAgIGdldEZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XG4gICAgfSxcbiAgICBnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgIH0sXG4gICAgZ2V0QnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vaHR0cDovL3d3dy53My5vcmcvVFIvQUVSVCNjb2xvci1jb250cmFzdFxuICAgICAgICB2YXIgcmdiID0gdGhpcy50b1JnYigpO1xuICAgICAgICByZXR1cm4gKHJnYi5yICogMjk5ICsgcmdiLmcgKiA1ODcgKyByZ2IuYiAqIDExNCkgLyAxMDAwO1xuICAgIH0sXG4gICAgZ2V0THVtaW5hbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHZhciBSc1JHQiwgR3NSR0IsIEJzUkdCLCBSLCBHLCBCO1xuICAgICAgICBSc1JHQiA9IHJnYi5yLzI1NTtcbiAgICAgICAgR3NSR0IgPSByZ2IuZy8yNTU7XG4gICAgICAgIEJzUkdCID0gcmdiLmIvMjU1O1xuXG4gICAgICAgIGlmIChSc1JHQiA8PSAwLjAzOTI4KSB7UiA9IFJzUkdCIC8gMTIuOTI7fSBlbHNlIHtSID0gTWF0aC5wb3coKChSc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIGlmIChHc1JHQiA8PSAwLjAzOTI4KSB7RyA9IEdzUkdCIC8gMTIuOTI7fSBlbHNlIHtHID0gTWF0aC5wb3coKChHc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIGlmIChCc1JHQiA8PSAwLjAzOTI4KSB7QiA9IEJzUkdCIC8gMTIuOTI7fSBlbHNlIHtCID0gTWF0aC5wb3coKChCc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIHJldHVybiAoMC4yMTI2ICogUikgKyAoMC43MTUyICogRykgKyAoMC4wNzIyICogQik7XG4gICAgfSxcbiAgICBzZXRBbHBoYTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYSA9IGJvdW5kQWxwaGEodmFsdWUpO1xuICAgICAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvSHN2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICByZXR1cm4geyBoOiBoc3YuaCAqIDM2MCwgczogaHN2LnMsIHY6IGhzdi52LCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b0hzdlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc3YgPSByZ2JUb0hzdih0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgdmFyIGggPSBtYXRoUm91bmQoaHN2LmggKiAzNjApLCBzID0gbWF0aFJvdW5kKGhzdi5zICogMTAwKSwgdiA9IG1hdGhSb3VuZChoc3YudiAqIDEwMCk7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJoc3YoXCIgICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdiArIFwiJSlcIiA6XG4gICAgICAgICAgXCJoc3ZhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdiArIFwiJSwgXCIrIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9Ic2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzbC5oICogMzYwLCBzOiBoc2wucywgbDogaHNsLmwsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHNsU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzbCA9IHJnYlRvSHNsKHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc2wuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHNsLnMgKiAxMDApLCBsID0gbWF0aFJvdW5kKGhzbC5sICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzbChcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzbGEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hleDogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICByZXR1cm4gcmdiVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgYWxsb3czQ2hhcik7XG4gICAgfSxcbiAgICB0b0hleFN0cmluZzogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy50b0hleChhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4ODogZnVuY3Rpb24oYWxsb3c0Q2hhcikge1xuICAgICAgICByZXR1cm4gcmdiYVRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRoaXMuX2EsIGFsbG93NENoYXIpO1xuICAgIH0sXG4gICAgdG9IZXg4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzRDaGFyKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4OChhbGxvdzRDaGFyKTtcbiAgICB9LFxuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKHRoaXMuX3IpLCBnOiBtYXRoUm91bmQodGhpcy5fZyksIGI6IG1hdGhSb3VuZCh0aGlzLl9iKSwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9SZ2JTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwicmdiKFwiICArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiKVwiIDpcbiAgICAgICAgICBcInJnYmEoXCIgKyBtYXRoUm91bmQodGhpcy5fcikgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fZykgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fYikgKyBcIiwgXCIgKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvUGVyY2VudGFnZVJnYjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGc6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlXCIsIGI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvUGVyY2VudGFnZVJnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9OYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2EgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXhOYW1lc1tyZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0cnVlKV0gfHwgZmFsc2U7XG4gICAgfSxcbiAgICB0b0ZpbHRlcjogZnVuY3Rpb24oc2Vjb25kQ29sb3IpIHtcbiAgICAgICAgdmFyIGhleDhTdHJpbmcgPSAnIycgKyByZ2JhVG9BcmdiSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRoaXMuX2EpO1xuICAgICAgICB2YXIgc2Vjb25kSGV4OFN0cmluZyA9IGhleDhTdHJpbmc7XG4gICAgICAgIHZhciBncmFkaWVudFR5cGUgPSB0aGlzLl9ncmFkaWVudFR5cGUgPyBcIkdyYWRpZW50VHlwZSA9IDEsIFwiIDogXCJcIjtcblxuICAgICAgICBpZiAoc2Vjb25kQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGlueWNvbG9yKHNlY29uZENvbG9yKTtcbiAgICAgICAgICAgIHNlY29uZEhleDhTdHJpbmcgPSAnIycgKyByZ2JhVG9BcmdiSGV4KHMuX3IsIHMuX2csIHMuX2IsIHMuX2EpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KFwiK2dyYWRpZW50VHlwZStcInN0YXJ0Q29sb3JzdHI9XCIraGV4OFN0cmluZytcIixlbmRDb2xvcnN0cj1cIitzZWNvbmRIZXg4U3RyaW5nK1wiKVwiO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgZm9ybWF0U2V0ID0gISFmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLl9mb3JtYXQ7XG5cbiAgICAgICAgdmFyIGZvcm1hdHRlZFN0cmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFzQWxwaGEgPSB0aGlzLl9hIDwgMSAmJiB0aGlzLl9hID49IDA7XG4gICAgICAgIHZhciBuZWVkc0FscGhhRm9ybWF0ID0gIWZvcm1hdFNldCAmJiBoYXNBbHBoYSAmJiAoZm9ybWF0ID09PSBcImhleFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg2XCIgfHwgZm9ybWF0ID09PSBcImhleDNcIiB8fCBmb3JtYXQgPT09IFwiaGV4NFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg4XCIgfHwgZm9ybWF0ID09PSBcIm5hbWVcIik7XG5cbiAgICAgICAgaWYgKG5lZWRzQWxwaGFGb3JtYXQpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgXCJ0cmFuc3BhcmVudFwiLCBhbGwgb3RoZXIgbm9uLWFscGhhIGZvcm1hdHNcbiAgICAgICAgICAgIC8vIHdpbGwgcmV0dXJuIHJnYmEgd2hlbiB0aGVyZSBpcyB0cmFuc3BhcmVuY3kuXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIiAmJiB0aGlzLl9hID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9OYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicmdiXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcInByZ2JcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1BlcmNlbnRhZ2VSZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg2XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDNcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDRcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXg4XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXg4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9OYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc2xcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzbFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaHN2XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic3ZTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdHJpbmcgfHwgdGhpcy50b0hleFN0cmluZygpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGlueWNvbG9yKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIF9hcHBseU1vZGlmaWNhdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gZm4uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgICAgIHRoaXMuX3IgPSBjb2xvci5fcjtcbiAgICAgICAgdGhpcy5fZyA9IGNvbG9yLl9nO1xuICAgICAgICB0aGlzLl9iID0gY29sb3IuX2I7XG4gICAgICAgIHRoaXMuc2V0QWxwaGEoY29sb3IuX2EpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGxpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24obGlnaHRlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGJyaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGJyaWdodGVuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZGFya2VuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGRhcmtlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGRlc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGVzYXR1cmF0ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKHNhdHVyYXRlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZ3JleXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGdyZXlzY2FsZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNwaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc3BpbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5Q29tYmluYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICB9LFxuICAgIGFuYWxvZ291czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKGFuYWxvZ291cywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihjb21wbGVtZW50LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbW9ub2Nocm9tYXRpYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKG1vbm9jaHJvbWF0aWMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzcGxpdGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihzcGxpdGNvbXBsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0cmlhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHRyaWFkLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgdGV0cmFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24odGV0cmFkLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbi8vIElmIGlucHV0IGlzIGFuIG9iamVjdCwgZm9yY2UgMSBpbnRvIFwiMS4wXCIgdG8gaGFuZGxlIHJhdGlvcyBwcm9wZXJseVxuLy8gU3RyaW5nIGlucHV0IHJlcXVpcmVzIFwiMS4wXCIgYXMgaW5wdXQsIHNvIDEgd2lsbCBiZSB0cmVhdGVkIGFzIDFcbnRpbnljb2xvci5mcm9tUmF0aW8gPSBmdW5jdGlvbihjb2xvciwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgbmV3Q29sb3IgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBjb2xvcikge1xuICAgICAgICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29sb3JbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2xvcltpXSA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3JbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IG5ld0NvbG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IsIG9wdHMpO1xufTtcblxuLy8gR2l2ZW4gYSBzdHJpbmcgb3Igb2JqZWN0LCBjb252ZXJ0IHRoYXQgaW5wdXQgdG8gUkdCXG4vLyBQb3NzaWJsZSBzdHJpbmcgaW5wdXRzOlxuLy9cbi8vICAgICBcInJlZFwiXG4vLyAgICAgXCIjZjAwXCIgb3IgXCJmMDBcIlxuLy8gICAgIFwiI2ZmMDAwMFwiIG9yIFwiZmYwMDAwXCJcbi8vICAgICBcIiNmZjAwMDAwMFwiIG9yIFwiZmYwMDAwMDBcIlxuLy8gICAgIFwicmdiIDI1NSAwIDBcIiBvciBcInJnYiAoMjU1LCAwLCAwKVwiXG4vLyAgICAgXCJyZ2IgMS4wIDAgMFwiIG9yIFwicmdiICgxLCAwLCAwKVwiXG4vLyAgICAgXCJyZ2JhICgyNTUsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDI1NSwgMCwgMCwgMVwiXG4vLyAgICAgXCJyZ2JhICgxLjAsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDEuMCwgMCwgMCwgMVwiXG4vLyAgICAgXCJoc2woMCwgMTAwJSwgNTAlKVwiIG9yIFwiaHNsIDAgMTAwJSA1MCVcIlxuLy8gICAgIFwiaHNsYSgwLCAxMDAlLCA1MCUsIDEpXCIgb3IgXCJoc2xhIDAgMTAwJSA1MCUsIDFcIlxuLy8gICAgIFwiaHN2KDAsIDEwMCUsIDEwMCUpXCIgb3IgXCJoc3YgMCAxMDAlIDEwMCVcIlxuLy9cbmZ1bmN0aW9uIGlucHV0VG9SR0IoY29sb3IpIHtcblxuICAgIHZhciByZ2IgPSB7IHI6IDAsIGc6IDAsIGI6IDAgfTtcbiAgICB2YXIgYSA9IDE7XG4gICAgdmFyIHMgPSBudWxsO1xuICAgIHZhciB2ID0gbnVsbDtcbiAgICB2YXIgbCA9IG51bGw7XG4gICAgdmFyIG9rID0gZmFsc2U7XG4gICAgdmFyIGZvcm1hdCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbG9yID0gc3RyaW5nSW5wdXRUb09iamVjdChjb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5yKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5nKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5iKSkge1xuICAgICAgICAgICAgcmdiID0gcmdiVG9SZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBTdHJpbmcoY29sb3Iucikuc3Vic3RyKC0xKSA9PT0gXCIlXCIgPyBcInByZ2JcIiA6IFwicmdiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZENTU1VuaXQoY29sb3IuaCkgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IucykgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IudikpIHtcbiAgICAgICAgICAgIHMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICAgICAgdiA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iudik7XG4gICAgICAgICAgICByZ2IgPSBoc3ZUb1JnYihjb2xvci5oLCBzLCB2KTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiaHN2XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZENTU1VuaXQoY29sb3IuaCkgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IucykgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IubCkpIHtcbiAgICAgICAgICAgIHMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICAgICAgbCA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3IubCk7XG4gICAgICAgICAgICByZ2IgPSBoc2xUb1JnYihjb2xvci5oLCBzLCBsKTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiaHNsXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJhXCIpKSB7XG4gICAgICAgICAgICBhID0gY29sb3IuYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGEgPSBib3VuZEFscGhhKGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2s6IG9rLFxuICAgICAgICBmb3JtYXQ6IGNvbG9yLmZvcm1hdCB8fCBmb3JtYXQsXG4gICAgICAgIHI6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5yLCAwKSksXG4gICAgICAgIGc6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5nLCAwKSksXG4gICAgICAgIGI6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5iLCAwKSksXG4gICAgICAgIGE6IGFcbiAgICB9O1xufVxuXG5cbi8vIENvbnZlcnNpb24gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBgcmdiVG9Ic2xgLCBgcmdiVG9Ic3ZgLCBgaHNsVG9SZ2JgLCBgaHN2VG9SZ2JgIG1vZGlmaWVkIGZyb206XG4vLyA8aHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdD5cblxuLy8gYHJnYlRvUmdiYFxuLy8gSGFuZGxlIGJvdW5kcyAvIHBlcmNlbnRhZ2UgY2hlY2tpbmcgdG8gY29uZm9ybSB0byBDU1MgY29sb3Igc3BlY1xuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvPlxuLy8gKkFzc3VtZXM6KiByLCBnLCBiIGluIFswLCAyNTVdIG9yIFswLCAxXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiBbMCwgMjU1XVxuZnVuY3Rpb24gcmdiVG9SZ2IociwgZywgYil7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogYm91bmQwMShyLCAyNTUpICogMjU1LFxuICAgICAgICBnOiBib3VuZDAxKGcsIDI1NSkgKiAyNTUsXG4gICAgICAgIGI6IGJvdW5kMDEoYiwgMjU1KSAqIDI1NVxuICAgIH07XG59XG5cbi8vIGByZ2JUb0hzbGBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU0wuXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgaCwgcywgbCB9IGluIFswLDFdXG5mdW5jdGlvbiByZ2JUb0hzbChyLCBnLCBiKSB7XG5cbiAgICByID0gYm91bmQwMShyLCAyNTUpO1xuICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgYiA9IGJvdW5kMDEoYiwgMjU1KTtcblxuICAgIHZhciBtYXggPSBtYXRoTWF4KHIsIGcsIGIpLCBtaW4gPSBtYXRoTWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYobWF4ID09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgIHN3aXRjaChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cblxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIGw6IGwgfTtcbn1cblxuLy8gYGhzbFRvUmdiYFxuLy8gQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi5cbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCBsIGFyZSBjb250YWluZWQgWzAsIDFdIG9yIFswLCAxMDBdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIHRoZSBzZXQgWzAsIDI1NV1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgICB2YXIgciwgZywgYjtcblxuICAgIGggPSBib3VuZDAxKGgsIDM2MCk7XG4gICAgcyA9IGJvdW5kMDEocywgMTAwKTtcbiAgICBsID0gYm91bmQwMShsLCAxMDApO1xuXG4gICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgaWYocyA9PT0gMCkge1xuICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcbiAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfTtcbn1cblxuLy8gYHJnYlRvSHN2YFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTVlxuLy8gKkFzc3VtZXM6KiByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgaCwgcywgdiB9IGluIFswLDFdXG5mdW5jdGlvbiByZ2JUb0hzdihyLCBnLCBiKSB7XG5cbiAgICByID0gYm91bmQwMShyLCAyNTUpO1xuICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgYiA9IGJvdW5kMDEoYiwgMjU1KTtcblxuICAgIHZhciBtYXggPSBtYXRoTWF4KHIsIGcsIGIpLCBtaW4gPSBtYXRoTWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCB2ID0gbWF4O1xuXG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xuXG4gICAgaWYobWF4ID09IG1pbikge1xuICAgICAgICBoID0gMDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCB2OiB2IH07XG59XG5cbi8vIGBoc3ZUb1JnYmBcbi8vIENvbnZlcnRzIGFuIEhTViBjb2xvciB2YWx1ZSB0byBSR0IuXG4vLyAqQXNzdW1lczoqIGggaXMgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMzYwXSBhbmQgcyBhbmQgdiBhcmUgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMTAwXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiB0aGUgc2V0IFswLCAyNTVdXG4gZnVuY3Rpb24gaHN2VG9SZ2IoaCwgcywgdikge1xuXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKSAqIDY7XG4gICAgcyA9IGJvdW5kMDEocywgMTAwKTtcbiAgICB2ID0gYm91bmQwMSh2LCAxMDApO1xuXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKGgpLFxuICAgICAgICBmID0gaCAtIGksXG4gICAgICAgIHAgPSB2ICogKDEgLSBzKSxcbiAgICAgICAgcSA9IHYgKiAoMSAtIGYgKiBzKSxcbiAgICAgICAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKSxcbiAgICAgICAgbW9kID0gaSAlIDYsXG4gICAgICAgIHIgPSBbdiwgcSwgcCwgcCwgdCwgdl1bbW9kXSxcbiAgICAgICAgZyA9IFt0LCB2LCB2LCBxLCBwLCBwXVttb2RdLFxuICAgICAgICBiID0gW3AsIHAsIHQsIHYsIHYsIHFdW21vZF07XG5cbiAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XG59XG5cbi8vIGByZ2JUb0hleGBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB0byBoZXhcbi8vIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdXG4vLyBSZXR1cm5zIGEgMyBvciA2IGNoYXJhY3RlciBoZXhcbmZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIsIGFsbG93M0NoYXIpIHtcblxuICAgIHZhciBoZXggPSBbXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSlcbiAgICBdO1xuXG4gICAgLy8gUmV0dXJuIGEgMyBjaGFyYWN0ZXIgaGV4IGlmIHBvc3NpYmxlXG4gICAgaWYgKGFsbG93M0NoYXIgJiYgaGV4WzBdLmNoYXJBdCgwKSA9PSBoZXhbMF0uY2hhckF0KDEpICYmIGhleFsxXS5jaGFyQXQoMCkgPT0gaGV4WzFdLmNoYXJBdCgxKSAmJiBoZXhbMl0uY2hhckF0KDApID09IGhleFsyXS5jaGFyQXQoMSkpIHtcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGByZ2JhVG9IZXhgXG4vLyBDb252ZXJ0cyBhbiBSR0JBIGNvbG9yIHBsdXMgYWxwaGEgdHJhbnNwYXJlbmN5IHRvIGhleFxuLy8gQXNzdW1lcyByLCBnLCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBhbmRcbi8vIGEgaW4gWzAsIDFdLiBSZXR1cm5zIGEgNCBvciA4IGNoYXJhY3RlciByZ2JhIGhleFxuZnVuY3Rpb24gcmdiYVRvSGV4KHIsIGcsIGIsIGEsIGFsbG93NENoYXIpIHtcblxuICAgIHZhciBoZXggPSBbXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIoY29udmVydERlY2ltYWxUb0hleChhKSlcbiAgICBdO1xuXG4gICAgLy8gUmV0dXJuIGEgNCBjaGFyYWN0ZXIgaGV4IGlmIHBvc3NpYmxlXG4gICAgaWYgKGFsbG93NENoYXIgJiYgaGV4WzBdLmNoYXJBdCgwKSA9PSBoZXhbMF0uY2hhckF0KDEpICYmIGhleFsxXS5jaGFyQXQoMCkgPT0gaGV4WzFdLmNoYXJBdCgxKSAmJiBoZXhbMl0uY2hhckF0KDApID09IGhleFsyXS5jaGFyQXQoMSkgJiYgaGV4WzNdLmNoYXJBdCgwKSA9PSBoZXhbM10uY2hhckF0KDEpKSB7XG4gICAgICAgIHJldHVybiBoZXhbMF0uY2hhckF0KDApICsgaGV4WzFdLmNoYXJBdCgwKSArIGhleFsyXS5jaGFyQXQoMCkgKyBoZXhbM10uY2hhckF0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYHJnYmFUb0FyZ2JIZXhgXG4vLyBDb252ZXJ0cyBhbiBSR0JBIGNvbG9yIHRvIGFuIEFSR0IgSGV4OCBzdHJpbmdcbi8vIFJhcmVseSB1c2VkLCBidXQgcmVxdWlyZWQgZm9yIFwidG9GaWx0ZXIoKVwiXG5mdW5jdGlvbiByZ2JhVG9BcmdiSGV4KHIsIGcsIGIsIGEpIHtcblxuICAgIHZhciBoZXggPSBbXG4gICAgICAgIHBhZDIoY29udmVydERlY2ltYWxUb0hleChhKSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSlcbiAgICBdO1xuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgZXF1YWxzYFxuLy8gQ2FuIGJlIGNhbGxlZCB3aXRoIGFueSB0aW55Y29sb3IgaW5wdXRcbnRpbnljb2xvci5lcXVhbHMgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIpIHtcbiAgICBpZiAoIWNvbG9yMSB8fCAhY29sb3IyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IxKS50b1JnYlN0cmluZygpID09IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiU3RyaW5nKCk7XG59O1xuXG50aW55Y29sb3IucmFuZG9tID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvci5mcm9tUmF0aW8oe1xuICAgICAgICByOiBtYXRoUmFuZG9tKCksXG4gICAgICAgIGc6IG1hdGhSYW5kb20oKSxcbiAgICAgICAgYjogbWF0aFJhbmRvbSgpXG4gICAgfSk7XG59O1xuXG5cbi8vIE1vZGlmaWNhdGlvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoYW5rcyB0byBsZXNzLmpzIGZvciBzb21lIG9mIHRoZSBiYXNpY3MgaGVyZVxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGhlYWQvbGVzcy5qcy9ibG9iL21hc3Rlci9saWIvbGVzcy9mdW5jdGlvbnMuanM+XG5cbmZ1bmN0aW9uIGRlc2F0dXJhdGUoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLnMgLT0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5zID0gY2xhbXAwMShoc2wucyk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiBzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wucyArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIGdyZXlzY2FsZShjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmRlc2F0dXJhdGUoMTAwKTtcbn1cblxuZnVuY3Rpb24gbGlnaHRlbiAoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmwgKz0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5sID0gY2xhbXAwMShoc2wubCk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiBicmlnaHRlbihjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIHJnYiA9IHRpbnljb2xvcihjb2xvcikudG9SZ2IoKTtcbiAgICByZ2IuciA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5yIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmdiLmcgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuZyAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJnYi5iID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLmIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKHJnYik7XG59XG5cbmZ1bmN0aW9uIGRhcmtlbiAoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmwgLT0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5sID0gY2xhbXAwMShoc2wubCk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG4vLyBTcGluIHRha2VzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgYW1vdW50IHdpdGhpbiBbLTM2MCwgMzYwXSBpbmRpY2F0aW5nIHRoZSBjaGFuZ2Ugb2YgaHVlLlxuLy8gVmFsdWVzIG91dHNpZGUgb2YgdGhpcyByYW5nZSB3aWxsIGJlIHdyYXBwZWQgaW50byB0aGlzIHJhbmdlLlxuZnVuY3Rpb24gc3Bpbihjb2xvciwgYW1vdW50KSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaHVlID0gKGhzbC5oICsgYW1vdW50KSAlIDM2MDtcbiAgICBoc2wuaCA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG4vLyBDb21iaW5hdGlvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGpRdWVyeSB4Q29sb3IgZm9yIHNvbWUgb2YgdGhlIGlkZWFzIGJlaGluZCB0aGVzZVxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmZ1c2lvbi9qUXVlcnkteGNvbG9yL2Jsb2IvbWFzdGVyL2pxdWVyeS54Y29sb3IuanM+XG5cbmZ1bmN0aW9uIGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5oID0gKGhzbC5oICsgMTgwKSAlIDM2MDtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHRyaWFkKGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTIwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI0MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHRldHJhZChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDkwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDE4MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyNzApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBzcGxpdGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyA3MikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDIxNikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gYW5hbG9nb3VzKGNvbG9yLCByZXN1bHRzLCBzbGljZXMpIHtcbiAgICByZXN1bHRzID0gcmVzdWx0cyB8fCA2O1xuICAgIHNsaWNlcyA9IHNsaWNlcyB8fCAzMDtcblxuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIHBhcnQgPSAzNjAgLyBzbGljZXM7XG4gICAgdmFyIHJldCA9IFt0aW55Y29sb3IoY29sb3IpXTtcblxuICAgIGZvciAoaHNsLmggPSAoKGhzbC5oIC0gKHBhcnQgKiByZXN1bHRzID4+IDEpKSArIDcyMCkgJSAzNjA7IC0tcmVzdWx0czsgKSB7XG4gICAgICAgIGhzbC5oID0gKGhzbC5oICsgcGFydCkgJSAzNjA7XG4gICAgICAgIHJldC5wdXNoKHRpbnljb2xvcihoc2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbW9ub2Nocm9tYXRpYyhjb2xvciwgcmVzdWx0cykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XG4gICAgdmFyIGhzdiA9IHRpbnljb2xvcihjb2xvcikudG9Ic3YoKTtcbiAgICB2YXIgaCA9IGhzdi5oLCBzID0gaHN2LnMsIHYgPSBoc3YudjtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIG1vZGlmaWNhdGlvbiA9IDEgLyByZXN1bHRzO1xuXG4gICAgd2hpbGUgKHJlc3VsdHMtLSkge1xuICAgICAgICByZXQucHVzaCh0aW55Y29sb3IoeyBoOiBoLCBzOiBzLCB2OiB2fSkpO1xuICAgICAgICB2ID0gKHYgKyBtb2RpZmljYXRpb24pICUgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnRpbnljb2xvci5taXggPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCA1MCk7XG5cbiAgICB2YXIgcmdiMSA9IHRpbnljb2xvcihjb2xvcjEpLnRvUmdiKCk7XG4gICAgdmFyIHJnYjIgPSB0aW55Y29sb3IoY29sb3IyKS50b1JnYigpO1xuXG4gICAgdmFyIHAgPSBhbW91bnQgLyAxMDA7XG5cbiAgICB2YXIgcmdiYSA9IHtcbiAgICAgICAgcjogKChyZ2IyLnIgLSByZ2IxLnIpICogcCkgKyByZ2IxLnIsXG4gICAgICAgIGc6ICgocmdiMi5nIC0gcmdiMS5nKSAqIHApICsgcmdiMS5nLFxuICAgICAgICBiOiAoKHJnYjIuYiAtIHJnYjEuYikgKiBwKSArIHJnYjEuYixcbiAgICAgICAgYTogKChyZ2IyLmEgLSByZ2IxLmEpICogcCkgKyByZ2IxLmFcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRpbnljb2xvcihyZ2JhKTtcbn07XG5cblxuLy8gUmVhZGFiaWxpdHkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmIChXQ0FHIFZlcnNpb24gMilcblxuLy8gYGNvbnRyYXN0YFxuLy8gQW5hbHl6ZSB0aGUgMiBjb2xvcnMgYW5kIHJldHVybnMgdGhlIGNvbG9yIGNvbnRyYXN0IGRlZmluZWQgYnkgKFdDQUcgVmVyc2lvbiAyKVxudGlueWNvbG9yLnJlYWRhYmlsaXR5ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcbiAgICB2YXIgYzEgPSB0aW55Y29sb3IoY29sb3IxKTtcbiAgICB2YXIgYzIgPSB0aW55Y29sb3IoY29sb3IyKTtcbiAgICByZXR1cm4gKE1hdGgubWF4KGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KSAvIChNYXRoLm1pbihjMS5nZXRMdW1pbmFuY2UoKSxjMi5nZXRMdW1pbmFuY2UoKSkrMC4wNSk7XG59O1xuXG4vLyBgaXNSZWFkYWJsZWBcbi8vIEVuc3VyZSB0aGF0IGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgY29tYmluYXRpb25zIG1lZXQgV0NBRzIgZ3VpZGVsaW5lcy5cbi8vIFRoZSB0aGlyZCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBPYmplY3QuXG4vLyAgICAgIHRoZSAnbGV2ZWwnIHByb3BlcnR5IHN0YXRlcyAnQUEnIG9yICdBQUEnIC0gaWYgbWlzc2luZyBvciBpbnZhbGlkLCBpdCBkZWZhdWx0cyB0byAnQUEnO1xuLy8gICAgICB0aGUgJ3NpemUnIHByb3BlcnR5IHN0YXRlcyAnbGFyZ2UnIG9yICdzbWFsbCcgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdzbWFsbCcuXG4vLyBJZiB0aGUgZW50aXJlIG9iamVjdCBpcyBhYnNlbnQsIGlzUmVhZGFibGUgZGVmYXVsdHMgdG8ge2xldmVsOlwiQUFcIixzaXplOlwic21hbGxcIn0uXG5cbi8vICpFeGFtcGxlKlxuLy8gICAgdGlueWNvbG9yLmlzUmVhZGFibGUoXCIjMDAwXCIsIFwiIzExMVwiKSA9PiBmYWxzZVxuLy8gICAgdGlueWNvbG9yLmlzUmVhZGFibGUoXCIjMDAwXCIsIFwiIzExMVwiLHtsZXZlbDpcIkFBXCIsc2l6ZTpcImxhcmdlXCJ9KSA9PiBmYWxzZVxudGlueWNvbG9yLmlzUmVhZGFibGUgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgd2NhZzIpIHtcbiAgICB2YXIgcmVhZGFiaWxpdHkgPSB0aW55Y29sb3IucmVhZGFiaWxpdHkoY29sb3IxLCBjb2xvcjIpO1xuICAgIHZhciB3Y2FnMlBhcm1zLCBvdXQ7XG5cbiAgICBvdXQgPSBmYWxzZTtcblxuICAgIHdjYWcyUGFybXMgPSB2YWxpZGF0ZVdDQUcyUGFybXMod2NhZzIpO1xuICAgIHN3aXRjaCAod2NhZzJQYXJtcy5sZXZlbCArIHdjYWcyUGFybXMuc2l6ZSkge1xuICAgICAgICBjYXNlIFwiQUFzbWFsbFwiOlxuICAgICAgICBjYXNlIFwiQUFBbGFyZ2VcIjpcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDQuNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQUFBc21hbGxcIjpcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcblxufTtcblxuLy8gYG1vc3RSZWFkYWJsZWBcbi8vIEdpdmVuIGEgYmFzZSBjb2xvciBhbmQgYSBsaXN0IG9mIHBvc3NpYmxlIGZvcmVncm91bmQgb3IgYmFja2dyb3VuZFxuLy8gY29sb3JzIGZvciB0aGF0IGJhc2UsIHJldHVybnMgdGhlIG1vc3QgcmVhZGFibGUgY29sb3IuXG4vLyBPcHRpb25hbGx5IHJldHVybnMgQmxhY2sgb3IgV2hpdGUgaWYgdGhlIG1vc3QgcmVhZGFibGUgY29sb3IgaXMgdW5yZWFkYWJsZS5cbi8vICpFeGFtcGxlKlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOmZhbHNlfSkudG9IZXhTdHJpbmcoKTsgLy8gXCIjMTEyMjU1XCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUodGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiMxMjNcIiwgW1wiIzEyNFwiLCBcIiMxMjVcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlfSkudG9IZXhTdHJpbmcoKTsgIC8vIFwiI2ZmZmZmZlwiXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiI2E4MDE1YVwiLCBbXCIjZmFmM2YzXCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6dHJ1ZSxsZXZlbDpcIkFBQVwiLHNpemU6XCJsYXJnZVwifSkudG9IZXhTdHJpbmcoKTsgLy8gXCIjZmFmM2YzXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcInNtYWxsXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmZmZmZmZcIlxudGlueWNvbG9yLm1vc3RSZWFkYWJsZSA9IGZ1bmN0aW9uKGJhc2VDb2xvciwgY29sb3JMaXN0LCBhcmdzKSB7XG4gICAgdmFyIGJlc3RDb2xvciA9IG51bGw7XG4gICAgdmFyIGJlc3RTY29yZSA9IDA7XG4gICAgdmFyIHJlYWRhYmlsaXR5O1xuICAgIHZhciBpbmNsdWRlRmFsbGJhY2tDb2xvcnMsIGxldmVsLCBzaXplIDtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBpbmNsdWRlRmFsbGJhY2tDb2xvcnMgPSBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycyA7XG4gICAgbGV2ZWwgPSBhcmdzLmxldmVsO1xuICAgIHNpemUgPSBhcmdzLnNpemU7XG5cbiAgICBmb3IgKHZhciBpPSAwOyBpIDwgY29sb3JMaXN0Lmxlbmd0aCA7IGkrKykge1xuICAgICAgICByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShiYXNlQ29sb3IsIGNvbG9yTGlzdFtpXSk7XG4gICAgICAgIGlmIChyZWFkYWJpbGl0eSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgYmVzdFNjb3JlID0gcmVhZGFiaWxpdHk7XG4gICAgICAgICAgICBiZXN0Q29sb3IgPSB0aW55Y29sb3IoY29sb3JMaXN0W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aW55Y29sb3IuaXNSZWFkYWJsZShiYXNlQ29sb3IsIGJlc3RDb2xvciwge1wibGV2ZWxcIjpsZXZlbCxcInNpemVcIjpzaXplfSkgfHwgIWluY2x1ZGVGYWxsYmFja0NvbG9ycykge1xuICAgICAgICByZXR1cm4gYmVzdENvbG9yO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJncy5pbmNsdWRlRmFsbGJhY2tDb2xvcnM9ZmFsc2U7XG4gICAgICAgIHJldHVybiB0aW55Y29sb3IubW9zdFJlYWRhYmxlKGJhc2VDb2xvcixbXCIjZmZmXCIsIFwiIzAwMFwiXSxhcmdzKTtcbiAgICB9XG59O1xuXG5cbi8vIEJpZyBMaXN0IG9mIENvbG9yc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yPlxudmFyIG5hbWVzID0gdGlueWNvbG9yLm5hbWVzID0ge1xuICAgIGFsaWNlYmx1ZTogXCJmMGY4ZmZcIixcbiAgICBhbnRpcXVld2hpdGU6IFwiZmFlYmQ3XCIsXG4gICAgYXF1YTogXCIwZmZcIixcbiAgICBhcXVhbWFyaW5lOiBcIjdmZmZkNFwiLFxuICAgIGF6dXJlOiBcImYwZmZmZlwiLFxuICAgIGJlaWdlOiBcImY1ZjVkY1wiLFxuICAgIGJpc3F1ZTogXCJmZmU0YzRcIixcbiAgICBibGFjazogXCIwMDBcIixcbiAgICBibGFuY2hlZGFsbW9uZDogXCJmZmViY2RcIixcbiAgICBibHVlOiBcIjAwZlwiLFxuICAgIGJsdWV2aW9sZXQ6IFwiOGEyYmUyXCIsXG4gICAgYnJvd246IFwiYTUyYTJhXCIsXG4gICAgYnVybHl3b29kOiBcImRlYjg4N1wiLFxuICAgIGJ1cm50c2llbm5hOiBcImVhN2U1ZFwiLFxuICAgIGNhZGV0Ymx1ZTogXCI1ZjllYTBcIixcbiAgICBjaGFydHJldXNlOiBcIjdmZmYwMFwiLFxuICAgIGNob2NvbGF0ZTogXCJkMjY5MWVcIixcbiAgICBjb3JhbDogXCJmZjdmNTBcIixcbiAgICBjb3JuZmxvd2VyYmx1ZTogXCI2NDk1ZWRcIixcbiAgICBjb3Juc2lsazogXCJmZmY4ZGNcIixcbiAgICBjcmltc29uOiBcImRjMTQzY1wiLFxuICAgIGN5YW46IFwiMGZmXCIsXG4gICAgZGFya2JsdWU6IFwiMDAwMDhiXCIsXG4gICAgZGFya2N5YW46IFwiMDA4YjhiXCIsXG4gICAgZGFya2dvbGRlbnJvZDogXCJiODg2MGJcIixcbiAgICBkYXJrZ3JheTogXCJhOWE5YTlcIixcbiAgICBkYXJrZ3JlZW46IFwiMDA2NDAwXCIsXG4gICAgZGFya2dyZXk6IFwiYTlhOWE5XCIsXG4gICAgZGFya2toYWtpOiBcImJkYjc2YlwiLFxuICAgIGRhcmttYWdlbnRhOiBcIjhiMDA4YlwiLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiBcIjU1NmIyZlwiLFxuICAgIGRhcmtvcmFuZ2U6IFwiZmY4YzAwXCIsXG4gICAgZGFya29yY2hpZDogXCI5OTMyY2NcIixcbiAgICBkYXJrcmVkOiBcIjhiMDAwMFwiLFxuICAgIGRhcmtzYWxtb246IFwiZTk5NjdhXCIsXG4gICAgZGFya3NlYWdyZWVuOiBcIjhmYmM4ZlwiLFxuICAgIGRhcmtzbGF0ZWJsdWU6IFwiNDgzZDhiXCIsXG4gICAgZGFya3NsYXRlZ3JheTogXCIyZjRmNGZcIixcbiAgICBkYXJrc2xhdGVncmV5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmt0dXJxdW9pc2U6IFwiMDBjZWQxXCIsXG4gICAgZGFya3Zpb2xldDogXCI5NDAwZDNcIixcbiAgICBkZWVwcGluazogXCJmZjE0OTNcIixcbiAgICBkZWVwc2t5Ymx1ZTogXCIwMGJmZmZcIixcbiAgICBkaW1ncmF5OiBcIjY5Njk2OVwiLFxuICAgIGRpbWdyZXk6IFwiNjk2OTY5XCIsXG4gICAgZG9kZ2VyYmx1ZTogXCIxZTkwZmZcIixcbiAgICBmaXJlYnJpY2s6IFwiYjIyMjIyXCIsXG4gICAgZmxvcmFsd2hpdGU6IFwiZmZmYWYwXCIsXG4gICAgZm9yZXN0Z3JlZW46IFwiMjI4YjIyXCIsXG4gICAgZnVjaHNpYTogXCJmMGZcIixcbiAgICBnYWluc2Jvcm86IFwiZGNkY2RjXCIsXG4gICAgZ2hvc3R3aGl0ZTogXCJmOGY4ZmZcIixcbiAgICBnb2xkOiBcImZmZDcwMFwiLFxuICAgIGdvbGRlbnJvZDogXCJkYWE1MjBcIixcbiAgICBncmF5OiBcIjgwODA4MFwiLFxuICAgIGdyZWVuOiBcIjAwODAwMFwiLFxuICAgIGdyZWVueWVsbG93OiBcImFkZmYyZlwiLFxuICAgIGdyZXk6IFwiODA4MDgwXCIsXG4gICAgaG9uZXlkZXc6IFwiZjBmZmYwXCIsXG4gICAgaG90cGluazogXCJmZjY5YjRcIixcbiAgICBpbmRpYW5yZWQ6IFwiY2Q1YzVjXCIsXG4gICAgaW5kaWdvOiBcIjRiMDA4MlwiLFxuICAgIGl2b3J5OiBcImZmZmZmMFwiLFxuICAgIGtoYWtpOiBcImYwZTY4Y1wiLFxuICAgIGxhdmVuZGVyOiBcImU2ZTZmYVwiLFxuICAgIGxhdmVuZGVyYmx1c2g6IFwiZmZmMGY1XCIsXG4gICAgbGF3bmdyZWVuOiBcIjdjZmMwMFwiLFxuICAgIGxlbW9uY2hpZmZvbjogXCJmZmZhY2RcIixcbiAgICBsaWdodGJsdWU6IFwiYWRkOGU2XCIsXG4gICAgbGlnaHRjb3JhbDogXCJmMDgwODBcIixcbiAgICBsaWdodGN5YW46IFwiZTBmZmZmXCIsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiZmFmYWQyXCIsXG4gICAgbGlnaHRncmF5OiBcImQzZDNkM1wiLFxuICAgIGxpZ2h0Z3JlZW46IFwiOTBlZTkwXCIsXG4gICAgbGlnaHRncmV5OiBcImQzZDNkM1wiLFxuICAgIGxpZ2h0cGluazogXCJmZmI2YzFcIixcbiAgICBsaWdodHNhbG1vbjogXCJmZmEwN2FcIixcbiAgICBsaWdodHNlYWdyZWVuOiBcIjIwYjJhYVwiLFxuICAgIGxpZ2h0c2t5Ymx1ZTogXCI4N2NlZmFcIixcbiAgICBsaWdodHNsYXRlZ3JheTogXCI3ODlcIixcbiAgICBsaWdodHNsYXRlZ3JleTogXCI3ODlcIixcbiAgICBsaWdodHN0ZWVsYmx1ZTogXCJiMGM0ZGVcIixcbiAgICBsaWdodHllbGxvdzogXCJmZmZmZTBcIixcbiAgICBsaW1lOiBcIjBmMFwiLFxuICAgIGxpbWVncmVlbjogXCIzMmNkMzJcIixcbiAgICBsaW5lbjogXCJmYWYwZTZcIixcbiAgICBtYWdlbnRhOiBcImYwZlwiLFxuICAgIG1hcm9vbjogXCI4MDAwMDBcIixcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBcIjY2Y2RhYVwiLFxuICAgIG1lZGl1bWJsdWU6IFwiMDAwMGNkXCIsXG4gICAgbWVkaXVtb3JjaGlkOiBcImJhNTVkM1wiLFxuICAgIG1lZGl1bXB1cnBsZTogXCI5MzcwZGJcIixcbiAgICBtZWRpdW1zZWFncmVlbjogXCIzY2IzNzFcIixcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFwiN2I2OGVlXCIsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiMDBmYTlhXCIsXG4gICAgbWVkaXVtdHVycXVvaXNlOiBcIjQ4ZDFjY1wiLFxuICAgIG1lZGl1bXZpb2xldHJlZDogXCJjNzE1ODVcIixcbiAgICBtaWRuaWdodGJsdWU6IFwiMTkxOTcwXCIsXG4gICAgbWludGNyZWFtOiBcImY1ZmZmYVwiLFxuICAgIG1pc3R5cm9zZTogXCJmZmU0ZTFcIixcbiAgICBtb2NjYXNpbjogXCJmZmU0YjVcIixcbiAgICBuYXZham93aGl0ZTogXCJmZmRlYWRcIixcbiAgICBuYXZ5OiBcIjAwMDA4MFwiLFxuICAgIG9sZGxhY2U6IFwiZmRmNWU2XCIsXG4gICAgb2xpdmU6IFwiODA4MDAwXCIsXG4gICAgb2xpdmVkcmFiOiBcIjZiOGUyM1wiLFxuICAgIG9yYW5nZTogXCJmZmE1MDBcIixcbiAgICBvcmFuZ2VyZWQ6IFwiZmY0NTAwXCIsXG4gICAgb3JjaGlkOiBcImRhNzBkNlwiLFxuICAgIHBhbGVnb2xkZW5yb2Q6IFwiZWVlOGFhXCIsXG4gICAgcGFsZWdyZWVuOiBcIjk4ZmI5OFwiLFxuICAgIHBhbGV0dXJxdW9pc2U6IFwiYWZlZWVlXCIsXG4gICAgcGFsZXZpb2xldHJlZDogXCJkYjcwOTNcIixcbiAgICBwYXBheWF3aGlwOiBcImZmZWZkNVwiLFxuICAgIHBlYWNocHVmZjogXCJmZmRhYjlcIixcbiAgICBwZXJ1OiBcImNkODUzZlwiLFxuICAgIHBpbms6IFwiZmZjMGNiXCIsXG4gICAgcGx1bTogXCJkZGEwZGRcIixcbiAgICBwb3dkZXJibHVlOiBcImIwZTBlNlwiLFxuICAgIHB1cnBsZTogXCI4MDAwODBcIixcbiAgICByZWJlY2NhcHVycGxlOiBcIjY2MzM5OVwiLFxuICAgIHJlZDogXCJmMDBcIixcbiAgICByb3N5YnJvd246IFwiYmM4ZjhmXCIsXG4gICAgcm95YWxibHVlOiBcIjQxNjllMVwiLFxuICAgIHNhZGRsZWJyb3duOiBcIjhiNDUxM1wiLFxuICAgIHNhbG1vbjogXCJmYTgwNzJcIixcbiAgICBzYW5keWJyb3duOiBcImY0YTQ2MFwiLFxuICAgIHNlYWdyZWVuOiBcIjJlOGI1N1wiLFxuICAgIHNlYXNoZWxsOiBcImZmZjVlZVwiLFxuICAgIHNpZW5uYTogXCJhMDUyMmRcIixcbiAgICBzaWx2ZXI6IFwiYzBjMGMwXCIsXG4gICAgc2t5Ymx1ZTogXCI4N2NlZWJcIixcbiAgICBzbGF0ZWJsdWU6IFwiNmE1YWNkXCIsXG4gICAgc2xhdGVncmF5OiBcIjcwODA5MFwiLFxuICAgIHNsYXRlZ3JleTogXCI3MDgwOTBcIixcbiAgICBzbm93OiBcImZmZmFmYVwiLFxuICAgIHNwcmluZ2dyZWVuOiBcIjAwZmY3ZlwiLFxuICAgIHN0ZWVsYmx1ZTogXCI0NjgyYjRcIixcbiAgICB0YW46IFwiZDJiNDhjXCIsXG4gICAgdGVhbDogXCIwMDgwODBcIixcbiAgICB0aGlzdGxlOiBcImQ4YmZkOFwiLFxuICAgIHRvbWF0bzogXCJmZjYzNDdcIixcbiAgICB0dXJxdW9pc2U6IFwiNDBlMGQwXCIsXG4gICAgdmlvbGV0OiBcImVlODJlZVwiLFxuICAgIHdoZWF0OiBcImY1ZGViM1wiLFxuICAgIHdoaXRlOiBcImZmZlwiLFxuICAgIHdoaXRlc21va2U6IFwiZjVmNWY1XCIsXG4gICAgeWVsbG93OiBcImZmMFwiLFxuICAgIHllbGxvd2dyZWVuOiBcIjlhY2QzMlwiXG59O1xuXG4vLyBNYWtlIGl0IGVhc3kgdG8gYWNjZXNzIGNvbG9ycyB2aWEgYGhleE5hbWVzW2hleF1gXG52YXIgaGV4TmFtZXMgPSB0aW55Y29sb3IuaGV4TmFtZXMgPSBmbGlwKG5hbWVzKTtcblxuXG4vLyBVdGlsaXRpZXNcbi8vIC0tLS0tLS0tLVxuXG4vLyBgeyAnbmFtZTEnOiAndmFsMScgfWAgYmVjb21lcyBgeyAndmFsMSc6ICduYW1lMScgfWBcbmZ1bmN0aW9uIGZsaXAobykge1xuICAgIHZhciBmbGlwcGVkID0geyB9O1xuICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgZmxpcHBlZFtvW2ldXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsaXBwZWQ7XG59XG5cbi8vIFJldHVybiBhIHZhbGlkIGFscGhhIHZhbHVlIFswLDFdIHdpdGggYWxsIGludmFsaWQgdmFsdWVzIGJlaW5nIHNldCB0byAxXG5mdW5jdGlvbiBib3VuZEFscGhhKGEpIHtcbiAgICBhID0gcGFyc2VGbG9hdChhKTtcblxuICAgIGlmIChpc05hTihhKSB8fCBhIDwgMCB8fCBhID4gMSkge1xuICAgICAgICBhID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuLy8gVGFrZSBpbnB1dCBmcm9tIFswLCBuXSBhbmQgcmV0dXJuIGl0IGFzIFswLCAxXVxuZnVuY3Rpb24gYm91bmQwMShuLCBtYXgpIHtcbiAgICBpZiAoaXNPbmVQb2ludFplcm8obikpIHsgbiA9IFwiMTAwJVwiOyB9XG5cbiAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBpc1BlcmNlbnRhZ2Uobik7XG4gICAgbiA9IG1hdGhNaW4obWF4LCBtYXRoTWF4KDAsIHBhcnNlRmxvYXQobikpKTtcblxuICAgIC8vIEF1dG9tYXRpY2FsbHkgY29udmVydCBwZXJjZW50YWdlIGludG8gbnVtYmVyXG4gICAgaWYgKHByb2Nlc3NQZXJjZW50KSB7XG4gICAgICAgIG4gPSBwYXJzZUludChuICogbWF4LCAxMCkgLyAxMDA7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yc1xuICAgIGlmICgoTWF0aC5hYnMobiAtIG1heCkgPCAwLjAwMDAwMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIFswLCAxXSByYW5nZSBpZiBpdCBpc24ndCBhbHJlYWR5XG4gICAgcmV0dXJuIChuICUgbWF4KSAvIHBhcnNlRmxvYXQobWF4KTtcbn1cblxuLy8gRm9yY2UgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG5mdW5jdGlvbiBjbGFtcDAxKHZhbCkge1xuICAgIHJldHVybiBtYXRoTWluKDEsIG1hdGhNYXgoMCwgdmFsKSk7XG59XG5cbi8vIFBhcnNlIGEgYmFzZS0xNiBoZXggdmFsdWUgaW50byBhIGJhc2UtMTAgaW50ZWdlclxuZnVuY3Rpb24gcGFyc2VJbnRGcm9tSGV4KHZhbCkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDE2KTtcbn1cblxuLy8gTmVlZCB0byBoYW5kbGUgMS4wIGFzIDEwMCUsIHNpbmNlIG9uY2UgaXQgaXMgYSBudW1iZXIsIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiBpdCBhbmQgMVxuLy8gPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQyMjA3Mi9qYXZhc2NyaXB0LWhvdy10by1kZXRlY3QtbnVtYmVyLWFzLWEtZGVjaW1hbC1pbmNsdWRpbmctMS0wPlxuZnVuY3Rpb24gaXNPbmVQb2ludFplcm8obikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZignLicpICE9IC0xICYmIHBhcnNlRmxvYXQobikgPT09IDE7XG59XG5cbi8vIENoZWNrIHRvIHNlZSBpZiBzdHJpbmcgcGFzc2VkIGluIGlzIGEgcGVyY2VudGFnZVxuZnVuY3Rpb24gaXNQZXJjZW50YWdlKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCclJykgIT0gLTE7XG59XG5cbi8vIEZvcmNlIGEgaGV4IHZhbHVlIHRvIGhhdmUgMiBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBwYWQyKGMpIHtcbiAgICByZXR1cm4gYy5sZW5ndGggPT0gMSA/ICcwJyArIGMgOiAnJyArIGM7XG59XG5cbi8vIFJlcGxhY2UgYSBkZWNpbWFsIHdpdGggaXQncyBwZXJjZW50YWdlIHZhbHVlXG5mdW5jdGlvbiBjb252ZXJ0VG9QZXJjZW50YWdlKG4pIHtcbiAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgIG4gPSAobiAqIDEwMCkgKyBcIiVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuLy8gQ29udmVydHMgYSBkZWNpbWFsIHRvIGEgaGV4IHZhbHVlXG5mdW5jdGlvbiBjb252ZXJ0RGVjaW1hbFRvSGV4KGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGQpICogMjU1KS50b1N0cmluZygxNik7XG59XG4vLyBDb252ZXJ0cyBhIGhleCB2YWx1ZSB0byBhIGRlY2ltYWxcbmZ1bmN0aW9uIGNvbnZlcnRIZXhUb0RlY2ltYWwoaCkge1xuICAgIHJldHVybiAocGFyc2VJbnRGcm9tSGV4KGgpIC8gMjU1KTtcbn1cblxudmFyIG1hdGNoZXJzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdmFsdWVzLyNpbnRlZ2Vycz5cbiAgICB2YXIgQ1NTX0lOVEVHRVIgPSBcIlstXFxcXCtdP1xcXFxkKyU/XCI7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI251bWJlci12YWx1ZT5cbiAgICB2YXIgQ1NTX05VTUJFUiA9IFwiWy1cXFxcK10/XFxcXGQqXFxcXC5cXFxcZCslP1wiO1xuXG4gICAgLy8gQWxsb3cgcG9zaXRpdmUvbmVnYXRpdmUgaW50ZWdlci9udW1iZXIuICBEb24ndCBjYXB0dXJlIHRoZSBlaXRoZXIvb3IsIGp1c3QgdGhlIGVudGlyZSBvdXRjb21lLlxuICAgIHZhciBDU1NfVU5JVCA9IFwiKD86XCIgKyBDU1NfTlVNQkVSICsgXCIpfCg/OlwiICsgQ1NTX0lOVEVHRVIgKyBcIilcIjtcblxuICAgIC8vIEFjdHVhbCBtYXRjaGluZy5cbiAgICAvLyBQYXJlbnRoZXNlcyBhbmQgY29tbWFzIGFyZSBvcHRpb25hbCwgYnV0IG5vdCByZXF1aXJlZC5cbiAgICAvLyBXaGl0ZXNwYWNlIGNhbiB0YWtlIHRoZSBwbGFjZSBvZiBjb21tYXMgb3Igb3BlbmluZyBwYXJlblxuICAgIHZhciBQRVJNSVNTSVZFX01BVENIMyA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuICAgIHZhciBQRVJNSVNTSVZFX01BVENINCA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1NTX1VOSVQ6IG5ldyBSZWdFeHAoQ1NTX1VOSVQpLFxuICAgICAgICByZ2I6IG5ldyBSZWdFeHAoXCJyZ2JcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgcmdiYTogbmV3IFJlZ0V4cChcInJnYmFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaHNsOiBuZXcgUmVnRXhwKFwiaHNsXCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIGhzbGE6IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhzdjogbmV3IFJlZ0V4cChcImhzdlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICBoc3ZhOiBuZXcgUmVnRXhwKFwiaHN2YVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoZXgzOiAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC8sXG4gICAgICAgIGhleDY6IC9eIz8oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkLyxcbiAgICAgICAgaGV4NDogL14jPyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICAgICAgaGV4ODogL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkL1xuICAgIH07XG59KSgpO1xuXG4vLyBgaXNWYWxpZENTU1VuaXRgXG4vLyBUYWtlIGluIGEgc2luZ2xlIHN0cmluZyAvIG51bWJlciBhbmQgY2hlY2sgdG8gc2VlIGlmIGl0IGxvb2tzIGxpa2UgYSBDU1MgdW5pdFxuLy8gKHNlZSBgbWF0Y2hlcnNgIGFib3ZlIGZvciBkZWZpbml0aW9uKS5cbmZ1bmN0aW9uIGlzVmFsaWRDU1NVbml0KGNvbG9yKSB7XG4gICAgcmV0dXJuICEhbWF0Y2hlcnMuQ1NTX1VOSVQuZXhlYyhjb2xvcik7XG59XG5cbi8vIGBzdHJpbmdJbnB1dFRvT2JqZWN0YFxuLy8gUGVybWlzc2l2ZSBzdHJpbmcgcGFyc2luZy4gIFRha2UgaW4gYSBudW1iZXIgb2YgZm9ybWF0cywgYW5kIG91dHB1dCBhbiBvYmplY3Rcbi8vIGJhc2VkIG9uIGRldGVjdGVkIGZvcm1hdC4gIFJldHVybnMgYHsgciwgZywgYiB9YCBvciBgeyBoLCBzLCBsIH1gIG9yIGB7IGgsIHMsIHZ9YFxuZnVuY3Rpb24gc3RyaW5nSW5wdXRUb09iamVjdChjb2xvcikge1xuXG4gICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKHRyaW1MZWZ0LCcnKS5yZXBsYWNlKHRyaW1SaWdodCwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG5hbWVkID0gZmFsc2U7XG4gICAgaWYgKG5hbWVzW2NvbG9yXSkge1xuICAgICAgICBjb2xvciA9IG5hbWVzW2NvbG9yXTtcbiAgICAgICAgbmFtZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2xvciA9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHJldHVybiB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAsIGZvcm1hdDogXCJuYW1lXCIgfTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gbWF0Y2ggc3RyaW5nIGlucHV0IHVzaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgLy8gS2VlcCBtb3N0IG9mIHRoZSBudW1iZXIgYm91bmRpbmcgb3V0IG9mIHRoaXMgZnVuY3Rpb24gLSBkb24ndCB3b3JyeSBhYm91dCBbMCwxXSBvciBbMCwxMDBdIG9yIFswLDM2MF1cbiAgICAvLyBKdXN0IHJldHVybiBhbiBvYmplY3QgYW5kIGxldCB0aGUgY29udmVyc2lvbiBmdW5jdGlvbnMgaGFuZGxlIHRoYXQuXG4gICAgLy8gVGhpcyB3YXkgdGhlIHJlc3VsdCB3aWxsIGJlIHRoZSBzYW1lIHdoZXRoZXIgdGhlIHRpbnljb2xvciBpcyBpbml0aWFsaXplZCB3aXRoIHN0cmluZyBvciBvYmplY3QuXG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5yZ2IuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc2wuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc3YuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgdjogbWF0Y2hbM10gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdmEuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgdjogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg4LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgYTogY29udmVydEhleFRvRGVjaW1hbChtYXRjaFs0XSksXG4gICAgICAgICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleDhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4Ni5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0pLFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0gKyAnJyArIG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSArICcnICsgbWF0Y2hbMl0pLFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdICsgJycgKyBtYXRjaFszXSksXG4gICAgICAgICAgICBhOiBjb252ZXJ0SGV4VG9EZWNpbWFsKG1hdGNoWzRdICsgJycgKyBtYXRjaFs0XSksXG4gICAgICAgICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleDhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10gKyAnJyArIG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV0NBRzJQYXJtcyhwYXJtcykge1xuICAgIC8vIHJldHVybiB2YWxpZCBXQ0FHMiBwYXJtcyBmb3IgaXNSZWFkYWJsZS5cbiAgICAvLyBJZiBpbnB1dCBwYXJtcyBhcmUgaW52YWxpZCwgcmV0dXJuIHtcImxldmVsXCI6XCJBQVwiLCBcInNpemVcIjpcInNtYWxsXCJ9XG4gICAgdmFyIGxldmVsLCBzaXplO1xuICAgIHBhcm1zID0gcGFybXMgfHwge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn07XG4gICAgbGV2ZWwgPSAocGFybXMubGV2ZWwgfHwgXCJBQVwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIHNpemUgPSAocGFybXMuc2l6ZSB8fCBcInNtYWxsXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxldmVsICE9PSBcIkFBXCIgJiYgbGV2ZWwgIT09IFwiQUFBXCIpIHtcbiAgICAgICAgbGV2ZWwgPSBcIkFBXCI7XG4gICAgfVxuICAgIGlmIChzaXplICE9PSBcInNtYWxsXCIgJiYgc2l6ZSAhPT0gXCJsYXJnZVwiKSB7XG4gICAgICAgIHNpemUgPSBcInNtYWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB7XCJsZXZlbFwiOmxldmVsLCBcInNpemVcIjpzaXplfTtcbn1cblxuLy8gTm9kZTogRXhwb3J0IGZ1bmN0aW9uXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdGlueWNvbG9yO1xufVxuLy8gQU1EL3JlcXVpcmVqczogRGVmaW5lIHRoZSBtb2R1bGVcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7cmV0dXJuIHRpbnljb2xvcjt9KTtcbn1cbi8vIEJyb3dzZXI6IEV4cG9zZSB0byB3aW5kb3dcbmVsc2Uge1xuICAgIHdpbmRvdy50aW55Y29sb3IgPSB0aW55Y29sb3I7XG59XG5cbn0pKE1hdGgpO1xuIiwiLyogV2ViIEZvbnQgTG9hZGVyIHYxLjYuMjcgLSAoYykgQWRvYmUgU3lzdGVtcywgR29vZ2xlLiBMaWNlbnNlOiBBcGFjaGUgMi4wICovKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYWEoYSxiLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYmEoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gcChhLGIsYyl7cD1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCYmLTEhPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpP2FhOmJhO3JldHVybiBwLmFwcGx5KG51bGwsYXJndW1lbnRzKX12YXIgcT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9O2Z1bmN0aW9uIGNhKGEsYil7dGhpcy5hPWE7dGhpcy5tPWJ8fGE7dGhpcy5jPXRoaXMubS5kb2N1bWVudH12YXIgZGE9ISF3aW5kb3cuRm9udEZhY2U7ZnVuY3Rpb24gdChhLGIsYyxkKXtiPWEuYy5jcmVhdGVFbGVtZW50KGIpO2lmKGMpZm9yKHZhciBlIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShlKSYmKFwic3R5bGVcIj09ZT9iLnN0eWxlLmNzc1RleHQ9Y1tlXTpiLnNldEF0dHJpYnV0ZShlLGNbZV0pKTtkJiZiLmFwcGVuZENoaWxkKGEuYy5jcmVhdGVUZXh0Tm9kZShkKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gdShhLGIsYyl7YT1hLmMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYilbMF07YXx8KGE9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTthLmluc2VydEJlZm9yZShjLGEubGFzdENoaWxkKX1mdW5jdGlvbiB2KGEpe2EucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfVxuZnVuY3Rpb24gdyhhLGIsYyl7Yj1ifHxbXTtjPWN8fFtdO2Zvcih2YXIgZD1hLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLGU9MDtlPGIubGVuZ3RoO2UrPTEpe2Zvcih2YXIgZj0hMSxnPTA7ZzxkLmxlbmd0aDtnKz0xKWlmKGJbZV09PT1kW2ddKXtmPSEwO2JyZWFrfWZ8fGQucHVzaChiW2VdKX1iPVtdO2ZvcihlPTA7ZTxkLmxlbmd0aDtlKz0xKXtmPSExO2ZvcihnPTA7ZzxjLmxlbmd0aDtnKz0xKWlmKGRbZV09PT1jW2ddKXtmPSEwO2JyZWFrfWZ8fGIucHVzaChkW2VdKX1hLmNsYXNzTmFtZT1iLmpvaW4oXCIgXCIpLnJlcGxhY2UoL1xccysvZyxcIiBcIikucmVwbGFjZSgvXlxccyt8XFxzKyQvLFwiXCIpfWZ1bmN0aW9uIHkoYSxiKXtmb3IodmFyIGM9YS5jbGFzc05hbWUuc3BsaXQoL1xccysvKSxkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKWlmKGNbZF09PWIpcmV0dXJuITA7cmV0dXJuITF9XG5mdW5jdGlvbiB6KGEpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYS5mKXJldHVybiBhLmY7dmFyIGI9YS5tLmxvY2F0aW9uLnByb3RvY29sO1wiYWJvdXQ6XCI9PWImJihiPWEuYS5sb2NhdGlvbi5wcm90b2NvbCk7cmV0dXJuXCJodHRwczpcIj09Yj9cImh0dHBzOlwiOlwiaHR0cDpcIn1mdW5jdGlvbiBlYShhKXtyZXR1cm4gYS5tLmxvY2F0aW9uLmhvc3RuYW1lfHxhLmEubG9jYXRpb24uaG9zdG5hbWV9XG5mdW5jdGlvbiBBKGEsYixjKXtmdW5jdGlvbiBkKCl7ayYmZSYmZiYmKGsoZyksaz1udWxsKX1iPXQoYSxcImxpbmtcIix7cmVsOlwic3R5bGVzaGVldFwiLGhyZWY6YixtZWRpYTpcImFsbFwifSk7dmFyIGU9ITEsZj0hMCxnPW51bGwsaz1jfHxudWxsO2RhPyhiLm9ubG9hZD1mdW5jdGlvbigpe2U9ITA7ZCgpfSxiLm9uZXJyb3I9ZnVuY3Rpb24oKXtlPSEwO2c9RXJyb3IoXCJTdHlsZXNoZWV0IGZhaWxlZCB0byBsb2FkXCIpO2QoKX0pOnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlPSEwO2QoKX0sMCk7dShhLFwiaGVhZFwiLGIpfVxuZnVuY3Rpb24gQihhLGIsYyxkKXt2YXIgZT1hLmMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO2lmKGUpe3ZhciBmPXQoYSxcInNjcmlwdFwiLHtzcmM6Yn0pLGc9ITE7Zi5vbmxvYWQ9Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtnfHx0aGlzLnJlYWR5U3RhdGUmJlwibG9hZGVkXCIhPXRoaXMucmVhZHlTdGF0ZSYmXCJjb21wbGV0ZVwiIT10aGlzLnJlYWR5U3RhdGV8fChnPSEwLGMmJmMobnVsbCksZi5vbmxvYWQ9Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxcIkhFQURcIj09Zi5wYXJlbnROb2RlLnRhZ05hbWUmJmUucmVtb3ZlQ2hpbGQoZikpfTtlLmFwcGVuZENoaWxkKGYpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtnfHwoZz0hMCxjJiZjKEVycm9yKFwiU2NyaXB0IGxvYWQgdGltZW91dFwiKSkpfSxkfHw1RTMpO3JldHVybiBmfXJldHVybiBudWxsfTtmdW5jdGlvbiBDKCl7dGhpcy5hPTA7dGhpcy5jPW51bGx9ZnVuY3Rpb24gRChhKXthLmErKztyZXR1cm4gZnVuY3Rpb24oKXthLmEtLTtFKGEpfX1mdW5jdGlvbiBGKGEsYil7YS5jPWI7RShhKX1mdW5jdGlvbiBFKGEpezA9PWEuYSYmYS5jJiYoYS5jKCksYS5jPW51bGwpfTtmdW5jdGlvbiBHKGEpe3RoaXMuYT1hfHxcIi1cIn1HLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTA7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliLnB1c2goYXJndW1lbnRzW2NdLnJlcGxhY2UoL1tcXFdfXSsvZyxcIlwiKS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gYi5qb2luKHRoaXMuYSl9O2Z1bmN0aW9uIEgoYSxiKXt0aGlzLmM9YTt0aGlzLmY9NDt0aGlzLmE9XCJuXCI7dmFyIGM9KGJ8fFwibjRcIikubWF0Y2goL14oW25pb10pKFsxLTldKSQvaSk7YyYmKHRoaXMuYT1jWzFdLHRoaXMuZj1wYXJzZUludChjWzJdLDEwKSl9ZnVuY3Rpb24gZmEoYSl7cmV0dXJuIEkoYSkrXCIgXCIrKGEuZitcIjAwXCIpK1wiIDMwMHB4IFwiK0ooYS5jKX1mdW5jdGlvbiBKKGEpe3ZhciBiPVtdO2E9YS5zcGxpdCgvLFxccyovKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXS5yZXBsYWNlKC9bJ1wiXS9nLFwiXCIpOy0xIT1kLmluZGV4T2YoXCIgXCIpfHwvXlxcZC8udGVzdChkKT9iLnB1c2goXCInXCIrZCtcIidcIik6Yi5wdXNoKGQpfXJldHVybiBiLmpvaW4oXCIsXCIpfWZ1bmN0aW9uIEsoYSl7cmV0dXJuIGEuYSthLmZ9ZnVuY3Rpb24gSShhKXt2YXIgYj1cIm5vcm1hbFwiO1wib1wiPT09YS5hP2I9XCJvYmxpcXVlXCI6XCJpXCI9PT1hLmEmJihiPVwiaXRhbGljXCIpO3JldHVybiBifVxuZnVuY3Rpb24gZ2EoYSl7dmFyIGI9NCxjPVwiblwiLGQ9bnVsbDthJiYoKGQ9YS5tYXRjaCgvKG5vcm1hbHxvYmxpcXVlfGl0YWxpYykvaSkpJiZkWzFdJiYoYz1kWzFdLnN1YnN0cigwLDEpLnRvTG93ZXJDYXNlKCkpLChkPWEubWF0Y2goLyhbMS05XTAwfG5vcm1hbHxib2xkKS9pKSkmJmRbMV0mJigvYm9sZC9pLnRlc3QoZFsxXSk/Yj03Oi9bMS05XTAwLy50ZXN0KGRbMV0pJiYoYj1wYXJzZUludChkWzFdLnN1YnN0cigwLDEpLDEwKSkpKTtyZXR1cm4gYytifTtmdW5jdGlvbiBoYShhLGIpe3RoaXMuYz1hO3RoaXMuZj1hLm0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3RoaXMuaD1iO3RoaXMuYT1uZXcgRyhcIi1cIik7dGhpcy5qPSExIT09Yi5ldmVudHM7dGhpcy5nPSExIT09Yi5jbGFzc2VzfWZ1bmN0aW9uIGlhKGEpe2EuZyYmdyhhLmYsW2EuYS5jKFwid2ZcIixcImxvYWRpbmdcIildKTtMKGEsXCJsb2FkaW5nXCIpfWZ1bmN0aW9uIE0oYSl7aWYoYS5nKXt2YXIgYj15KGEuZixhLmEuYyhcIndmXCIsXCJhY3RpdmVcIikpLGM9W10sZD1bYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKV07Ynx8Yy5wdXNoKGEuYS5jKFwid2ZcIixcImluYWN0aXZlXCIpKTt3KGEuZixjLGQpfUwoYSxcImluYWN0aXZlXCIpfWZ1bmN0aW9uIEwoYSxiLGMpe2lmKGEuaiYmYS5oW2JdKWlmKGMpYS5oW2JdKGMuYyxLKGMpKTtlbHNlIGEuaFtiXSgpfTtmdW5jdGlvbiBqYSgpe3RoaXMuYz17fX1mdW5jdGlvbiBrYShhLGIsYyl7dmFyIGQ9W10sZTtmb3IoZSBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoZSkpe3ZhciBmPWEuY1tlXTtmJiZkLnB1c2goZihiW2VdLGMpKX1yZXR1cm4gZH07ZnVuY3Rpb24gTihhLGIpe3RoaXMuYz1hO3RoaXMuZj1iO3RoaXMuYT10KHRoaXMuYyxcInNwYW5cIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSx0aGlzLmYpfWZ1bmN0aW9uIE8oYSl7dShhLmMsXCJib2R5XCIsYS5hKX1mdW5jdGlvbiBQKGEpe3JldHVyblwiZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTk5OTlweDtsZWZ0Oi05OTk5cHg7Zm9udC1zaXplOjMwMHB4O3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87bGluZS1oZWlnaHQ6bm9ybWFsO21hcmdpbjowO3BhZGRpbmc6MDtmb250LXZhcmlhbnQ6bm9ybWFsO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpcIitKKGEuYykrXCI7XCIrKFwiZm9udC1zdHlsZTpcIitJKGEpK1wiO2ZvbnQtd2VpZ2h0OlwiKyhhLmYrXCIwMFwiKStcIjtcIil9O2Z1bmN0aW9uIFEoYSxiLGMsZCxlLGYpe3RoaXMuZz1hO3RoaXMuaj1iO3RoaXMuYT1kO3RoaXMuYz1jO3RoaXMuZj1lfHwzRTM7dGhpcy5oPWZ8fHZvaWQgMH1RLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYy5tLmRvY3VtZW50LGI9dGhpcyxjPXEoKSxkPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gaygpe3EoKS1jPj1iLmY/ZSgpOmEuZm9udHMubG9hZChmYShiLmEpLGIuaCkudGhlbihmdW5jdGlvbihhKXsxPD1hLmxlbmd0aD9kKCk6c2V0VGltZW91dChrLDI1KX0sZnVuY3Rpb24oKXtlKCl9KX1rKCl9KSxlPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEsZCl7c2V0VGltZW91dChkLGIuZil9KTtQcm9taXNlLnJhY2UoW2UsZF0pLnRoZW4oZnVuY3Rpb24oKXtiLmcoYi5hKX0sZnVuY3Rpb24oKXtiLmooYi5hKX0pfTtmdW5jdGlvbiBSKGEsYixjLGQsZSxmLGcpe3RoaXMudj1hO3RoaXMuQj1iO3RoaXMuYz1jO3RoaXMuYT1kO3RoaXMucz1nfHxcIkJFU2Jzd3lcIjt0aGlzLmY9e307dGhpcy53PWV8fDNFMzt0aGlzLnU9Znx8bnVsbDt0aGlzLm89dGhpcy5qPXRoaXMuaD10aGlzLmc9bnVsbDt0aGlzLmc9bmV3IE4odGhpcy5jLHRoaXMucyk7dGhpcy5oPW5ldyBOKHRoaXMuYyx0aGlzLnMpO3RoaXMuaj1uZXcgTih0aGlzLmMsdGhpcy5zKTt0aGlzLm89bmV3IE4odGhpcy5jLHRoaXMucyk7YT1uZXcgSCh0aGlzLmEuYytcIixzZXJpZlwiLEsodGhpcy5hKSk7YT1QKGEpO3RoaXMuZy5hLnN0eWxlLmNzc1RleHQ9YTthPW5ldyBIKHRoaXMuYS5jK1wiLHNhbnMtc2VyaWZcIixLKHRoaXMuYSkpO2E9UChhKTt0aGlzLmguYS5zdHlsZS5jc3NUZXh0PWE7YT1uZXcgSChcInNlcmlmXCIsSyh0aGlzLmEpKTthPVAoYSk7dGhpcy5qLmEuc3R5bGUuY3NzVGV4dD1hO2E9bmV3IEgoXCJzYW5zLXNlcmlmXCIsSyh0aGlzLmEpKTthPVxuUChhKTt0aGlzLm8uYS5zdHlsZS5jc3NUZXh0PWE7Tyh0aGlzLmcpO08odGhpcy5oKTtPKHRoaXMuaik7Tyh0aGlzLm8pfXZhciBTPXtEOlwic2VyaWZcIixDOlwic2Fucy1zZXJpZlwifSxUPW51bGw7ZnVuY3Rpb24gVSgpe2lmKG51bGw9PT1UKXt2YXIgYT0vQXBwbGVXZWJLaXRcXC8oWzAtOV0rKSg/OlxcLihbMC05XSspKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7VD0hIWEmJig1MzY+cGFyc2VJbnQoYVsxXSwxMCl8fDUzNj09PXBhcnNlSW50KGFbMV0sMTApJiYxMT49cGFyc2VJbnQoYVsyXSwxMCkpfXJldHVybiBUfVIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5mLnNlcmlmPXRoaXMuai5hLm9mZnNldFdpZHRoO3RoaXMuZltcInNhbnMtc2VyaWZcIl09dGhpcy5vLmEub2Zmc2V0V2lkdGg7dGhpcy5BPXEoKTtsYSh0aGlzKX07XG5mdW5jdGlvbiBtYShhLGIsYyl7Zm9yKHZhciBkIGluIFMpaWYoUy5oYXNPd25Qcm9wZXJ0eShkKSYmYj09PWEuZltTW2RdXSYmYz09PWEuZltTW2RdXSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBsYShhKXt2YXIgYj1hLmcuYS5vZmZzZXRXaWR0aCxjPWEuaC5hLm9mZnNldFdpZHRoLGQ7KGQ9Yj09PWEuZi5zZXJpZiYmYz09PWEuZltcInNhbnMtc2VyaWZcIl0pfHwoZD1VKCkmJm1hKGEsYixjKSk7ZD9xKCktYS5BPj1hLnc/VSgpJiZtYShhLGIsYykmJihudWxsPT09YS51fHxhLnUuaGFzT3duUHJvcGVydHkoYS5hLmMpKT9WKGEsYS52KTpWKGEsYS5CKTpuYShhKTpWKGEsYS52KX1mdW5jdGlvbiBuYShhKXtzZXRUaW1lb3V0KHAoZnVuY3Rpb24oKXtsYSh0aGlzKX0sYSksNTApfWZ1bmN0aW9uIFYoYSxiKXtzZXRUaW1lb3V0KHAoZnVuY3Rpb24oKXt2KHRoaXMuZy5hKTt2KHRoaXMuaC5hKTt2KHRoaXMuai5hKTt2KHRoaXMuby5hKTtiKHRoaXMuYSl9LGEpLDApfTtmdW5jdGlvbiBXKGEsYixjKXt0aGlzLmM9YTt0aGlzLmE9Yjt0aGlzLmY9MDt0aGlzLm89dGhpcy5qPSExO3RoaXMucz1jfXZhciBYPW51bGw7Vy5wcm90b3R5cGUuZz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmE7Yi5nJiZ3KGIuZixbYi5hLmMoXCJ3ZlwiLGEuYyxLKGEpLnRvU3RyaW5nKCksXCJhY3RpdmVcIildLFtiLmEuYyhcIndmXCIsYS5jLEsoYSkudG9TdHJpbmcoKSxcImxvYWRpbmdcIiksYi5hLmMoXCJ3ZlwiLGEuYyxLKGEpLnRvU3RyaW5nKCksXCJpbmFjdGl2ZVwiKV0pO0woYixcImZvbnRhY3RpdmVcIixhKTt0aGlzLm89ITA7b2EodGhpcyl9O1xuVy5wcm90b3R5cGUuaD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmE7aWYoYi5nKXt2YXIgYz15KGIuZixiLmEuYyhcIndmXCIsYS5jLEsoYSkudG9TdHJpbmcoKSxcImFjdGl2ZVwiKSksZD1bXSxlPVtiLmEuYyhcIndmXCIsYS5jLEsoYSkudG9TdHJpbmcoKSxcImxvYWRpbmdcIildO2N8fGQucHVzaChiLmEuYyhcIndmXCIsYS5jLEsoYSkudG9TdHJpbmcoKSxcImluYWN0aXZlXCIpKTt3KGIuZixkLGUpfUwoYixcImZvbnRpbmFjdGl2ZVwiLGEpO29hKHRoaXMpfTtmdW5jdGlvbiBvYShhKXswPT0tLWEuZiYmYS5qJiYoYS5vPyhhPWEuYSxhLmcmJncoYS5mLFthLmEuYyhcIndmXCIsXCJhY3RpdmVcIildLFthLmEuYyhcIndmXCIsXCJsb2FkaW5nXCIpLGEuYS5jKFwid2ZcIixcImluYWN0aXZlXCIpXSksTChhLFwiYWN0aXZlXCIpKTpNKGEuYSkpfTtmdW5jdGlvbiBwYShhKXt0aGlzLmo9YTt0aGlzLmE9bmV3IGphO3RoaXMuaD0wO3RoaXMuZj10aGlzLmc9ITB9cGEucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7dGhpcy5jPW5ldyBjYSh0aGlzLmosYS5jb250ZXh0fHx0aGlzLmopO3RoaXMuZz0hMSE9PWEuZXZlbnRzO3RoaXMuZj0hMSE9PWEuY2xhc3NlcztxYSh0aGlzLG5ldyBoYSh0aGlzLmMsYSksYSl9O1xuZnVuY3Rpb24gcmEoYSxiLGMsZCxlKXt2YXIgZj0wPT0tLWEuaDsoYS5mfHxhLmcpJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGE9ZXx8bnVsbCxrPWR8fG51bGx8fHt9O2lmKDA9PT1jLmxlbmd0aCYmZilNKGIuYSk7ZWxzZXtiLmYrPWMubGVuZ3RoO2YmJihiLmo9Zik7dmFyIGgsbT1bXTtmb3IoaD0wO2g8Yy5sZW5ndGg7aCsrKXt2YXIgbD1jW2hdLG49a1tsLmNdLHI9Yi5hLHg9bDtyLmcmJncoci5mLFtyLmEuYyhcIndmXCIseC5jLEsoeCkudG9TdHJpbmcoKSxcImxvYWRpbmdcIildKTtMKHIsXCJmb250bG9hZGluZ1wiLHgpO3I9bnVsbDtpZihudWxsPT09WClpZih3aW5kb3cuRm9udEZhY2Upe3ZhciB4PS9HZWNrby4qRmlyZWZveFxcLyhcXGQrKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkseWE9L09TIFguKlZlcnNpb25cXC8xMFxcLi4qU2FmYXJpLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSYmL0FwcGxlLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudmVuZG9yKTtcblg9eD80MjxwYXJzZUludCh4WzFdLDEwKTp5YT8hMTohMH1lbHNlIFg9ITE7WD9yPW5ldyBRKHAoYi5nLGIpLHAoYi5oLGIpLGIuYyxsLGIucyxuKTpyPW5ldyBSKHAoYi5nLGIpLHAoYi5oLGIpLGIuYyxsLGIucyxhLG4pO20ucHVzaChyKX1mb3IoaD0wO2g8bS5sZW5ndGg7aCsrKW1baF0uc3RhcnQoKX19LDApfWZ1bmN0aW9uIHFhKGEsYixjKXt2YXIgZD1bXSxlPWMudGltZW91dDtpYShiKTt2YXIgZD1rYShhLmEsYyxhLmMpLGY9bmV3IFcoYS5jLGIsZSk7YS5oPWQubGVuZ3RoO2I9MDtmb3IoYz1kLmxlbmd0aDtiPGM7YisrKWRbYl0ubG9hZChmdW5jdGlvbihiLGQsYyl7cmEoYSxmLGIsZCxjKX0pfTtmdW5jdGlvbiBzYShhLGIpe3RoaXMuYz1hO3RoaXMuYT1ifWZ1bmN0aW9uIHRhKGEsYixjKXt2YXIgZD16KGEuYyk7YT0oYS5hLmFwaXx8XCJmYXN0LmZvbnRzLm5ldC9qc2FwaVwiKS5yZXBsYWNlKC9eLipodHRwKHM/KTooXFwvXFwvKT8vLFwiXCIpO3JldHVybiBkK1wiLy9cIithK1wiL1wiK2IrXCIuanNcIisoYz9cIj92PVwiK2M6XCJcIil9XG5zYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7aWYoZltcIl9fbXRpX2ZudExzdFwiK2RdKXt2YXIgYz1mW1wiX19tdGlfZm50THN0XCIrZF0oKSxlPVtdLGg7aWYoYylmb3IodmFyIG09MDttPGMubGVuZ3RoO20rKyl7dmFyIGw9Y1ttXS5mb250ZmFtaWx5O3ZvaWQgMCE9Y1ttXS5mb250U3R5bGUmJnZvaWQgMCE9Y1ttXS5mb250V2VpZ2h0PyhoPWNbbV0uZm9udFN0eWxlK2NbbV0uZm9udFdlaWdodCxlLnB1c2gobmV3IEgobCxoKSkpOmUucHVzaChuZXcgSChsKSl9YShlKX1lbHNlIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiKCl9LDUwKX12YXIgYz10aGlzLGQ9Yy5hLnByb2plY3RJZCxlPWMuYS52ZXJzaW9uO2lmKGQpe3ZhciBmPWMuYy5tO0IodGhpcy5jLHRhKGMsZCxlKSxmdW5jdGlvbihlKXtlP2EoW10pOihmW1wiX19Nb25vdHlwZUNvbmZpZ3VyYXRpb25fX1wiK2RdPWZ1bmN0aW9uKCl7cmV0dXJuIGMuYX0sYigpKX0pLmlkPVwiX19Nb25vdHlwZUFQSVNjcmlwdF9fXCIrXG5kfWVsc2UgYShbXSl9O2Z1bmN0aW9uIHVhKGEsYil7dGhpcy5jPWE7dGhpcy5hPWJ9dWEucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPXRoaXMuYS51cmxzfHxbXSxlPXRoaXMuYS5mYW1pbGllc3x8W10sZj10aGlzLmEudGVzdFN0cmluZ3N8fHt9LGc9bmV3IEM7Yj0wO2ZvcihjPWQubGVuZ3RoO2I8YztiKyspQSh0aGlzLmMsZFtiXSxEKGcpKTt2YXIgaz1bXTtiPTA7Zm9yKGM9ZS5sZW5ndGg7YjxjO2IrKylpZihkPWVbYl0uc3BsaXQoXCI6XCIpLGRbMV0pZm9yKHZhciBoPWRbMV0uc3BsaXQoXCIsXCIpLG09MDttPGgubGVuZ3RoO20rPTEpay5wdXNoKG5ldyBIKGRbMF0saFttXSkpO2Vsc2Ugay5wdXNoKG5ldyBIKGRbMF0pKTtGKGcsZnVuY3Rpb24oKXthKGssZil9KX07ZnVuY3Rpb24gdmEoYSxiLGMpe2E/dGhpcy5jPWE6dGhpcy5jPWIrd2E7dGhpcy5hPVtdO3RoaXMuZj1bXTt0aGlzLmc9Y3x8XCJcIn12YXIgd2E9XCIvL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzc1wiO2Z1bmN0aW9uIHhhKGEsYil7Zm9yKHZhciBjPWIubGVuZ3RoLGQ9MDtkPGM7ZCsrKXt2YXIgZT1iW2RdLnNwbGl0KFwiOlwiKTszPT1lLmxlbmd0aCYmYS5mLnB1c2goZS5wb3AoKSk7dmFyIGY9XCJcIjsyPT1lLmxlbmd0aCYmXCJcIiE9ZVsxXSYmKGY9XCI6XCIpO2EuYS5wdXNoKGUuam9pbihmKSl9fVxuZnVuY3Rpb24gemEoYSl7aWYoMD09YS5hLmxlbmd0aCl0aHJvdyBFcnJvcihcIk5vIGZvbnRzIHRvIGxvYWQhXCIpO2lmKC0xIT1hLmMuaW5kZXhPZihcImtpdD1cIikpcmV0dXJuIGEuYztmb3IodmFyIGI9YS5hLmxlbmd0aCxjPVtdLGQ9MDtkPGI7ZCsrKWMucHVzaChhLmFbZF0ucmVwbGFjZSgvIC9nLFwiK1wiKSk7Yj1hLmMrXCI/ZmFtaWx5PVwiK2Muam9pbihcIiU3Q1wiKTswPGEuZi5sZW5ndGgmJihiKz1cIiZzdWJzZXQ9XCIrYS5mLmpvaW4oXCIsXCIpKTswPGEuZy5sZW5ndGgmJihiKz1cIiZ0ZXh0PVwiK2VuY29kZVVSSUNvbXBvbmVudChhLmcpKTtyZXR1cm4gYn07ZnVuY3Rpb24gQWEoYSl7dGhpcy5mPWE7dGhpcy5hPVtdO3RoaXMuYz17fX1cbnZhciBCYT17bGF0aW46XCJCRVNic3d5XCIsXCJsYXRpbi1leHRcIjpcIlxcdTAwZTdcXHUwMGY2XFx1MDBmY1xcdTAxMWZcXHUwMTVmXCIsY3lyaWxsaWM6XCJcXHUwNDM5XFx1MDQ0ZlxcdTA0MTZcIixncmVlazpcIlxcdTAzYjFcXHUwM2IyXFx1MDNhM1wiLGtobWVyOlwiXFx1MTc4MFxcdTE3ODFcXHUxNzgyXCIsSGFudW1hbjpcIlxcdTE3ODBcXHUxNzgxXFx1MTc4MlwifSxDYT17dGhpbjpcIjFcIixleHRyYWxpZ2h0OlwiMlwiLFwiZXh0cmEtbGlnaHRcIjpcIjJcIix1bHRyYWxpZ2h0OlwiMlwiLFwidWx0cmEtbGlnaHRcIjpcIjJcIixsaWdodDpcIjNcIixyZWd1bGFyOlwiNFwiLGJvb2s6XCI0XCIsbWVkaXVtOlwiNVwiLFwic2VtaS1ib2xkXCI6XCI2XCIsc2VtaWJvbGQ6XCI2XCIsXCJkZW1pLWJvbGRcIjpcIjZcIixkZW1pYm9sZDpcIjZcIixib2xkOlwiN1wiLFwiZXh0cmEtYm9sZFwiOlwiOFwiLGV4dHJhYm9sZDpcIjhcIixcInVsdHJhLWJvbGRcIjpcIjhcIix1bHRyYWJvbGQ6XCI4XCIsYmxhY2s6XCI5XCIsaGVhdnk6XCI5XCIsbDpcIjNcIixyOlwiNFwiLGI6XCI3XCJ9LERhPXtpOlwiaVwiLGl0YWxpYzpcImlcIixuOlwiblwiLG5vcm1hbDpcIm5cIn0sXG5FYT0vXih0aGlufCg/Oig/OmV4dHJhfHVsdHJhKS0/KT9saWdodHxyZWd1bGFyfGJvb2t8bWVkaXVtfCg/Oig/OnNlbWl8ZGVtaXxleHRyYXx1bHRyYSktPyk/Ym9sZHxibGFja3xoZWF2eXxsfHJ8YnxbMS05XTAwKT8obnxpfG5vcm1hbHxpdGFsaWMpPyQvO1xuZnVuY3Rpb24gRmEoYSl7Zm9yKHZhciBiPWEuZi5sZW5ndGgsYz0wO2M8YjtjKyspe3ZhciBkPWEuZltjXS5zcGxpdChcIjpcIiksZT1kWzBdLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSxmPVtcIm40XCJdO2lmKDI8PWQubGVuZ3RoKXt2YXIgZzt2YXIgaz1kWzFdO2c9W107aWYoaylmb3IodmFyIGs9ay5zcGxpdChcIixcIiksaD1rLmxlbmd0aCxtPTA7bTxoO20rKyl7dmFyIGw7bD1rW21dO2lmKGwubWF0Y2goL15bXFx3LV0rJC8pKXt2YXIgbj1FYS5leGVjKGwudG9Mb3dlckNhc2UoKSk7aWYobnVsbD09bilsPVwiXCI7ZWxzZXtsPW5bMl07bD1udWxsPT1sfHxcIlwiPT1sP1wiblwiOkRhW2xdO249blsxXTtpZihudWxsPT1ufHxcIlwiPT1uKW49XCI0XCI7ZWxzZSB2YXIgcj1DYVtuXSxuPXI/cjppc05hTihuKT9cIjRcIjpuLnN1YnN0cigwLDEpO2w9W2wsbl0uam9pbihcIlwiKX19ZWxzZSBsPVwiXCI7bCYmZy5wdXNoKGwpfTA8Zy5sZW5ndGgmJihmPWcpOzM9PWQubGVuZ3RoJiYoZD1kWzJdLGc9W10sZD1kP2Quc3BsaXQoXCIsXCIpOlxuZywwPGQubGVuZ3RoJiYoZD1CYVtkWzBdXSkmJihhLmNbZV09ZCkpfWEuY1tlXXx8KGQ9QmFbZV0pJiYoYS5jW2VdPWQpO2ZvcihkPTA7ZDxmLmxlbmd0aDtkKz0xKWEuYS5wdXNoKG5ldyBIKGUsZltkXSkpfX07ZnVuY3Rpb24gR2EoYSxiKXt0aGlzLmM9YTt0aGlzLmE9Yn12YXIgSGE9e0FyaW1vOiEwLENvdXNpbmU6ITAsVGlub3M6ITB9O0dhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBDLGM9dGhpcy5jLGQ9bmV3IHZhKHRoaXMuYS5hcGkseihjKSx0aGlzLmEudGV4dCksZT10aGlzLmEuZmFtaWxpZXM7eGEoZCxlKTt2YXIgZj1uZXcgQWEoZSk7RmEoZik7QShjLHphKGQpLEQoYikpO0YoYixmdW5jdGlvbigpe2EoZi5hLGYuYyxIYSl9KX07ZnVuY3Rpb24gSWEoYSxiKXt0aGlzLmM9YTt0aGlzLmE9Yn1JYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmEuaWQsYz10aGlzLmMubTtiP0IodGhpcy5jLCh0aGlzLmEuYXBpfHxcImh0dHBzOi8vdXNlLnR5cGVraXQubmV0XCIpK1wiL1wiK2IrXCIuanNcIixmdW5jdGlvbihiKXtpZihiKWEoW10pO2Vsc2UgaWYoYy5UeXBla2l0JiZjLlR5cGVraXQuY29uZmlnJiZjLlR5cGVraXQuY29uZmlnLmZuKXtiPWMuVHlwZWtpdC5jb25maWcuZm47Zm9yKHZhciBlPVtdLGY9MDtmPGIubGVuZ3RoO2YrPTIpZm9yKHZhciBnPWJbZl0saz1iW2YrMV0saD0wO2g8ay5sZW5ndGg7aCsrKWUucHVzaChuZXcgSChnLGtbaF0pKTt0cnl7Yy5UeXBla2l0LmxvYWQoe2V2ZW50czohMSxjbGFzc2VzOiExLGFzeW5jOiEwfSl9Y2F0Y2gobSl7fWEoZSl9fSwyRTMpOmEoW10pfTtmdW5jdGlvbiBKYShhLGIpe3RoaXMuYz1hO3RoaXMuZj1iO3RoaXMuYT1bXX1KYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmYuaWQsYz10aGlzLmMubSxkPXRoaXM7Yj8oYy5fX3dlYmZvbnRmb250ZGVja21vZHVsZV9ffHwoYy5fX3dlYmZvbnRmb250ZGVja21vZHVsZV9fPXt9KSxjLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX19bYl09ZnVuY3Rpb24oYixjKXtmb3IodmFyIGc9MCxrPWMuZm9udHMubGVuZ3RoO2c8azsrK2cpe3ZhciBoPWMuZm9udHNbZ107ZC5hLnB1c2gobmV3IEgoaC5uYW1lLGdhKFwiZm9udC13ZWlnaHQ6XCIraC53ZWlnaHQrXCI7Zm9udC1zdHlsZTpcIitoLnN0eWxlKSkpfWEoZC5hKX0sQih0aGlzLmMseih0aGlzLmMpKyh0aGlzLmYuYXBpfHxcIi8vZi5mb250ZGVjay5jb20vcy9jc3MvanMvXCIpK2VhKHRoaXMuYykrXCIvXCIrYitcIi5qc1wiLGZ1bmN0aW9uKGIpe2ImJmEoW10pfSkpOmEoW10pfTt2YXIgWT1uZXcgcGEod2luZG93KTtZLmEuYy5jdXN0b209ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IHVhKGIsYSl9O1kuYS5jLmZvbnRkZWNrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBKYShiLGEpfTtZLmEuYy5tb25vdHlwZT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgc2EoYixhKX07WS5hLmMudHlwZWtpdD1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgSWEoYixhKX07WS5hLmMuZ29vZ2xlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBHYShiLGEpfTt2YXIgWj17bG9hZDpwKFkubG9hZCxZKX07XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gWn0pOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1aOih3aW5kb3cuV2ViRm9udD1aLHdpbmRvdy5XZWJGb250Q29uZmlnJiZZLmxvYWQod2luZG93LldlYkZvbnRDb25maWcpKTt9KCkpO1xuIiwiXG52YXIgemlwID0gcmVxdWlyZSgnemlwJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVybChzcmMpe1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzcmNdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbnZhciB6V29ya2VyID0gY3JlYXRlVXJsKFwiLyoganNoaW50IHdvcmtlcjp0cnVlICovXFxuKGZ1bmN0aW9uIG1haW4oZ2xvYmFsKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGlmIChnbG9iYWwueldvcmtlckluaXRpYWxpemVkKVxcblxcdFxcdHRocm93IG5ldyBFcnJvcignei13b3JrZXIuanMgc2hvdWxkIGJlIHJ1biBvbmx5IG9uY2UnKTtcXG5cXHRnbG9iYWwueldvcmtlckluaXRpYWxpemVkID0gdHJ1ZTtcXG5cXG5cXHRhZGRFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIiwgZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgbWVzc2FnZSA9IGV2ZW50LmRhdGEsIHR5cGUgPSBtZXNzYWdlLnR5cGUsIHNuID0gbWVzc2FnZS5zbjtcXG5cXHRcXHR2YXIgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdO1xcblxcdFxcdGlmIChoYW5kbGVyKSB7XFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRoYW5kbGVyKG1lc3NhZ2UpO1xcblxcdFxcdFxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRcXHRcXHRvbkVycm9yKHR5cGUsIHNuLCBlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdC8vZm9yIGRlYnVnXFxuXFx0XFx0Ly9wb3N0TWVzc2FnZSh7dHlwZTogJ2VjaG8nLCBvcmlnaW5hbFR5cGU6IHR5cGUsIHNuOiBzbn0pO1xcblxcdH0pO1xcblxcblxcdHZhciBoYW5kbGVycyA9IHtcXG5cXHRcXHRpbXBvcnRTY3JpcHRzOiBkb0ltcG9ydFNjcmlwdHMsXFxuXFx0XFx0bmV3VGFzazogbmV3VGFzayxcXG5cXHRcXHRhcHBlbmQ6IHByb2Nlc3NEYXRhLFxcblxcdFxcdGZsdXNoOiBwcm9jZXNzRGF0YSxcXG5cXHR9O1xcblxcblxcdC8vIGRlZmxhdGVyL2luZmxhdGVyIHRhc2tzIGluZGV4ZWQgYnkgc2VyaWFsIG51bWJlcnNcXG5cXHR2YXIgdGFza3MgPSB7fTtcXG5cXG5cXHRmdW5jdGlvbiBkb0ltcG9ydFNjcmlwdHMobXNnKSB7XFxuXFx0XFx0aWYgKG1zZy5zY3JpcHRzICYmIG1zZy5zY3JpcHRzLmxlbmd0aCA+IDApXFxuXFx0XFx0XFx0aW1wb3J0U2NyaXB0cy5hcHBseSh1bmRlZmluZWQsIG1zZy5zY3JpcHRzKTtcXG5cXHRcXHRwb3N0TWVzc2FnZSh7dHlwZTogJ2ltcG9ydFNjcmlwdHMnfSk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIG5ld1Rhc2sobXNnKSB7XFxuXFx0XFx0dmFyIENvZGVjQ2xhc3MgPSBnbG9iYWxbbXNnLmNvZGVjQ2xhc3NdO1xcblxcdFxcdHZhciBzbiA9IG1zZy5zbjtcXG5cXHRcXHRpZiAodGFza3Nbc25dKVxcblxcdFxcdFxcdHRocm93IEVycm9yKCdkdXBsaWNhdGVkIHNuJyk7XFxuXFx0XFx0dGFza3Nbc25dID0gIHtcXG5cXHRcXHRcXHRjb2RlYzogbmV3IENvZGVjQ2xhc3MobXNnLm9wdGlvbnMpLFxcblxcdFxcdFxcdGNyY0lucHV0OiBtc2cuY3JjVHlwZSA9PT0gJ2lucHV0JyxcXG5cXHRcXHRcXHRjcmNPdXRwdXQ6IG1zZy5jcmNUeXBlID09PSAnb3V0cHV0JyxcXG5cXHRcXHRcXHRjcmM6IG5ldyBDcmMzMigpLFxcblxcdFxcdH07XFxuXFx0XFx0cG9zdE1lc3NhZ2Uoe3R5cGU6ICduZXdUYXNrJywgc246IHNufSk7XFxuXFx0fVxcblxcblxcdC8vIHBlcmZvcm1hbmNlIG1heSBub3QgYmUgc3VwcG9ydGVkXFxuXFx0dmFyIG5vdyA9IGdsb2JhbC5wZXJmb3JtYW5jZSA/IGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cuYmluZChnbG9iYWwucGVyZm9ybWFuY2UpIDogRGF0ZS5ub3c7XFxuXFxuXFx0ZnVuY3Rpb24gcHJvY2Vzc0RhdGEobXNnKSB7XFxuXFx0XFx0dmFyIHNuID0gbXNnLnNuLCB0eXBlID0gbXNnLnR5cGUsIGlucHV0ID0gbXNnLmRhdGE7XFxuXFx0XFx0dmFyIHRhc2sgPSB0YXNrc1tzbl07XFxuXFx0XFx0Ly8gYWxsb3cgY3JlYXRpbmcgY29kZWMgb24gZmlyc3QgYXBwZW5kXFxuXFx0XFx0aWYgKCF0YXNrICYmIG1zZy5jb2RlY0NsYXNzKSB7XFxuXFx0XFx0XFx0bmV3VGFzayhtc2cpO1xcblxcdFxcdFxcdHRhc2sgPSB0YXNrc1tzbl07XFxuXFx0XFx0fVxcblxcdFxcdHZhciBpc0FwcGVuZCA9IHR5cGUgPT09ICdhcHBlbmQnO1xcblxcdFxcdHZhciBzdGFydCA9IG5vdygpO1xcblxcdFxcdHZhciBvdXRwdXQ7XFxuXFx0XFx0aWYgKGlzQXBwZW5kKSB7XFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRvdXRwdXQgPSB0YXNrLmNvZGVjLmFwcGVuZChpbnB1dCwgZnVuY3Rpb24gb25wcm9ncmVzcyhsb2FkZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3N0TWVzc2FnZSh7dHlwZTogJ3Byb2dyZXNzJywgc246IHNuLCBsb2FkZWQ6IGxvYWRlZH0pO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdGFza3Nbc25dO1xcblxcdFxcdFxcdFxcdHRocm93IGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZGVsZXRlIHRhc2tzW3NuXTtcXG5cXHRcXHRcXHRvdXRwdXQgPSB0YXNrLmNvZGVjLmZsdXNoKCk7XFxuXFx0XFx0fVxcblxcdFxcdHZhciBjb2RlY1RpbWUgPSBub3coKSAtIHN0YXJ0O1xcblxcblxcdFxcdHN0YXJ0ID0gbm93KCk7XFxuXFx0XFx0aWYgKGlucHV0ICYmIHRhc2suY3JjSW5wdXQpXFxuXFx0XFx0XFx0dGFzay5jcmMuYXBwZW5kKGlucHV0KTtcXG5cXHRcXHRpZiAob3V0cHV0ICYmIHRhc2suY3JjT3V0cHV0KVxcblxcdFxcdFxcdHRhc2suY3JjLmFwcGVuZChvdXRwdXQpO1xcblxcdFxcdHZhciBjcmNUaW1lID0gbm93KCkgLSBzdGFydDtcXG5cXG5cXHRcXHR2YXIgcm1zZyA9IHt0eXBlOiB0eXBlLCBzbjogc24sIGNvZGVjVGltZTogY29kZWNUaW1lLCBjcmNUaW1lOiBjcmNUaW1lfTtcXG5cXHRcXHR2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xcblxcdFxcdGlmIChvdXRwdXQpIHtcXG5cXHRcXHRcXHRybXNnLmRhdGEgPSBvdXRwdXQ7XFxuXFx0XFx0XFx0dHJhbnNmZXJhYmxlcy5wdXNoKG91dHB1dC5idWZmZXIpO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIWlzQXBwZW5kICYmICh0YXNrLmNyY0lucHV0IHx8IHRhc2suY3JjT3V0cHV0KSlcXG5cXHRcXHRcXHRybXNnLmNyYyA9IHRhc2suY3JjLmdldCgpO1xcblxcdFxcdFxcblxcdFxcdC8vIHBvc3RpbmcgYSBtZXNzYWdlIHdpdGggdHJhbnNmZXJhYmxlcyB3aWxsIGZhaWwgb24gSUUxMFxcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0cG9zdE1lc3NhZ2Uocm1zZywgdHJhbnNmZXJhYmxlcyk7XFxuXFx0XFx0fSBjYXRjaChleCkge1xcblxcdFxcdFxcdHBvc3RNZXNzYWdlKHJtc2cpOyAvLyByZXRyeSB3aXRob3V0IHRyYW5zZmVyYWJsZXNcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIG9uRXJyb3IodHlwZSwgc24sIGUpIHtcXG5cXHRcXHR2YXIgbXNnID0ge1xcblxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0c246IHNuLFxcblxcdFxcdFxcdGVycm9yOiBmb3JtYXRFcnJvcihlKVxcblxcdFxcdH07XFxuXFx0XFx0cG9zdE1lc3NhZ2UobXNnKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZm9ybWF0RXJyb3IoZSkge1xcblxcdFxcdHJldHVybiB7IG1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2sgfTtcXG5cXHR9XFxuXFxuXFx0Ly8gQ3JjMzIgY29kZSBjb3BpZWQgZnJvbSBmaWxlIHppcC5qc1xcblxcdGZ1bmN0aW9uIENyYzMyKCkge1xcblxcdFxcdHRoaXMuY3JjID0gLTE7XFxuXFx0fVxcblxcdENyYzMyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoZGF0YSkge1xcblxcdFxcdHZhciBjcmMgPSB0aGlzLmNyYyB8IDAsIHRhYmxlID0gdGhpcy50YWJsZTtcXG5cXHRcXHRmb3IgKHZhciBvZmZzZXQgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aCB8IDA7IG9mZnNldCA8IGxlbjsgb2Zmc2V0KyspXFxuXFx0XFx0XFx0Y3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtvZmZzZXRdKSAmIDB4RkZdO1xcblxcdFxcdHRoaXMuY3JjID0gY3JjO1xcblxcdH07XFxuXFx0Q3JjMzIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcXG5cXHRcXHRyZXR1cm4gfnRoaXMuY3JjO1xcblxcdH07XFxuXFx0Q3JjMzIucHJvdG90eXBlLnRhYmxlID0gKGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBpLCBqLCB0LCB0YWJsZSA9IFtdOyAvLyBVaW50MzJBcnJheSBpcyBhY3R1YWxseSBzbG93ZXIgdGhhbiBbXVxcblxcdFxcdGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xcblxcdFxcdFxcdHQgPSBpO1xcblxcdFxcdFxcdGZvciAoaiA9IDA7IGogPCA4OyBqKyspXFxuXFx0XFx0XFx0XFx0aWYgKHQgJiAxKVxcblxcdFxcdFxcdFxcdFxcdHQgPSAodCA+Pj4gMSkgXiAweEVEQjg4MzIwO1xcblxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHR0ID0gdCA+Pj4gMTtcXG5cXHRcXHRcXHR0YWJsZVtpXSA9IHQ7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0YWJsZTtcXG5cXHR9KSgpO1xcblxcblxcdC8vIFxcXCJuby1vcFxcXCIgY29kZWNcXG5cXHRmdW5jdGlvbiBOT09QKCkge31cXG5cXHRnbG9iYWwuTk9PUCA9IE5PT1A7XFxuXFx0Tk9PUC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGJ5dGVzLCBvbnByb2dyZXNzKSB7XFxuXFx0XFx0cmV0dXJuIGJ5dGVzO1xcblxcdH07XFxuXFx0Tk9PUC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHt9O1xcbn0pKHRoaXMpO1xcblwiKTtcbnppcC53b3JrZXJTY3JpcHRzID0ge1xuICBkZWZsYXRlcjogW3pXb3JrZXIsIGNyZWF0ZVVybChcIi8qXFxuIENvcHlyaWdodCAoYykgMjAxMyBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG5cXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcblxcbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IFxcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcbiAqL1xcblxcbi8qXFxuICogVGhpcyBwcm9ncmFtIGlzIGJhc2VkIG9uIEpabGliIDEuMC4yIHltbmssIEpDcmFmdCxJbmMuXFxuICogSlpsaWIgaXMgYmFzZWQgb24gemxpYi0xLjEuMywgc28gYWxsIGNyZWRpdCBzaG91bGQgZ28gYXV0aG9yc1xcbiAqIEplYW4tbG91cCBHYWlsbHkoamxvdXBAZ3ppcC5vcmcpIGFuZCBNYXJrIEFkbGVyKG1hZGxlckBhbHVtbmkuY2FsdGVjaC5lZHUpXFxuICogYW5kIGNvbnRyaWJ1dG9ycyBvZiB6bGliLlxcbiAqL1xcblxcbihmdW5jdGlvbihnbG9iYWwpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0Ly8gR2xvYmFsXFxuXFxuXFx0dmFyIE1BWF9CSVRTID0gMTU7XFxuXFx0dmFyIERfQ09ERVMgPSAzMDtcXG5cXHR2YXIgQkxfQ09ERVMgPSAxOTtcXG5cXG5cXHR2YXIgTEVOR1RIX0NPREVTID0gMjk7XFxuXFx0dmFyIExJVEVSQUxTID0gMjU2O1xcblxcdHZhciBMX0NPREVTID0gKExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUyk7XFxuXFx0dmFyIEhFQVBfU0laRSA9ICgyICogTF9DT0RFUyArIDEpO1xcblxcblxcdHZhciBFTkRfQkxPQ0sgPSAyNTY7XFxuXFxuXFx0Ly8gQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0c1xcblxcdHZhciBNQVhfQkxfQklUUyA9IDc7XFxuXFxuXFx0Ly8gcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KVxcblxcdHZhciBSRVBfM182ID0gMTY7XFxuXFxuXFx0Ly8gcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudClcXG5cXHR2YXIgUkVQWl8zXzEwID0gMTc7XFxuXFxuXFx0Ly8gcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KVxcblxcdHZhciBSRVBaXzExXzEzOCA9IDE4O1xcblxcblxcdC8vIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcXG5cXHQvLyBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0XFxuXFx0Ly8gbGVuZ3RoIGNvZGVzLlxcblxcblxcdHZhciBCdWZfc2l6ZSA9IDggKiAyO1xcblxcblxcdC8vIEpabGliIHZlcnNpb24gOiBcXFwiMS4wLjJcXFwiXFxuXFx0dmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xcblxcblxcdC8vIGNvbXByZXNzaW9uIHN0cmF0ZWd5XFxuXFx0dmFyIFpfRklMVEVSRUQgPSAxO1xcblxcdHZhciBaX0hVRkZNQU5fT05MWSA9IDI7XFxuXFx0dmFyIFpfREVGQVVMVF9TVFJBVEVHWSA9IDA7XFxuXFxuXFx0dmFyIFpfTk9fRkxVU0ggPSAwO1xcblxcdHZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xcblxcdHZhciBaX0ZVTExfRkxVU0ggPSAzO1xcblxcdHZhciBaX0ZJTklTSCA9IDQ7XFxuXFxuXFx0dmFyIFpfT0sgPSAwO1xcblxcdHZhciBaX1NUUkVBTV9FTkQgPSAxO1xcblxcdHZhciBaX05FRURfRElDVCA9IDI7XFxuXFx0dmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7XFxuXFx0dmFyIFpfREFUQV9FUlJPUiA9IC0zO1xcblxcdHZhciBaX0JVRl9FUlJPUiA9IC01O1xcblxcblxcdC8vIFRyZWVcXG5cXG5cXHQvLyBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3dcXG5cXHR2YXIgX2Rpc3RfY29kZSA9IFsgMCwgMSwgMiwgMywgNCwgNCwgNSwgNSwgNiwgNiwgNiwgNiwgNywgNywgNywgNywgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsXFxuXFx0XFx0XFx0MTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsXFxuXFx0XFx0XFx0MTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsXFxuXFx0XFx0XFx0MTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsXFxuXFx0XFx0XFx0MTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsXFxuXFx0XFx0XFx0MTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsXFxuXFx0XFx0XFx0MTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAwLCAwLCAxNiwgMTcsIDE4LCAxOCwgMTksIDE5LFxcblxcdFxcdFxcdDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcblxcdFxcdFxcdDI0LCAyNCwgMjQsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LFxcblxcdFxcdFxcdDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LFxcblxcdFxcdFxcdDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LFxcblxcdFxcdFxcdDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI5LFxcblxcdFxcdFxcdDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LFxcblxcdFxcdFxcdDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSBdO1xcblxcblxcdGZ1bmN0aW9uIFRyZWUoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdC8vIGR5bl90cmVlOyAvLyB0aGUgZHluYW1pYyB0cmVlXFxuXFx0XFx0Ly8gbWF4X2NvZGU7IC8vIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeVxcblxcdFxcdC8vIHN0YXRfZGVzYzsgLy8gdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWVcXG5cXG5cXHRcXHQvLyBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0XFxuXFx0XFx0Ly8gbGVuZ3RoXFxuXFx0XFx0Ly8gZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxcblxcdFxcdC8vIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXFxuXFx0XFx0Ly8gYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cXG5cXHRcXHQvLyBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXFxuXFx0XFx0Ly8gYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXFxuXFx0XFx0Ly8gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXFxuXFx0XFx0Ly8gbm90IG51bGwuXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuX2JpdGxlbihzKSB7XFxuXFx0XFx0XFx0dmFyIHRyZWUgPSB0aGF0LmR5bl90cmVlO1xcblxcdFxcdFxcdHZhciBzdHJlZSA9IHRoYXQuc3RhdF9kZXNjLnN0YXRpY190cmVlO1xcblxcdFxcdFxcdHZhciBleHRyYSA9IHRoYXQuc3RhdF9kZXNjLmV4dHJhX2JpdHM7XFxuXFx0XFx0XFx0dmFyIGJhc2UgPSB0aGF0LnN0YXRfZGVzYy5leHRyYV9iYXNlO1xcblxcdFxcdFxcdHZhciBtYXhfbGVuZ3RoID0gdGhhdC5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcXG5cXHRcXHRcXHR2YXIgaDsgLy8gaGVhcCBpbmRleFxcblxcdFxcdFxcdHZhciBuLCBtOyAvLyBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHNcXG5cXHRcXHRcXHR2YXIgYml0czsgLy8gYml0IGxlbmd0aFxcblxcdFxcdFxcdHZhciB4Yml0czsgLy8gZXh0cmEgYml0c1xcblxcdFxcdFxcdHZhciBmOyAvLyBmcmVxdWVuY3lcXG5cXHRcXHRcXHR2YXIgb3ZlcmZsb3cgPSAwOyAvLyBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZVxcblxcblxcdFxcdFxcdGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKylcXG5cXHRcXHRcXHRcXHRzLmJsX2NvdW50W2JpdHNdID0gMDtcXG5cXG5cXHRcXHRcXHQvLyBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxcblxcdFxcdFxcdC8vIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxcblxcdFxcdFxcdHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsgLy8gcm9vdCBvZiB0aGUgaGVhcFxcblxcblxcdFxcdFxcdGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcXG5cXHRcXHRcXHRcXHRuID0gcy5oZWFwW2hdO1xcblxcdFxcdFxcdFxcdGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXSAqIDIgKyAxXSArIDE7XFxuXFx0XFx0XFx0XFx0aWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Yml0cyA9IG1heF9sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0b3ZlcmZsb3crKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dHJlZVtuICogMiArIDFdID0gYml0cztcXG5cXHRcXHRcXHRcXHQvLyBXZSBvdmVyd3JpdGUgdHJlZVtuKjIrMV0gd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZFxcblxcblxcdFxcdFxcdFxcdGlmIChuID4gdGhhdC5tYXhfY29kZSlcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTsgLy8gbm90IGEgbGVhZiBub2RlXFxuXFxuXFx0XFx0XFx0XFx0cy5ibF9jb3VudFtiaXRzXSsrO1xcblxcdFxcdFxcdFxcdHhiaXRzID0gMDtcXG5cXHRcXHRcXHRcXHRpZiAobiA+PSBiYXNlKVxcblxcdFxcdFxcdFxcdFxcdHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xcblxcdFxcdFxcdFxcdGYgPSB0cmVlW24gKiAyXTtcXG5cXHRcXHRcXHRcXHRzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xcblxcdFxcdFxcdFxcdGlmIChzdHJlZSlcXG5cXHRcXHRcXHRcXHRcXHRzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdICsgeGJpdHMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob3ZlcmZsb3cgPT09IDApXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdC8vIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzXFxuXFx0XFx0XFx0Ly8gRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTpcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0Yml0cyA9IG1heF9sZW5ndGggLSAxO1xcblxcdFxcdFxcdFxcdHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdGJpdHMtLTtcXG5cXHRcXHRcXHRcXHRzLmJsX2NvdW50W2JpdHNdLS07IC8vIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZVxcblxcdFxcdFxcdFxcdHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8vIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXJcXG5cXHRcXHRcXHRcXHRzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XFxuXFx0XFx0XFx0XFx0Ly8gVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcXG5cXHRcXHRcXHRcXHQvLyBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cXG5cXHRcXHRcXHRcXHRvdmVyZmxvdyAtPSAyO1xcblxcdFxcdFxcdH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XFxuXFxuXFx0XFx0XFx0Zm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XFxuXFx0XFx0XFx0XFx0biA9IHMuYmxfY291bnRbYml0c107XFxuXFx0XFx0XFx0XFx0d2hpbGUgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRtID0gcy5oZWFwWy0taF07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG0gPiB0aGF0Lm1heF9jb2RlKVxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0cmVlW20gKiAyICsgMV0gIT0gYml0cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXSkgKiB0cmVlW20gKiAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cmVlW20gKiAyICsgMV0gPSBiaXRzO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYVxcblxcdFxcdC8vIGZhc3RlclxcblxcdFxcdC8vIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XFxuXFx0XFx0ZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCAvLyB0aGUgdmFsdWUgdG8gaW52ZXJ0XFxuXFx0XFx0bGVuIC8vIGl0cyBiaXQgbGVuZ3RoXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIHJlcyA9IDA7XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdHJlcyB8PSBjb2RlICYgMTtcXG5cXHRcXHRcXHRcXHRjb2RlID4+Pj0gMTtcXG5cXHRcXHRcXHRcXHRyZXMgPDw9IDE7XFxuXFx0XFx0XFx0fSB3aGlsZSAoLS1sZW4gPiAwKTtcXG5cXHRcXHRcXHRyZXR1cm4gcmVzID4+PiAxO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcXG5cXHRcXHQvLyBvcHRpbWFsKS5cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxcblxcdFxcdC8vIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXFxuXFx0XFx0Ly8gT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cXG5cXHRcXHQvLyB6ZXJvIGNvZGUgbGVuZ3RoLlxcblxcdFxcdGZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCAvLyB0aGUgdHJlZSB0byBkZWNvcmF0ZVxcblxcdFxcdG1heF9jb2RlLCAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcXG5cXHRcXHRibF9jb3VudCAvLyBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIG5leHRfY29kZSA9IFtdOyAvLyBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2hcXG5cXHRcXHRcXHQvLyBiaXQgbGVuZ3RoXFxuXFx0XFx0XFx0dmFyIGNvZGUgPSAwOyAvLyBydW5uaW5nIGNvZGUgdmFsdWVcXG5cXHRcXHRcXHR2YXIgYml0czsgLy8gYml0IGluZGV4XFxuXFx0XFx0XFx0dmFyIG47IC8vIGNvZGUgaW5kZXhcXG5cXHRcXHRcXHR2YXIgbGVuO1xcblxcblxcdFxcdFxcdC8vIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xcblxcdFxcdFxcdC8vIHdpdGhvdXQgYml0IHJldmVyc2FsLlxcblxcdFxcdFxcdGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xcblxcdFxcdFxcdFxcdG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDEpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXFxuXFx0XFx0XFx0Ly8gbXVzdCBiZSBhbGwgb25lcy5cXG5cXHRcXHRcXHQvLyBBc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXFxuXFx0XFx0XFx0Ly8gXFxcImluY29uc2lzdGVudCBiaXQgY291bnRzXFxcIik7XFxuXFx0XFx0XFx0Ly8gVHJhY2V2KChzdGRlcnIsXFxcIlxcXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcXFwiLCBtYXhfY29kZSkpO1xcblxcblxcdFxcdFxcdGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xcblxcdFxcdFxcdFxcdGxlbiA9IHRyZWVbbiAqIDIgKyAxXTtcXG5cXHRcXHRcXHRcXHRpZiAobGVuID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdC8vIE5vdyByZXZlcnNlIHRoZSBiaXRzXFxuXFx0XFx0XFx0XFx0dHJlZVtuICogMl0gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cXG5cXHRcXHQvLyBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxcblxcdFxcdC8vIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cXG5cXHRcXHQvLyBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXFxuXFx0XFx0Ly8gYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcXG5cXHRcXHQvLyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXFxuXFx0XFx0dGhhdC5idWlsZF90cmVlID0gZnVuY3Rpb24ocykge1xcblxcdFxcdFxcdHZhciB0cmVlID0gdGhhdC5keW5fdHJlZTtcXG5cXHRcXHRcXHR2YXIgc3RyZWUgPSB0aGF0LnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcXG5cXHRcXHRcXHR2YXIgZWxlbXMgPSB0aGF0LnN0YXRfZGVzYy5lbGVtcztcXG5cXHRcXHRcXHR2YXIgbiwgbTsgLy8gaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHNcXG5cXHRcXHRcXHR2YXIgbWF4X2NvZGUgPSAtMTsgLy8gbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5XFxuXFx0XFx0XFx0dmFyIG5vZGU7IC8vIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWRcXG5cXG5cXHRcXHRcXHQvLyBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXFxuXFx0XFx0XFx0Ly8gaGVhcFsxXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cXG5cXHRcXHRcXHQvLyBoZWFwWzBdIGlzIG5vdCB1c2VkLlxcblxcdFxcdFxcdHMuaGVhcF9sZW4gPSAwO1xcblxcdFxcdFxcdHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XFxuXFxuXFx0XFx0XFx0Zm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAodHJlZVtuICogMl0gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRzLmRlcHRoW25dID0gMDtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRyZWVbbiAqIDIgKyAxXSA9IDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxcblxcdFxcdFxcdC8vIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxcblxcdFxcdFxcdC8vIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XFxuXFx0XFx0XFx0Ly8gdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cXG5cXHRcXHRcXHR3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcXG5cXHRcXHRcXHRcXHRub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMDtcXG5cXHRcXHRcXHRcXHR0cmVlW25vZGUgKiAyXSA9IDE7XFxuXFx0XFx0XFx0XFx0cy5kZXB0aFtub2RlXSA9IDA7XFxuXFx0XFx0XFx0XFx0cy5vcHRfbGVuLS07XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmVlKVxcblxcdFxcdFxcdFxcdFxcdHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdO1xcblxcdFxcdFxcdFxcdC8vIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0c1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGF0Lm1heF9jb2RlID0gbWF4X2NvZGU7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxcblxcdFxcdFxcdC8vIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxcblxcblxcdFxcdFxcdGZvciAobiA9IE1hdGguZmxvb3Iocy5oZWFwX2xlbiAvIDIpOyBuID49IDE7IG4tLSlcXG5cXHRcXHRcXHRcXHRzLnBxZG93bmhlYXAodHJlZSwgbik7XFxuXFxuXFx0XFx0XFx0Ly8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xcblxcdFxcdFxcdC8vIGZyZXF1ZW50IG5vZGVzLlxcblxcblxcdFxcdFxcdG5vZGUgPSBlbGVtczsgLy8gbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlXFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdC8vIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeVxcblxcdFxcdFxcdFxcdG4gPSBzLmhlYXBbMV07XFxuXFx0XFx0XFx0XFx0cy5oZWFwWzFdID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XFxuXFx0XFx0XFx0XFx0cy5wcWRvd25oZWFwKHRyZWUsIDEpO1xcblxcdFxcdFxcdFxcdG0gPSBzLmhlYXBbMV07IC8vIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5XFxuXFxuXFx0XFx0XFx0XFx0cy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvLyBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5XFxuXFx0XFx0XFx0XFx0cy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xcblxcblxcdFxcdFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtXFxuXFx0XFx0XFx0XFx0dHJlZVtub2RlICogMl0gPSAodHJlZVtuICogMl0gKyB0cmVlW20gKiAyXSk7XFxuXFx0XFx0XFx0XFx0cy5kZXB0aFtub2RlXSA9IE1hdGgubWF4KHMuZGVwdGhbbl0sIHMuZGVwdGhbbV0pICsgMTtcXG5cXHRcXHRcXHRcXHR0cmVlW24gKiAyICsgMV0gPSB0cmVlW20gKiAyICsgMV0gPSBub2RlO1xcblxcblxcdFxcdFxcdFxcdC8vIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwXFxuXFx0XFx0XFx0XFx0cy5oZWFwWzFdID0gbm9kZSsrO1xcblxcdFxcdFxcdFxcdHMucHFkb3duaGVhcCh0cmVlLCAxKTtcXG5cXHRcXHRcXHR9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xcblxcblxcdFxcdFxcdHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzFdO1xcblxcblxcdFxcdFxcdC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXFxuXFxuXFx0XFx0XFx0Z2VuX2JpdGxlbihzKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzXFxuXFx0XFx0XFx0Z2VuX2NvZGVzKHRyZWUsIHRoYXQubWF4X2NvZGUsIHMuYmxfY291bnQpO1xcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdFRyZWUuX2xlbmd0aF9jb2RlID0gWyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LFxcblxcdFxcdFxcdDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLFxcblxcdFxcdFxcdDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxcblxcdFxcdFxcdDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcblxcdFxcdFxcdDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LFxcblxcdFxcdFxcdDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LFxcblxcdFxcdFxcdDI2LCAyNiwgMjYsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyOCBdO1xcblxcblxcdFRyZWUuYmFzZV9sZW5ndGggPSBbIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDEwLCAxMiwgMTQsIDE2LCAyMCwgMjQsIDI4LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDAgXTtcXG5cXG5cXHRUcmVlLmJhc2VfZGlzdCA9IFsgMCwgMSwgMiwgMywgNCwgNiwgOCwgMTIsIDE2LCAyNCwgMzIsIDQ4LCA2NCwgOTYsIDEyOCwgMTkyLCAyNTYsIDM4NCwgNTEyLCA3NjgsIDEwMjQsIDE1MzYsIDIwNDgsIDMwNzIsIDQwOTYsIDYxNDQsIDgxOTIsIDEyMjg4LCAxNjM4NCxcXG5cXHRcXHRcXHQyNDU3NiBdO1xcblxcblxcdC8vIE1hcHBpbmcgZnJvbSBhIGRpc3RhbmNlIHRvIGEgZGlzdGFuY2UgY29kZS4gZGlzdCBpcyB0aGUgZGlzdGFuY2UgLSAxIGFuZFxcblxcdC8vIG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLiBfZGlzdF9jb2RlWzI1Nl0gYW5kIF9kaXN0X2NvZGVbMjU3XSBhcmUgbmV2ZXJcXG5cXHQvLyB1c2VkLlxcblxcdFRyZWUuZF9jb2RlID0gZnVuY3Rpb24oZGlzdCkge1xcblxcdFxcdHJldHVybiAoKGRpc3QpIDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKChkaXN0KSA+Pj4gNyldKTtcXG5cXHR9O1xcblxcblxcdC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGVcXG5cXHRUcmVlLmV4dHJhX2xiaXRzID0gWyAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwIF07XFxuXFxuXFx0Ly8gZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlXFxuXFx0VHJlZS5leHRyYV9kYml0cyA9IFsgMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzIF07XFxuXFxuXFx0Ly8gZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGVcXG5cXHRUcmVlLmV4dHJhX2JsYml0cyA9IFsgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgNyBdO1xcblxcblxcdFRyZWUuYmxfb3JkZXIgPSBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcXG5cXG5cXHQvLyBTdGF0aWNUcmVlXFxuXFxuXFx0ZnVuY3Rpb24gU3RhdGljVHJlZShzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcXG5cXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0dGhhdC5zdGF0aWNfdHJlZSA9IHN0YXRpY190cmVlO1xcblxcdFxcdHRoYXQuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7XFxuXFx0XFx0dGhhdC5leHRyYV9iYXNlID0gZXh0cmFfYmFzZTtcXG5cXHRcXHR0aGF0LmVsZW1zID0gZWxlbXM7XFxuXFx0XFx0dGhhdC5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDtcXG5cXHR9XFxuXFxuXFx0U3RhdGljVHJlZS5zdGF0aWNfbHRyZWUgPSBbIDEyLCA4LCAxNDAsIDgsIDc2LCA4LCAyMDQsIDgsIDQ0LCA4LCAxNzIsIDgsIDEwOCwgOCwgMjM2LCA4LCAyOCwgOCwgMTU2LCA4LCA5MiwgOCwgMjIwLCA4LCA2MCwgOCwgMTg4LCA4LCAxMjQsIDgsIDI1MiwgOCwgMiwgOCxcXG5cXHRcXHRcXHQxMzAsIDgsIDY2LCA4LCAxOTQsIDgsIDM0LCA4LCAxNjIsIDgsIDk4LCA4LCAyMjYsIDgsIDE4LCA4LCAxNDYsIDgsIDgyLCA4LCAyMTAsIDgsIDUwLCA4LCAxNzgsIDgsIDExNCwgOCwgMjQyLCA4LCAxMCwgOCwgMTM4LCA4LCA3NCwgOCwgMjAyLCA4LCA0MixcXG5cXHRcXHRcXHQ4LCAxNzAsIDgsIDEwNiwgOCwgMjM0LCA4LCAyNiwgOCwgMTU0LCA4LCA5MCwgOCwgMjE4LCA4LCA1OCwgOCwgMTg2LCA4LCAxMjIsIDgsIDI1MCwgOCwgNiwgOCwgMTM0LCA4LCA3MCwgOCwgMTk4LCA4LCAzOCwgOCwgMTY2LCA4LCAxMDIsIDgsIDIzMCwgOCxcXG5cXHRcXHRcXHQyMiwgOCwgMTUwLCA4LCA4NiwgOCwgMjE0LCA4LCA1NCwgOCwgMTgyLCA4LCAxMTgsIDgsIDI0NiwgOCwgMTQsIDgsIDE0MiwgOCwgNzgsIDgsIDIwNiwgOCwgNDYsIDgsIDE3NCwgOCwgMTEwLCA4LCAyMzgsIDgsIDMwLCA4LCAxNTgsIDgsIDk0LCA4LFxcblxcdFxcdFxcdDIyMiwgOCwgNjIsIDgsIDE5MCwgOCwgMTI2LCA4LCAyNTQsIDgsIDEsIDgsIDEyOSwgOCwgNjUsIDgsIDE5MywgOCwgMzMsIDgsIDE2MSwgOCwgOTcsIDgsIDIyNSwgOCwgMTcsIDgsIDE0NSwgOCwgODEsIDgsIDIwOSwgOCwgNDksIDgsIDE3NywgOCwgMTEzLFxcblxcdFxcdFxcdDgsIDI0MSwgOCwgOSwgOCwgMTM3LCA4LCA3MywgOCwgMjAxLCA4LCA0MSwgOCwgMTY5LCA4LCAxMDUsIDgsIDIzMywgOCwgMjUsIDgsIDE1MywgOCwgODksIDgsIDIxNywgOCwgNTcsIDgsIDE4NSwgOCwgMTIxLCA4LCAyNDksIDgsIDUsIDgsIDEzMywgOCxcXG5cXHRcXHRcXHQ2OSwgOCwgMTk3LCA4LCAzNywgOCwgMTY1LCA4LCAxMDEsIDgsIDIyOSwgOCwgMjEsIDgsIDE0OSwgOCwgODUsIDgsIDIxMywgOCwgNTMsIDgsIDE4MSwgOCwgMTE3LCA4LCAyNDUsIDgsIDEzLCA4LCAxNDEsIDgsIDc3LCA4LCAyMDUsIDgsIDQ1LCA4LFxcblxcdFxcdFxcdDE3MywgOCwgMTA5LCA4LCAyMzcsIDgsIDI5LCA4LCAxNTcsIDgsIDkzLCA4LCAyMjEsIDgsIDYxLCA4LCAxODksIDgsIDEyNSwgOCwgMjUzLCA4LCAxOSwgOSwgMjc1LCA5LCAxNDcsIDksIDQwMywgOSwgODMsIDksIDMzOSwgOSwgMjExLCA5LCA0NjcsIDksXFxuXFx0XFx0XFx0NTEsIDksIDMwNywgOSwgMTc5LCA5LCA0MzUsIDksIDExNSwgOSwgMzcxLCA5LCAyNDMsIDksIDQ5OSwgOSwgMTEsIDksIDI2NywgOSwgMTM5LCA5LCAzOTUsIDksIDc1LCA5LCAzMzEsIDksIDIwMywgOSwgNDU5LCA5LCA0MywgOSwgMjk5LCA5LCAxNzEsIDksXFxuXFx0XFx0XFx0NDI3LCA5LCAxMDcsIDksIDM2MywgOSwgMjM1LCA5LCA0OTEsIDksIDI3LCA5LCAyODMsIDksIDE1NSwgOSwgNDExLCA5LCA5MSwgOSwgMzQ3LCA5LCAyMTksIDksIDQ3NSwgOSwgNTksIDksIDMxNSwgOSwgMTg3LCA5LCA0NDMsIDksIDEyMywgOSwgMzc5LFxcblxcdFxcdFxcdDksIDI1MSwgOSwgNTA3LCA5LCA3LCA5LCAyNjMsIDksIDEzNSwgOSwgMzkxLCA5LCA3MSwgOSwgMzI3LCA5LCAxOTksIDksIDQ1NSwgOSwgMzksIDksIDI5NSwgOSwgMTY3LCA5LCA0MjMsIDksIDEwMywgOSwgMzU5LCA5LCAyMzEsIDksIDQ4NywgOSwgMjMsXFxuXFx0XFx0XFx0OSwgMjc5LCA5LCAxNTEsIDksIDQwNywgOSwgODcsIDksIDM0MywgOSwgMjE1LCA5LCA0NzEsIDksIDU1LCA5LCAzMTEsIDksIDE4MywgOSwgNDM5LCA5LCAxMTksIDksIDM3NSwgOSwgMjQ3LCA5LCA1MDMsIDksIDE1LCA5LCAyNzEsIDksIDE0MywgOSxcXG5cXHRcXHRcXHQzOTksIDksIDc5LCA5LCAzMzUsIDksIDIwNywgOSwgNDYzLCA5LCA0NywgOSwgMzAzLCA5LCAxNzUsIDksIDQzMSwgOSwgMTExLCA5LCAzNjcsIDksIDIzOSwgOSwgNDk1LCA5LCAzMSwgOSwgMjg3LCA5LCAxNTksIDksIDQxNSwgOSwgOTUsIDksIDM1MSwgOSxcXG5cXHRcXHRcXHQyMjMsIDksIDQ3OSwgOSwgNjMsIDksIDMxOSwgOSwgMTkxLCA5LCA0NDcsIDksIDEyNywgOSwgMzgzLCA5LCAyNTUsIDksIDUxMSwgOSwgMCwgNywgNjQsIDcsIDMyLCA3LCA5NiwgNywgMTYsIDcsIDgwLCA3LCA0OCwgNywgMTEyLCA3LCA4LCA3LCA3MiwgNyxcXG5cXHRcXHRcXHQ0MCwgNywgMTA0LCA3LCAyNCwgNywgODgsIDcsIDU2LCA3LCAxMjAsIDcsIDQsIDcsIDY4LCA3LCAzNiwgNywgMTAwLCA3LCAyMCwgNywgODQsIDcsIDUyLCA3LCAxMTYsIDcsIDMsIDgsIDEzMSwgOCwgNjcsIDgsIDE5NSwgOCwgMzUsIDgsIDE2MywgOCxcXG5cXHRcXHRcXHQ5OSwgOCwgMjI3LCA4IF07XFxuXFxuXFx0U3RhdGljVHJlZS5zdGF0aWNfZHRyZWUgPSBbIDAsIDUsIDE2LCA1LCA4LCA1LCAyNCwgNSwgNCwgNSwgMjAsIDUsIDEyLCA1LCAyOCwgNSwgMiwgNSwgMTgsIDUsIDEwLCA1LCAyNiwgNSwgNiwgNSwgMjIsIDUsIDE0LCA1LCAzMCwgNSwgMSwgNSwgMTcsIDUsIDksIDUsXFxuXFx0XFx0XFx0MjUsIDUsIDUsIDUsIDIxLCA1LCAxMywgNSwgMjksIDUsIDMsIDUsIDE5LCA1LCAxMSwgNSwgMjcsIDUsIDcsIDUsIDIzLCA1IF07XFxuXFxuXFx0U3RhdGljVHJlZS5zdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWUoU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUsIFRyZWUuZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlLCBUcmVlLmV4dHJhX2RiaXRzLCAwLCBEX0NPREVTLCBNQVhfQklUUyk7XFxuXFxuXFx0U3RhdGljVHJlZS5zdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKG51bGwsIFRyZWUuZXh0cmFfYmxiaXRzLCAwLCBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xcblxcblxcdC8vIERlZmxhdGVcXG5cXG5cXHR2YXIgTUFYX01FTV9MRVZFTCA9IDk7XFxuXFx0dmFyIERFRl9NRU1fTEVWRUwgPSA4O1xcblxcblxcdGZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcXG5cXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0dGhhdC5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xcblxcdFxcdHRoYXQubWF4X2xhenkgPSBtYXhfbGF6eTtcXG5cXHRcXHR0aGF0Lm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XFxuXFx0XFx0dGhhdC5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XFxuXFx0XFx0dGhhdC5mdW5jID0gZnVuYztcXG5cXHR9XFxuXFxuXFx0dmFyIFNUT1JFRCA9IDA7XFxuXFx0dmFyIEZBU1QgPSAxO1xcblxcdHZhciBTTE9XID0gMjtcXG5cXHR2YXIgY29uZmlnX3RhYmxlID0gWyBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIFNUT1JFRCksIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgRkFTVCksIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIEZBU1QpLCBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgRkFTVCksXFxuXFx0XFx0XFx0bmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgU0xPVyksIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBTTE9XKSxcXG5cXHRcXHRcXHRuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgU0xPVyksIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBTTE9XKSBdO1xcblxcblxcdHZhciB6X2Vycm1zZyA9IFsgXFxcIm5lZWQgZGljdGlvbmFyeVxcXCIsIC8vIFpfTkVFRF9ESUNUXFxuXFx0Ly8gMlxcblxcdFxcXCJzdHJlYW0gZW5kXFxcIiwgLy8gWl9TVFJFQU1fRU5EIDFcXG5cXHRcXFwiXFxcIiwgLy8gWl9PSyAwXFxuXFx0XFxcIlxcXCIsIC8vIFpfRVJSTk8gKC0xKVxcblxcdFxcXCJzdHJlYW0gZXJyb3JcXFwiLCAvLyBaX1NUUkVBTV9FUlJPUiAoLTIpXFxuXFx0XFxcImRhdGEgZXJyb3JcXFwiLCAvLyBaX0RBVEFfRVJST1IgKC0zKVxcblxcdFxcXCJcXFwiLCAvLyBaX01FTV9FUlJPUiAoLTQpXFxuXFx0XFxcImJ1ZmZlciBlcnJvclxcXCIsIC8vIFpfQlVGX0VSUk9SICgtNSlcXG5cXHRcXFwiXFxcIiwvLyBaX1ZFUlNJT05fRVJST1IgKC02KVxcblxcdFxcXCJcXFwiIF07XFxuXFxuXFx0Ly8gYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0XFxuXFx0dmFyIE5lZWRNb3JlID0gMDtcXG5cXG5cXHQvLyBibG9jayBmbHVzaCBwZXJmb3JtZWRcXG5cXHR2YXIgQmxvY2tEb25lID0gMTtcXG5cXG5cXHQvLyBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZVxcblxcdHZhciBGaW5pc2hTdGFydGVkID0gMjtcXG5cXG5cXHQvLyBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0XFxuXFx0dmFyIEZpbmlzaERvbmUgPSAzO1xcblxcblxcdC8vIHByZXNldCBkaWN0aW9uYXJ5IGZsYWcgaW4gemxpYiBoZWFkZXJcXG5cXHR2YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xcblxcblxcdHZhciBJTklUX1NUQVRFID0gNDI7XFxuXFx0dmFyIEJVU1lfU1RBVEUgPSAxMTM7XFxuXFx0dmFyIEZJTklTSF9TVEFURSA9IDY2NjtcXG5cXG5cXHQvLyBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2RcXG5cXHR2YXIgWl9ERUZMQVRFRCA9IDg7XFxuXFxuXFx0dmFyIFNUT1JFRF9CTE9DSyA9IDA7XFxuXFx0dmFyIFNUQVRJQ19UUkVFUyA9IDE7XFxuXFx0dmFyIERZTl9UUkVFUyA9IDI7XFxuXFxuXFx0dmFyIE1JTl9NQVRDSCA9IDM7XFxuXFx0dmFyIE1BWF9NQVRDSCA9IDI1ODtcXG5cXHR2YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcXG5cXG5cXHRmdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XFxuXFx0XFx0dmFyIHRuMiA9IHRyZWVbbiAqIDJdO1xcblxcdFxcdHZhciB0bTIgPSB0cmVlW20gKiAyXTtcXG5cXHRcXHRyZXR1cm4gKHRuMiA8IHRtMiB8fCAodG4yID09IHRtMiAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBEZWZsYXRlKCkge1xcblxcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHR2YXIgc3RybTsgLy8gcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW1cXG5cXHRcXHR2YXIgc3RhdHVzOyAvLyBhcyB0aGUgbmFtZSBpbXBsaWVzXFxuXFx0XFx0Ly8gcGVuZGluZ19idWY7IC8vIG91dHB1dCBzdGlsbCBwZW5kaW5nXFxuXFx0XFx0dmFyIHBlbmRpbmdfYnVmX3NpemU7IC8vIHNpemUgb2YgcGVuZGluZ19idWZcXG5cXHRcXHQvLyBwZW5kaW5nX291dDsgLy8gbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW1cXG5cXHRcXHQvLyBwZW5kaW5nOyAvLyBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXJcXG5cXHRcXHR2YXIgbWV0aG9kOyAvLyBTVE9SRUQgKGZvciB6aXAgb25seSkgb3IgREVGTEFURURcXG5cXHRcXHR2YXIgbGFzdF9mbHVzaDsgLy8gdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbFxcblxcblxcdFxcdHZhciB3X3NpemU7IC8vIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KVxcblxcdFxcdHZhciB3X2JpdHM7IC8vIGxvZzIod19zaXplKSAoOC4uMTYpXFxuXFx0XFx0dmFyIHdfbWFzazsgLy8gd19zaXplIC0gMVxcblxcblxcdFxcdHZhciB3aW5kb3c7XFxuXFx0XFx0Ly8gU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXFxuXFx0XFx0Ly8gYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcXG5cXHRcXHQvLyBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXFxuXFx0XFx0Ly8gd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXFxuXFx0XFx0Ly8gcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuIEFsc28sIGl0IGxpbWl0c1xcblxcdFxcdC8vIHRoZSB3aW5kb3cgc2l6ZSB0byA2NEssIHdoaWNoIGlzIHF1aXRlIHVzZWZ1bCBvbiBNU0RPUy5cXG5cXHRcXHQvLyBUbyBkbzogdXNlIHRoZSB1c2VyIGlucHV0IGJ1ZmZlciBhcyBzbGlkaW5nIHdpbmRvdy5cXG5cXG5cXHRcXHR2YXIgd2luZG93X3NpemU7XFxuXFx0XFx0Ly8gQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcXG5cXHRcXHQvLyBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxcblxcblxcdFxcdHZhciBwcmV2O1xcblxcdFxcdC8vIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXFxuXFx0XFx0Ly8gYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cXG5cXHRcXHQvLyBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cXG5cXG5cXHRcXHR2YXIgaGVhZDsgLy8gSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC5cXG5cXG5cXHRcXHR2YXIgaW5zX2g7IC8vIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkXFxuXFx0XFx0dmFyIGhhc2hfc2l6ZTsgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGVcXG5cXHRcXHR2YXIgaGFzaF9iaXRzOyAvLyBsb2cyKGhhc2hfc2l6ZSlcXG5cXHRcXHR2YXIgaGFzaF9tYXNrOyAvLyBoYXNoX3NpemUtMVxcblxcblxcdFxcdC8vIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XFxuXFx0XFx0Ly8gc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XFxuXFx0XFx0Ly8gYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XFxuXFx0XFx0Ly8gaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcXG5cXHRcXHR2YXIgaGFzaF9zaGlmdDtcXG5cXG5cXHRcXHQvLyBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcXG5cXHRcXHQvLyBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxcblxcblxcdFxcdHZhciBibG9ja19zdGFydDtcXG5cXG5cXHRcXHR2YXIgbWF0Y2hfbGVuZ3RoOyAvLyBsZW5ndGggb2YgYmVzdCBtYXRjaFxcblxcdFxcdHZhciBwcmV2X21hdGNoOyAvLyBwcmV2aW91cyBtYXRjaFxcblxcdFxcdHZhciBtYXRjaF9hdmFpbGFibGU7IC8vIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHNcXG5cXHRcXHR2YXIgc3Ryc3RhcnQ7IC8vIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnRcXG5cXHRcXHR2YXIgbWF0Y2hfc3RhcnQ7IC8vIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZ1xcblxcdFxcdHZhciBsb29rYWhlYWQ7IC8vIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3dcXG5cXG5cXHRcXHQvLyBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcXG5cXHRcXHQvLyBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cXG5cXHRcXHR2YXIgcHJldl9sZW5ndGg7XFxuXFxuXFx0XFx0Ly8gVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcXG5cXHRcXHQvLyBsZW5ndGguIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGUgc3BlZWQuXFxuXFx0XFx0dmFyIG1heF9jaGFpbl9sZW5ndGg7XFxuXFxuXFx0XFx0Ly8gQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxcblxcdFxcdC8vIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXFxuXFx0XFx0Ly8gbGV2ZWxzID49IDQuXFxuXFx0XFx0dmFyIG1heF9sYXp5X21hdGNoO1xcblxcblxcdFxcdC8vIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XFxuXFx0XFx0Ly8gZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxcblxcdFxcdC8vIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXFxuXFxuXFx0XFx0dmFyIGxldmVsOyAvLyBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSlcXG5cXHRcXHR2YXIgc3RyYXRlZ3k7IC8vIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nXFxuXFxuXFx0XFx0Ly8gVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzXFxuXFx0XFx0dmFyIGdvb2RfbWF0Y2g7XFxuXFxuXFx0XFx0Ly8gU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpc1xcblxcdFxcdHZhciBuaWNlX21hdGNoO1xcblxcblxcdFxcdHZhciBkeW5fbHRyZWU7IC8vIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlXFxuXFx0XFx0dmFyIGR5bl9kdHJlZTsgLy8gZGlzdGFuY2UgdHJlZVxcblxcdFxcdHZhciBibF90cmVlOyAvLyBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzXFxuXFxuXFx0XFx0dmFyIGxfZGVzYyA9IG5ldyBUcmVlKCk7IC8vIGRlc2MgZm9yIGxpdGVyYWwgdHJlZVxcblxcdFxcdHZhciBkX2Rlc2MgPSBuZXcgVHJlZSgpOyAvLyBkZXNjIGZvciBkaXN0YW5jZSB0cmVlXFxuXFx0XFx0dmFyIGJsX2Rlc2MgPSBuZXcgVHJlZSgpOyAvLyBkZXNjIGZvciBiaXQgbGVuZ3RoIHRyZWVcXG5cXG5cXHRcXHQvLyB0aGF0LmhlYXBfbGVuOyAvLyBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXBcXG5cXHRcXHQvLyB0aGF0LmhlYXBfbWF4OyAvLyBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5XFxuXFx0XFx0Ly8gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cXG5cXHRcXHQvLyBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxcblxcblxcdFxcdC8vIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcXG5cXHRcXHR0aGF0LmRlcHRoID0gW107XFxuXFxuXFx0XFx0dmFyIGxfYnVmOyAvLyBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xcblxcblxcdFxcdC8vIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxcblxcdFxcdC8vIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcXG5cXHRcXHQvLyAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xcblxcdFxcdC8vIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XFxuXFx0XFx0Ly8gZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cXG5cXHRcXHQvLyB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXFxuXFx0XFx0Ly8gYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXFxuXFx0XFx0Ly8gLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxcblxcdFxcdC8vIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cXG5cXHRcXHQvLyBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cXG5cXHRcXHQvLyAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxcblxcdFxcdC8vIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcXG5cXHRcXHQvLyBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcXG5cXHRcXHQvLyBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxcblxcdFxcdC8vIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xcblxcdFxcdC8vIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cXG5cXHRcXHQvLyAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxcblxcdFxcdHZhciBsaXRfYnVmc2l6ZTtcXG5cXG5cXHRcXHR2YXIgbGFzdF9saXQ7IC8vIHJ1bm5pbmcgaW5kZXggaW4gbF9idWZcXG5cXG5cXHRcXHQvLyBCdWZmZXIgZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXFxuXFx0XFx0Ly8gdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcXG5cXHRcXHQvLyBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXFxuXFxuXFx0XFx0dmFyIGRfYnVmOyAvLyBpbmRleCBvZiBwZW5kaWdfYnVmXFxuXFxuXFx0XFx0Ly8gdGhhdC5vcHRfbGVuOyAvLyBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzXFxuXFx0XFx0Ly8gdGhhdC5zdGF0aWNfbGVuOyAvLyBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXNcXG5cXHRcXHR2YXIgbWF0Y2hlczsgLy8gbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2tcXG5cXHRcXHR2YXIgbGFzdF9lb2JfbGVuOyAvLyBiaXQgbGVuZ3RoIG9mIEVPQiBjb2RlIGZvciBsYXN0IGJsb2NrXFxuXFxuXFx0XFx0Ly8gT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcXG5cXHRcXHQvLyBzaWduaWZpY2FudCBiaXRzKS5cXG5cXHRcXHR2YXIgYmlfYnVmO1xcblxcblxcdFxcdC8vIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XFxuXFx0XFx0Ly8gYXJlIGFsd2F5cyB6ZXJvLlxcblxcdFxcdHZhciBiaV92YWxpZDtcXG5cXG5cXHRcXHQvLyBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWVcXG5cXHRcXHR0aGF0LmJsX2NvdW50ID0gW107XFxuXFxuXFx0XFx0Ly8gaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzXFxuXFx0XFx0dGhhdC5oZWFwID0gW107XFxuXFxuXFx0XFx0ZHluX2x0cmVlID0gW107XFxuXFx0XFx0ZHluX2R0cmVlID0gW107XFxuXFx0XFx0YmxfdHJlZSA9IFtdO1xcblxcblxcdFxcdGZ1bmN0aW9uIGxtX2luaXQoKSB7XFxuXFx0XFx0XFx0dmFyIGk7XFxuXFx0XFx0XFx0d2luZG93X3NpemUgPSAyICogd19zaXplO1xcblxcblxcdFxcdFxcdGhlYWRbaGFzaF9zaXplIC0gMV0gPSAwO1xcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBoYXNoX3NpemUgLSAxOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRoZWFkW2ldID0gMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcXG5cXHRcXHRcXHRtYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubWF4X2xhenk7XFxuXFx0XFx0XFx0Z29vZF9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0uZ29vZF9sZW5ndGg7XFxuXFx0XFx0XFx0bmljZV9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubmljZV9sZW5ndGg7XFxuXFx0XFx0XFx0bWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubWF4X2NoYWluO1xcblxcblxcdFxcdFxcdHN0cnN0YXJ0ID0gMDtcXG5cXHRcXHRcXHRibG9ja19zdGFydCA9IDA7XFxuXFx0XFx0XFx0bG9va2FoZWFkID0gMDtcXG5cXHRcXHRcXHRtYXRjaF9sZW5ndGggPSBwcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XFxuXFx0XFx0XFx0bWF0Y2hfYXZhaWxhYmxlID0gMDtcXG5cXHRcXHRcXHRpbnNfaCA9IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGluaXRfYmxvY2soKSB7XFxuXFx0XFx0XFx0dmFyIGk7XFxuXFx0XFx0XFx0Ly8gSW5pdGlhbGl6ZSB0aGUgdHJlZXMuXFxuXFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IExfQ09ERVM7IGkrKylcXG5cXHRcXHRcXHRcXHRkeW5fbHRyZWVbaSAqIDJdID0gMDtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgRF9DT0RFUzsgaSsrKVxcblxcdFxcdFxcdFxcdGR5bl9kdHJlZVtpICogMl0gPSAwO1xcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBCTF9DT0RFUzsgaSsrKVxcblxcdFxcdFxcdFxcdGJsX3RyZWVbaSAqIDJdID0gMDtcXG5cXG5cXHRcXHRcXHRkeW5fbHRyZWVbRU5EX0JMT0NLICogMl0gPSAxO1xcblxcdFxcdFxcdHRoYXQub3B0X2xlbiA9IHRoYXQuc3RhdGljX2xlbiA9IDA7XFxuXFx0XFx0XFx0bGFzdF9saXQgPSBtYXRjaGVzID0gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxcblxcdFxcdGZ1bmN0aW9uIHRyX2luaXQoKSB7XFxuXFxuXFx0XFx0XFx0bF9kZXNjLmR5bl90cmVlID0gZHluX2x0cmVlO1xcblxcdFxcdFxcdGxfZGVzYy5zdGF0X2Rlc2MgPSBTdGF0aWNUcmVlLnN0YXRpY19sX2Rlc2M7XFxuXFxuXFx0XFx0XFx0ZF9kZXNjLmR5bl90cmVlID0gZHluX2R0cmVlO1xcblxcdFxcdFxcdGRfZGVzYy5zdGF0X2Rlc2MgPSBTdGF0aWNUcmVlLnN0YXRpY19kX2Rlc2M7XFxuXFxuXFx0XFx0XFx0YmxfZGVzYy5keW5fdHJlZSA9IGJsX3RyZWU7XFxuXFx0XFx0XFx0YmxfZGVzYy5zdGF0X2Rlc2MgPSBTdGF0aWNUcmVlLnN0YXRpY19ibF9kZXNjO1xcblxcblxcdFxcdFxcdGJpX2J1ZiA9IDA7XFxuXFx0XFx0XFx0YmlfdmFsaWQgPSAwO1xcblxcdFxcdFxcdGxhc3RfZW9iX2xlbiA9IDg7IC8vIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGVcXG5cXG5cXHRcXHRcXHQvLyBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTpcXG5cXHRcXHRcXHRpbml0X2Jsb2NrKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxcblxcdFxcdC8vIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksXFxuXFx0XFx0Ly8gc3RvcHBpbmdcXG5cXHRcXHQvLyB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXFxuXFx0XFx0Ly8gdHdvIHNvbnMpLlxcblxcdFxcdHRoYXQucHFkb3duaGVhcCA9IGZ1bmN0aW9uKHRyZWUsIC8vIHRoZSB0cmVlIHRvIHJlc3RvcmVcXG5cXHRcXHRrIC8vIG5vZGUgdG8gbW92ZSBkb3duXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIGhlYXAgPSB0aGF0LmhlYXA7XFxuXFx0XFx0XFx0dmFyIHYgPSBoZWFwW2tdO1xcblxcdFxcdFxcdHZhciBqID0gayA8PCAxOyAvLyBsZWZ0IHNvbiBvZiBrXFxuXFx0XFx0XFx0d2hpbGUgKGogPD0gdGhhdC5oZWFwX2xlbikge1xcblxcdFxcdFxcdFxcdC8vIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6XFxuXFx0XFx0XFx0XFx0aWYgKGogPCB0aGF0LmhlYXBfbGVuICYmIHNtYWxsZXIodHJlZSwgaGVhcFtqICsgMV0sIGhlYXBbal0sIHRoYXQuZGVwdGgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aisrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29uc1xcblxcdFxcdFxcdFxcdGlmIChzbWFsbGVyKHRyZWUsIHYsIGhlYXBbal0sIHRoYXQuZGVwdGgpKVxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdC8vIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uXFxuXFx0XFx0XFx0XFx0aGVhcFtrXSA9IGhlYXBbal07XFxuXFx0XFx0XFx0XFx0ayA9IGo7XFxuXFx0XFx0XFx0XFx0Ly8gQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2Yga1xcblxcdFxcdFxcdFxcdGogPDw9IDE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGhlYXBba10gPSB2O1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xcblxcdFxcdC8vIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXFxuXFx0XFx0ZnVuY3Rpb24gc2Nhbl90cmVlKHRyZWUsLy8gdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZFxcblxcdFxcdG1heF9jb2RlIC8vIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeVxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciBuOyAvLyBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzXFxuXFx0XFx0XFx0dmFyIHByZXZsZW4gPSAtMTsgLy8gbGFzdCBlbWl0dGVkIGxlbmd0aFxcblxcdFxcdFxcdHZhciBjdXJsZW47IC8vIGxlbmd0aCBvZiBjdXJyZW50IGNvZGVcXG5cXHRcXHRcXHR2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsgLy8gbGVuZ3RoIG9mIG5leHQgY29kZVxcblxcdFxcdFxcdHZhciBjb3VudCA9IDA7IC8vIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIG1heF9jb3VudCA9IDc7IC8vIG1heCByZXBlYXQgY291bnRcXG5cXHRcXHRcXHR2YXIgbWluX2NvdW50ID0gNDsgLy8gbWluIHJlcGVhdCBjb3VudFxcblxcblxcdFxcdFxcdGlmIChuZXh0bGVuID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gMTM4O1xcblxcdFxcdFxcdFxcdG1pbl9jb3VudCA9IDM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0gPSAweGZmZmY7IC8vIGd1YXJkXFxuXFxuXFx0XFx0XFx0Zm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XFxuXFx0XFx0XFx0XFx0Y3VybGVuID0gbmV4dGxlbjtcXG5cXHRcXHRcXHRcXHRuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdO1xcblxcdFxcdFxcdFxcdGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xcblxcdFxcdFxcdFxcdFxcdGJsX3RyZWVbY3VybGVuICogMl0gKz0gY291bnQ7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY3VybGVuICE9IHByZXZsZW4pXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmxfdHJlZVtjdXJsZW4gKiAyXSsrO1xcblxcdFxcdFxcdFxcdFxcdGJsX3RyZWVbUkVQXzNfNiAqIDJdKys7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xcblxcdFxcdFxcdFxcdFxcdGJsX3RyZWVbUkVQWl8zXzEwICogMl0rKztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXSsrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb3VudCA9IDA7XFxuXFx0XFx0XFx0XFx0cHJldmxlbiA9IGN1cmxlbjtcXG5cXHRcXHRcXHRcXHRpZiAobmV4dGxlbiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdG1heF9jb3VudCA9IDEzODtcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY3VybGVuID09IG5leHRsZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSA2O1xcblxcdFxcdFxcdFxcdFxcdG1pbl9jb3VudCA9IDM7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSA3O1xcblxcdFxcdFxcdFxcdFxcdG1pbl9jb3VudCA9IDQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxcblxcdFxcdC8vIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxcblxcdFxcdGZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUoKSB7XFxuXFx0XFx0XFx0dmFyIG1heF9ibGluZGV4OyAvLyBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxXFxuXFxuXFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlc1xcblxcdFxcdFxcdHNjYW5fdHJlZShkeW5fbHRyZWUsIGxfZGVzYy5tYXhfY29kZSk7XFxuXFx0XFx0XFx0c2Nhbl90cmVlKGR5bl9kdHJlZSwgZF9kZXNjLm1heF9jb2RlKTtcXG5cXG5cXHRcXHRcXHQvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOlxcblxcdFxcdFxcdGJsX2Rlc2MuYnVpbGRfdHJlZSh0aGF0KTtcXG5cXHRcXHRcXHQvLyBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XFxuXFx0XFx0XFx0Ly8gdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlXFxuXFx0XFx0XFx0Ly8gY291bnRzLlxcblxcblxcdFxcdFxcdC8vIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxcblxcdFxcdFxcdC8vIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXFxuXFx0XFx0XFx0Ly8gMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxcblxcdFxcdFxcdGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcXG5cXHRcXHRcXHRcXHRpZiAoYmxfdHJlZVtUcmVlLmJsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXSAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHNcXG5cXHRcXHRcXHR0aGF0Lm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xcblxcblxcdFxcdFxcdHJldHVybiBtYXhfYmxpbmRleDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3V0cHV0IGEgYnl0ZSBvbiB0aGUgc3RyZWFtLlxcblxcdFxcdC8vIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ19idWYuXFxuXFx0XFx0ZnVuY3Rpb24gcHV0X2J5dGUocCkge1xcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWZbdGhhdC5wZW5kaW5nKytdID0gcDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcHV0X3Nob3J0KHcpIHtcXG5cXHRcXHRcXHRwdXRfYnl0ZSh3ICYgMHhmZik7XFxuXFx0XFx0XFx0cHV0X2J5dGUoKHcgPj4+IDgpICYgMHhmZik7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHB1dFNob3J0TVNCKGIpIHtcXG5cXHRcXHRcXHRwdXRfYnl0ZSgoYiA+PiA4KSAmIDB4ZmYpO1xcblxcdFxcdFxcdHB1dF9ieXRlKChiICYgMHhmZikgJiAweGZmKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2VuZF9iaXRzKHZhbHVlLCBsZW5ndGgpIHtcXG5cXHRcXHRcXHR2YXIgdmFsLCBsZW4gPSBsZW5ndGg7XFxuXFx0XFx0XFx0aWYgKGJpX3ZhbGlkID4gQnVmX3NpemUgLSBsZW4pIHtcXG5cXHRcXHRcXHRcXHR2YWwgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHQvLyBiaV9idWYgfD0gKHZhbCA8PCBiaV92YWxpZCk7XFxuXFx0XFx0XFx0XFx0YmlfYnVmIHw9ICgodmFsIDw8IGJpX3ZhbGlkKSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0cHV0X3Nob3J0KGJpX2J1Zik7XFxuXFx0XFx0XFx0XFx0YmlfYnVmID0gdmFsID4+PiAoQnVmX3NpemUgLSBiaV92YWxpZCk7XFxuXFx0XFx0XFx0XFx0YmlfdmFsaWQgKz0gbGVuIC0gQnVmX3NpemU7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBiaV9idWYgfD0gKHZhbHVlKSA8PCBiaV92YWxpZDtcXG5cXHRcXHRcXHRcXHRiaV9idWYgfD0gKCgodmFsdWUpIDw8IGJpX3ZhbGlkKSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0YmlfdmFsaWQgKz0gbGVuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2VuZF9jb2RlKGMsIHRyZWUpIHtcXG5cXHRcXHRcXHR2YXIgYzIgPSBjICogMjtcXG5cXHRcXHRcXHRzZW5kX2JpdHModHJlZVtjMl0gJiAweGZmZmYsIHRyZWVbYzIgKyAxXSAmIDB4ZmZmZik7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cXG5cXHRcXHQvLyBibF90cmVlLlxcblxcdFxcdGZ1bmN0aW9uIHNlbmRfdHJlZSh0cmVlLC8vIHRoZSB0cmVlIHRvIGJlIHNlbnRcXG5cXHRcXHRtYXhfY29kZSAvLyBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3lcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHR2YXIgbjsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xcblxcdFxcdFxcdHZhciBwcmV2bGVuID0gLTE7IC8vIGxhc3QgZW1pdHRlZCBsZW5ndGhcXG5cXHRcXHRcXHR2YXIgY3VybGVuOyAvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07IC8vIGxlbmd0aCBvZiBuZXh0IGNvZGVcXG5cXHRcXHRcXHR2YXIgY291bnQgPSAwOyAvLyByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZVxcblxcdFxcdFxcdHZhciBtYXhfY291bnQgPSA3OyAvLyBtYXggcmVwZWF0IGNvdW50XFxuXFx0XFx0XFx0dmFyIG1pbl9jb3VudCA9IDQ7IC8vIG1pbiByZXBlYXQgY291bnRcXG5cXG5cXHRcXHRcXHRpZiAobmV4dGxlbiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdG1heF9jb3VudCA9IDEzODtcXG5cXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcXG5cXHRcXHRcXHRcXHRjdXJsZW4gPSBuZXh0bGVuO1xcblxcdFxcdFxcdFxcdG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07XFxuXFx0XFx0XFx0XFx0aWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09IG5leHRsZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShjdXJsZW4sIGJsX3RyZWUpO1xcblxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGN1cmxlbiAhPSBwcmV2bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9jb2RlKGN1cmxlbiwgYmxfdHJlZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y291bnQtLTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0c2VuZF9jb2RlKFJFUF8zXzYsIGJsX3RyZWUpO1xcblxcdFxcdFxcdFxcdFxcdHNlbmRfYml0cyhjb3VudCAtIDMsIDIpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcXG5cXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoUkVQWl8zXzEwLCBibF90cmVlKTtcXG5cXHRcXHRcXHRcXHRcXHRzZW5kX2JpdHMoY291bnQgLSAzLCAzKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShSRVBaXzExXzEzOCwgYmxfdHJlZSk7XFxuXFx0XFx0XFx0XFx0XFx0c2VuZF9iaXRzKGNvdW50IC0gMTEsIDcpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb3VudCA9IDA7XFxuXFx0XFx0XFx0XFx0cHJldmxlbiA9IGN1cmxlbjtcXG5cXHRcXHRcXHRcXHRpZiAobmV4dGxlbiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdG1heF9jb3VudCA9IDEzODtcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY3VybGVuID09IG5leHRsZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSA2O1xcblxcdFxcdFxcdFxcdFxcdG1pbl9jb3VudCA9IDM7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSA3O1xcblxcdFxcdFxcdFxcdFxcdG1pbl9jb3VudCA9IDQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXFxuXFx0XFx0Ly8gbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXFxuXFx0XFx0Ly8gSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxcblxcdFxcdGZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSB7XFxuXFx0XFx0XFx0dmFyIHJhbms7IC8vIGluZGV4IGluIGJsX29yZGVyXFxuXFxuXFx0XFx0XFx0c2VuZF9iaXRzKGxjb2RlcyAtIDI1NywgNSk7IC8vIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dFxcblxcdFxcdFxcdHNlbmRfYml0cyhkY29kZXMgLSAxLCA1KTtcXG5cXHRcXHRcXHRzZW5kX2JpdHMoYmxjb2RlcyAtIDQsIDQpOyAvLyBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0XFxuXFx0XFx0XFx0Zm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xcblxcdFxcdFxcdFxcdHNlbmRfYml0cyhibF90cmVlW1RyZWUuYmxfb3JkZXJbcmFua10gKiAyICsgMV0sIDMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzZW5kX3RyZWUoZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLy8gbGl0ZXJhbCB0cmVlXFxuXFx0XFx0XFx0c2VuZF90cmVlKGR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8vIGRpc3RhbmNlIHRyZWVcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXFxuXFx0XFx0ZnVuY3Rpb24gYmlfZmx1c2goKSB7XFxuXFx0XFx0XFx0aWYgKGJpX3ZhbGlkID09IDE2KSB7XFxuXFx0XFx0XFx0XFx0cHV0X3Nob3J0KGJpX2J1Zik7XFxuXFx0XFx0XFx0XFx0YmlfYnVmID0gMDtcXG5cXHRcXHRcXHRcXHRiaV92YWxpZCA9IDA7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChiaV92YWxpZCA+PSA4KSB7XFxuXFx0XFx0XFx0XFx0cHV0X2J5dGUoYmlfYnVmICYgMHhmZik7XFxuXFx0XFx0XFx0XFx0YmlfYnVmID4+Pj0gODtcXG5cXHRcXHRcXHRcXHRiaV92YWxpZCAtPSA4O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cXG5cXHRcXHQvLyBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cXG5cXHRcXHQvLyBUaGUgY3VycmVudCBpbmZsYXRlIGNvZGUgcmVxdWlyZXMgOSBiaXRzIG9mIGxvb2thaGVhZC4gSWYgdGhlXFxuXFx0XFx0Ly8gbGFzdCB0d28gY29kZXMgZm9yIHRoZSBwcmV2aW91cyBibG9jayAocmVhbCBjb2RlIHBsdXMgRU9CKSB3ZXJlIGNvZGVkXFxuXFx0XFx0Ly8gb24gNSBiaXRzIG9yIGxlc3MsIGluZmxhdGUgbWF5IGhhdmUgb25seSA1KzMgYml0cyBvZiBsb29rYWhlYWQgdG8gZGVjb2RlXFxuXFx0XFx0Ly8gdGhlIGxhc3QgcmVhbCBjb2RlLiBJbiB0aGlzIGNhc2Ugd2Ugc2VuZCB0d28gZW1wdHkgc3RhdGljIGJsb2NrcyBpbnN0ZWFkXFxuXFx0XFx0Ly8gb2Ygb25lLiAoVGhlcmUgYXJlIG5vIHByb2JsZW1zIGlmIHRoZSBwcmV2aW91cyBibG9jayBpcyBzdG9yZWQgb3IgZml4ZWQuKVxcblxcdFxcdC8vIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBhc3N1bWUgdGhlIHdvcnN0IGNhc2Ugb2YgbGFzdCByZWFsIGNvZGUgZW5jb2RlZFxcblxcdFxcdC8vIG9uIG9uZSBiaXQgb25seS5cXG5cXHRcXHRmdW5jdGlvbiBfdHJfYWxpZ24oKSB7XFxuXFx0XFx0XFx0c2VuZF9iaXRzKFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcXG5cXHRcXHRcXHRzZW5kX2NvZGUoRU5EX0JMT0NLLCBTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSk7XFxuXFxuXFx0XFx0XFx0YmlfZmx1c2goKTtcXG5cXG5cXHRcXHRcXHQvLyBPZiB0aGUgMTAgYml0cyBmb3IgdGhlIGVtcHR5IGJsb2NrLCB3ZSBoYXZlIGFscmVhZHkgc2VudFxcblxcdFxcdFxcdC8vICgxMCAtIGJpX3ZhbGlkKSBiaXRzLiBUaGUgbG9va2FoZWFkIGZvciB0aGUgbGFzdCByZWFsIGNvZGUgKGJlZm9yZVxcblxcdFxcdFxcdC8vIHRoZSBFT0Igb2YgdGhlIHByZXZpb3VzIGJsb2NrKSB3YXMgdGh1cyBhdCBsZWFzdCBvbmUgcGx1cyB0aGUgbGVuZ3RoXFxuXFx0XFx0XFx0Ly8gb2YgdGhlIEVPQiBwbHVzIHdoYXQgd2UgaGF2ZSBqdXN0IHNlbnQgb2YgdGhlIGVtcHR5IHN0YXRpYyBibG9jay5cXG5cXHRcXHRcXHRpZiAoMSArIGxhc3RfZW9iX2xlbiArIDEwIC0gYmlfdmFsaWQgPCA5KSB7XFxuXFx0XFx0XFx0XFx0c2VuZF9iaXRzKFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcXG5cXHRcXHRcXHRcXHRzZW5kX2NvZGUoRU5EX0JMT0NLLCBTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSk7XFxuXFx0XFx0XFx0XFx0YmlfZmx1c2goKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bGFzdF9lb2JfbGVuID0gNztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXFxuXFx0XFx0Ly8gdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxcblxcdFxcdGZ1bmN0aW9uIF90cl90YWxseShkaXN0LCAvLyBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZ1xcblxcdFxcdGxjIC8vIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XFxuXFx0XFx0XFx0dGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGxhc3RfbGl0ICogMl0gPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBsYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xcblxcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWZbbF9idWYgKyBsYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XFxuXFx0XFx0XFx0bGFzdF9saXQrKztcXG5cXG5cXHRcXHRcXHRpZiAoZGlzdCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdC8vIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhclxcblxcdFxcdFxcdFxcdGR5bl9sdHJlZVtsYyAqIDJdKys7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRtYXRjaGVzKys7XFxuXFx0XFx0XFx0XFx0Ly8gSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSFxcblxcdFxcdFxcdFxcdGRpc3QtLTsgLy8gZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMVxcblxcdFxcdFxcdFxcdGR5bl9sdHJlZVsoVHJlZS5fbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdKys7XFxuXFx0XFx0XFx0XFx0ZHluX2R0cmVlW1RyZWUuZF9jb2RlKGRpc3QpICogMl0rKztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKChsYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgbGV2ZWwgPiAyKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoXFxuXFx0XFx0XFx0XFx0b3V0X2xlbmd0aCA9IGxhc3RfbGl0ICogODtcXG5cXHRcXHRcXHRcXHRpbl9sZW5ndGggPSBzdHJzdGFydCAtIGJsb2NrX3N0YXJ0O1xcblxcdFxcdFxcdFxcdGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRvdXRfbGVuZ3RoICs9IGR5bl9kdHJlZVtkY29kZSAqIDJdICogKDUgKyBUcmVlLmV4dHJhX2RiaXRzW2Rjb2RlXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdG91dF9sZW5ndGggPj4+PSAzO1xcblxcdFxcdFxcdFxcdGlmICgobWF0Y2hlcyA8IE1hdGguZmxvb3IobGFzdF9saXQgLyAyKSkgJiYgb3V0X2xlbmd0aCA8IE1hdGguZmxvb3IoaW5fbGVuZ3RoIC8gMikpXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiAobGFzdF9saXQgPT0gbGl0X2J1ZnNpemUgLSAxKTtcXG5cXHRcXHRcXHQvLyBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcXG5cXHRcXHRcXHQvLyBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xcblxcdFxcdFxcdC8vIDY0Sy0xIGJ5dGVzLlxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcXG5cXHRcXHRmdW5jdGlvbiBjb21wcmVzc19ibG9jayhsdHJlZSwgZHRyZWUpIHtcXG5cXHRcXHRcXHR2YXIgZGlzdDsgLy8gZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmdcXG5cXHRcXHRcXHR2YXIgbGM7IC8vIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PT0gMClcXG5cXHRcXHRcXHR2YXIgbHggPSAwOyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXFxuXFx0XFx0XFx0dmFyIGNvZGU7IC8vIHRoZSBjb2RlIHRvIHNlbmRcXG5cXHRcXHRcXHR2YXIgZXh0cmE7IC8vIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmRcXG5cXG5cXHRcXHRcXHRpZiAobGFzdF9saXQgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0ZGlzdCA9ICgodGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGx4ICogMl0gPDwgOCkgJiAweGZmMDApIHwgKHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBseCAqIDIgKyAxXSAmIDB4ZmYpO1xcblxcdFxcdFxcdFxcdFxcdGxjID0gKHRoYXQucGVuZGluZ19idWZbbF9idWYgKyBseF0pICYgMHhmZjtcXG5cXHRcXHRcXHRcXHRcXHRseCsrO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChkaXN0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9jb2RlKGxjLCBsdHJlZSk7IC8vIHNlbmQgYSBsaXRlcmFsIGJ5dGVcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0hcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb2RlID0gVHJlZS5fbGVuZ3RoX2NvZGVbbGNdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8vIHNlbmQgdGhlIGxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvZGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRyYSA9IFRyZWUuZXh0cmFfbGJpdHNbY29kZV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV4dHJhICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGMgLT0gVHJlZS5iYXNlX2xlbmd0aFtjb2RlXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2JpdHMobGMsIGV4dHJhKTsgLy8gc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlzdC0tOyAvLyBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29kZSA9IFRyZWUuZF9jb2RlKGRpc3QpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShjb2RlLCBkdHJlZSk7IC8vIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRyYSA9IFRyZWUuZXh0cmFfZGJpdHNbY29kZV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV4dHJhICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdCAtPSBUcmVlLmJhc2VfZGlzdFtjb2RlXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2JpdHMoZGlzdCwgZXh0cmEpOyAvLyBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0gLy8gbGl0ZXJhbCBvciBtYXRjaCBwYWlyID9cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2s6XFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAobHggPCBsYXN0X2xpdCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNlbmRfY29kZShFTkRfQkxPQ0ssIGx0cmVlKTtcXG5cXHRcXHRcXHRsYXN0X2VvYl9sZW4gPSBsdHJlZVtFTkRfQkxPQ0sgKiAyICsgMV07XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxcblxcdFxcdGZ1bmN0aW9uIGJpX3dpbmR1cCgpIHtcXG5cXHRcXHRcXHRpZiAoYmlfdmFsaWQgPiA4KSB7XFxuXFx0XFx0XFx0XFx0cHV0X3Nob3J0KGJpX2J1Zik7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChiaV92YWxpZCA+IDApIHtcXG5cXHRcXHRcXHRcXHRwdXRfYnl0ZShiaV9idWYgJiAweGZmKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0YmlfYnVmID0gMDtcXG5cXHRcXHRcXHRiaV92YWxpZCA9IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXFxuXFx0XFx0Ly8gb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXFxuXFx0XFx0ZnVuY3Rpb24gY29weV9ibG9jayhidWYsIC8vIHRoZSBpbnB1dCBkYXRhXFxuXFx0XFx0bGVuLCAvLyBpdHMgbGVuZ3RoXFxuXFx0XFx0aGVhZGVyIC8vIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlblxcblxcdFxcdCkge1xcblxcdFxcdFxcdGJpX3dpbmR1cCgpOyAvLyBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5XFxuXFx0XFx0XFx0bGFzdF9lb2JfbGVuID0gODsgLy8gZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZVxcblxcblxcdFxcdFxcdGlmIChoZWFkZXIpIHtcXG5cXHRcXHRcXHRcXHRwdXRfc2hvcnQobGVuKTtcXG5cXHRcXHRcXHRcXHRwdXRfc2hvcnQofmxlbik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWYuc2V0KHdpbmRvdy5zdWJhcnJheShidWYsIGJ1ZiArIGxlbiksIHRoYXQucGVuZGluZyk7XFxuXFx0XFx0XFx0dGhhdC5wZW5kaW5nICs9IGxlbjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2VuZCBhIHN0b3JlZCBibG9ja1xcblxcdFxcdGZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2soYnVmLCAvLyBpbnB1dCBibG9ja1xcblxcdFxcdHN0b3JlZF9sZW4sIC8vIGxlbmd0aCBvZiBpbnB1dCBibG9ja1xcblxcdFxcdGVvZiAvLyB0cnVlIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZVxcblxcdFxcdCkge1xcblxcdFxcdFxcdHNlbmRfYml0cygoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGVvZiA/IDEgOiAwKSwgMyk7IC8vIHNlbmQgYmxvY2sgdHlwZVxcblxcdFxcdFxcdGNvcHlfYmxvY2soYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLy8gd2l0aCBoZWFkZXJcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXFxuXFx0XFx0Ly8gdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxcblxcdFxcdGZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhidWYsIC8vIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGRcXG5cXHRcXHRzdG9yZWRfbGVuLCAvLyBsZW5ndGggb2YgaW5wdXQgYmxvY2tcXG5cXHRcXHRlb2YgLy8gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGVcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHR2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOy8vIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXNcXG5cXHRcXHRcXHR2YXIgbWF4X2JsaW5kZXggPSAwOyAvLyBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxXFxuXFxuXFx0XFx0XFx0Ly8gQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZFxcblxcdFxcdFxcdGlmIChsZXZlbCA+IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzXFxuXFx0XFx0XFx0XFx0bF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxuXFxuXFx0XFx0XFx0XFx0ZF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzXFxuXFx0XFx0XFx0XFx0Ly8gb2ZcXG5cXHRcXHRcXHRcXHQvLyB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxcblxcblxcdFxcdFxcdFxcdC8vIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gaW5kZXhcXG5cXHRcXHRcXHRcXHQvLyBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cXG5cXHRcXHRcXHRcXHRtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgZmlyc3QgdGhlIGJsb2NrIGxlbmd0aCBpblxcblxcdFxcdFxcdFxcdC8vIGJ5dGVzXFxuXFx0XFx0XFx0XFx0b3B0X2xlbmIgPSAodGhhdC5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xcblxcdFxcdFxcdFxcdHN0YXRpY19sZW5iID0gKHRoYXQuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpXFxuXFx0XFx0XFx0XFx0XFx0b3B0X2xlbmIgPSBzdGF0aWNfbGVuYjtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLy8gZm9yY2UgYSBzdG9yZWQgYmxvY2tcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgYnVmICE9IC0xKSB7XFxuXFx0XFx0XFx0XFx0Ly8gNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3Roc1xcblxcdFxcdFxcdFxcdC8vIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlc1xcblxcdFxcdFxcdFxcdC8vIHNpbmNlXFxuXFx0XFx0XFx0XFx0Ly8gdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXFxuXFx0XFx0XFx0XFx0Ly8gc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXFxuXFx0XFx0XFx0XFx0Ly8gdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cXG5cXHRcXHRcXHRcXHRfdHJfc3RvcmVkX2Jsb2NrKGJ1Ziwgc3RvcmVkX2xlbiwgZW9mKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKHN0YXRpY19sZW5iID09IG9wdF9sZW5iKSB7XFxuXFx0XFx0XFx0XFx0c2VuZF9iaXRzKChTVEFUSUNfVFJFRVMgPDwgMSkgKyAoZW9mID8gMSA6IDApLCAzKTtcXG5cXHRcXHRcXHRcXHRjb21wcmVzc19ibG9jayhTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSwgU3RhdGljVHJlZS5zdGF0aWNfZHRyZWUpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0c2VuZF9iaXRzKChEWU5fVFJFRVMgPDwgMSkgKyAoZW9mID8gMSA6IDApLCAzKTtcXG5cXHRcXHRcXHRcXHRzZW5kX2FsbF90cmVlcyhsX2Rlc2MubWF4X2NvZGUgKyAxLCBkX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xcblxcdFxcdFxcdFxcdGNvbXByZXNzX2Jsb2NrKGR5bl9sdHJlZSwgZHluX2R0cmVlKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcXG5cXHRcXHRcXHQvLyBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cXG5cXG5cXHRcXHRcXHRpbml0X2Jsb2NrKCk7XFxuXFxuXFx0XFx0XFx0aWYgKGVvZikge1xcblxcdFxcdFxcdFxcdGJpX3dpbmR1cCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShlb2YpIHtcXG5cXHRcXHRcXHRfdHJfZmx1c2hfYmxvY2soYmxvY2tfc3RhcnQgPj0gMCA/IGJsb2NrX3N0YXJ0IDogLTEsIHN0cnN0YXJ0IC0gYmxvY2tfc3RhcnQsIGVvZik7XFxuXFx0XFx0XFx0YmxvY2tfc3RhcnQgPSBzdHJzdGFydDtcXG5cXHRcXHRcXHRzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cXG5cXHRcXHQvLyBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcXG5cXHRcXHQvLyBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxcblxcdFxcdC8vIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09PSAwOyByZWFkcyBhcmVcXG5cXHRcXHQvLyBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxcblxcdFxcdC8vIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxcblxcdFxcdGZ1bmN0aW9uIGZpbGxfd2luZG93KCkge1xcblxcdFxcdFxcdHZhciBuLCBtO1xcblxcdFxcdFxcdHZhciBwO1xcblxcdFxcdFxcdHZhciBtb3JlOyAvLyBBbW91bnQgb2YgZnJlZSBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSB3aW5kb3cuXFxuXFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdG1vcmUgPSAod2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDpcXG5cXHRcXHRcXHRcXHRpZiAobW9yZSA9PT0gMCAmJiBzdHJzdGFydCA9PT0gMCAmJiBsb29rYWhlYWQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRtb3JlID0gd19zaXplO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAobW9yZSA9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZiBzdHJzdGFydCA9PVxcblxcdFxcdFxcdFxcdFxcdC8vIDBcXG5cXHRcXHRcXHRcXHRcXHQvLyBhbmQgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgb25lIGJ5dGUgYXQgdGltZSlcXG5cXHRcXHRcXHRcXHRcXHRtb3JlLS07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbG9va2FoZWFkLFxcblxcdFxcdFxcdFxcdFxcdC8vIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXBwZXIgaGFsZi5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHN0cnN0YXJ0ID49IHdfc2l6ZSArIHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuc2V0KHdpbmRvdy5zdWJhcnJheSh3X3NpemUsIHdfc2l6ZSArIHdfc2l6ZSksIDApO1xcblxcblxcdFxcdFxcdFxcdFxcdG1hdGNoX3N0YXJ0IC09IHdfc2l6ZTtcXG5cXHRcXHRcXHRcXHRcXHRzdHJzdGFydCAtPSB3X3NpemU7IC8vIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUXFxuXFx0XFx0XFx0XFx0XFx0YmxvY2tfc3RhcnQgLT0gd19zaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdC8vIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PVxcblxcdFxcdFxcdFxcdFxcdC8vIDBcXG5cXHRcXHRcXHRcXHRcXHQvLyB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWxcXG5cXHRcXHRcXHRcXHRcXHQvLyA+IDBcXG5cXHRcXHRcXHRcXHRcXHQvLyBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcXG5cXHRcXHRcXHRcXHRcXHQvLyB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxcblxcblxcdFxcdFxcdFxcdFxcdG4gPSBoYXNoX3NpemU7XFxuXFx0XFx0XFx0XFx0XFx0cCA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdG0gPSAoaGVhZFstLXBdICYgMHhmZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoZWFkW3BdID0gKG0gPj0gd19zaXplID8gbSAtIHdfc2l6ZSA6IDApO1xcblxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0tbiAhPT0gMCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0biA9IHdfc2l6ZTtcXG5cXHRcXHRcXHRcXHRcXHRwID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bSA9IChwcmV2Wy0tcF0gJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHByZXZbcF0gPSAobSA+PSB3X3NpemUgPyBtIC0gd19zaXplIDogMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxcblxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0tbiAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0bW9yZSArPSB3X3NpemU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX2luID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcXG5cXHRcXHRcXHRcXHQvLyBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxcblxcdFxcdFxcdFxcdC8vIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxcblxcdFxcdFxcdFxcdC8vID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxcblxcdFxcdFxcdFxcdC8vID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxcblxcdFxcdFxcdFxcdC8vIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxcblxcdFxcdFxcdFxcdC8vIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICYmXFxuXFx0XFx0XFx0XFx0Ly8gc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXFxuXFxuXFx0XFx0XFx0XFx0biA9IHN0cm0ucmVhZF9idWYod2luZG93LCBzdHJzdGFydCArIGxvb2thaGVhZCwgbW9yZSk7XFxuXFx0XFx0XFx0XFx0bG9va2FoZWFkICs9IG47XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6XFxuXFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRpbnNfaCA9IHdpbmRvd1tzdHJzdGFydF0gJiAweGZmO1xcblxcdFxcdFxcdFxcdFxcdGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1tzdHJzdGFydCArIDFdICYgMHhmZikpICYgaGFzaF9tYXNrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzXFxuXFx0XFx0XFx0XFx0Ly8gZ2FyYmFnZSxcXG5cXHRcXHRcXHRcXHQvLyBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlXFxuXFx0XFx0XFx0XFx0Ly8gZW1pdHRlZC5cXG5cXHRcXHRcXHR9IHdoaWxlIChsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHN0cm0uYXZhaWxfaW4gIT09IDApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sXFxuXFx0XFx0Ly8gcmV0dXJuXFxuXFx0XFx0Ly8gdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXFxuXFx0XFx0Ly8gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcXG5cXHRcXHQvLyB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxcblxcdFxcdC8vIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cXG5cXHRcXHQvLyBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXFxuXFx0XFx0Ly8gd2luZG93IHRvIHBlbmRpbmdfYnVmLlxcblxcdFxcdGZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKGZsdXNoKSB7XFxuXFx0XFx0XFx0Ly8gU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcXG5cXHRcXHRcXHQvLyB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcXG5cXG5cXHRcXHRcXHR2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XFxuXFx0XFx0XFx0dmFyIG1heF9zdGFydDtcXG5cXG5cXHRcXHRcXHRpZiAobWF4X2Jsb2NrX3NpemUgPiBwZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xcblxcdFxcdFxcdFxcdG1heF9ibG9ja19zaXplID0gcGVuZGluZ19idWZfc2l6ZSAtIDU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDpcXG5cXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdC8vIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOlxcblxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPD0gMSkge1xcblxcdFxcdFxcdFxcdFxcdGZpbGxfd2luZG93KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PSBaX05PX0ZMVVNIKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrOyAvLyBmbHVzaCB0aGUgY3VycmVudCBibG9ja1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRzdHJzdGFydCArPSBsb29rYWhlYWQ7XFxuXFx0XFx0XFx0XFx0bG9va2FoZWFkID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDpcXG5cXHRcXHRcXHRcXHRtYXhfc3RhcnQgPSBibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xcblxcdFxcdFxcdFxcdGlmIChzdHJzdGFydCA9PT0gMCB8fCBzdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBzdHJzdGFydCA9PT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmVcXG5cXHRcXHRcXHRcXHRcXHRsb29rYWhlYWQgPSAoc3Ryc3RhcnQgLSBtYXhfc3RhcnQpO1xcblxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xcblxcblxcdFxcdFxcdFxcdFxcdGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxcblxcdFxcdFxcdFxcdC8vIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XFxuXFx0XFx0XFx0XFx0aWYgKHN0cnN0YXJ0IC0gYmxvY2tfc3RhcnQgPj0gd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdFxcdGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZsdXNoID09IFpfRklOSVNIKTtcXG5cXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxuXFx0XFx0XFx0XFx0cmV0dXJuIChmbHVzaCA9PSBaX0ZJTklTSCkgPyBGaW5pc2hTdGFydGVkIDogTmVlZE1vcmU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChjdXJfbWF0Y2gpIHtcXG5cXHRcXHRcXHR2YXIgY2hhaW5fbGVuZ3RoID0gbWF4X2NoYWluX2xlbmd0aDsgLy8gbWF4IGhhc2ggY2hhaW4gbGVuZ3RoXFxuXFx0XFx0XFx0dmFyIHNjYW4gPSBzdHJzdGFydDsgLy8gY3VycmVudCBzdHJpbmdcXG5cXHRcXHRcXHR2YXIgbWF0Y2g7IC8vIG1hdGNoZWQgc3RyaW5nXFxuXFx0XFx0XFx0dmFyIGxlbjsgLy8gbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2hcXG5cXHRcXHRcXHR2YXIgYmVzdF9sZW4gPSBwcmV2X2xlbmd0aDsgLy8gYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyXFxuXFx0XFx0XFx0dmFyIGxpbWl0ID0gc3Ryc3RhcnQgPiAod19zaXplIC0gTUlOX0xPT0tBSEVBRCkgPyBzdHJzdGFydCAtICh3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDA7XFxuXFx0XFx0XFx0dmFyIF9uaWNlX21hdGNoID0gbmljZV9tYXRjaDtcXG5cXG5cXHRcXHRcXHQvLyBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxcblxcdFxcdFxcdC8vIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXFxuXFxuXFx0XFx0XFx0dmFyIHdtYXNrID0gd19tYXNrO1xcblxcblxcdFxcdFxcdHZhciBzdHJlbmQgPSBzdHJzdGFydCArIE1BWF9NQVRDSDtcXG5cXHRcXHRcXHR2YXIgc2Nhbl9lbmQxID0gd2luZG93W3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xcblxcdFxcdFxcdHZhciBzY2FuX2VuZCA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW5dO1xcblxcblxcdFxcdFxcdC8vIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mXFxuXFx0XFx0XFx0Ly8gMTYuXFxuXFx0XFx0XFx0Ly8gSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cXG5cXG5cXHRcXHRcXHQvLyBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOlxcblxcdFxcdFxcdGlmIChwcmV2X2xlbmd0aCA+PSBnb29kX21hdGNoKSB7XFxuXFx0XFx0XFx0XFx0Y2hhaW5fbGVuZ3RoID4+PSAyO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXNcXG5cXHRcXHRcXHQvLyBuZWNlc3NhcnlcXG5cXHRcXHRcXHQvLyB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cXG5cXHRcXHRcXHRpZiAoX25pY2VfbWF0Y2ggPiBsb29rYWhlYWQpXFxuXFx0XFx0XFx0XFx0X25pY2VfbWF0Y2ggPSBsb29rYWhlYWQ7XFxuXFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdG1hdGNoID0gY3VyX21hdGNoO1xcblxcblxcdFxcdFxcdFxcdC8vIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxcblxcdFxcdFxcdFxcdC8vIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDI6XFxuXFx0XFx0XFx0XFx0aWYgKHdpbmRvd1ttYXRjaCArIGJlc3RfbGVuXSAhPSBzY2FuX2VuZCB8fCB3aW5kb3dbbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9IHNjYW5fZW5kMSB8fCB3aW5kb3dbbWF0Y2hdICE9IHdpbmRvd1tzY2FuXVxcblxcdFxcdFxcdFxcdFxcdFxcdHx8IHdpbmRvd1srK21hdGNoXSAhPSB3aW5kb3dbc2NhbiArIDFdKVxcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdC8vIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXFxuXFx0XFx0XFx0XFx0Ly8gYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcXG5cXHRcXHRcXHRcXHQvLyBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxcblxcdFxcdFxcdFxcdC8vIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcXG5cXHRcXHRcXHRcXHQvLyB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cXG5cXHRcXHRcXHRcXHRzY2FuICs9IDI7XFxuXFx0XFx0XFx0XFx0bWF0Y2grKztcXG5cXG5cXHRcXHRcXHRcXHQvLyBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xcblxcdFxcdFxcdFxcdC8vIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxcblxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHR9IHdoaWxlICh3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXVxcblxcdFxcdFxcdFxcdFxcdFxcdCYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdXFxuXFx0XFx0XFx0XFx0XFx0XFx0JiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiBzY2FuIDwgc3RyZW5kKTtcXG5cXG5cXHRcXHRcXHRcXHRsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XFxuXFx0XFx0XFx0XFx0c2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAobGVuID4gYmVzdF9sZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcXG5cXHRcXHRcXHRcXHRcXHRiZXN0X2xlbiA9IGxlbjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobGVuID49IF9uaWNlX21hdGNoKVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdHNjYW5fZW5kMSA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW4gLSAxXTtcXG5cXHRcXHRcXHRcXHRcXHRzY2FuX2VuZCA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW5dO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IHdoaWxlICgoY3VyX21hdGNoID0gKHByZXZbY3VyX21hdGNoICYgd21hc2tdICYgMHhmZmZmKSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XFxuXFxuXFx0XFx0XFx0aWYgKGJlc3RfbGVuIDw9IGxvb2thaGVhZClcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYmVzdF9sZW47XFxuXFx0XFx0XFx0cmV0dXJuIGxvb2thaGVhZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxcblxcdFxcdC8vIGJsb2NrIHN0YXRlLlxcblxcdFxcdC8vIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xcblxcdFxcdC8vIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxcblxcdFxcdC8vIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cXG5cXHRcXHRmdW5jdGlvbiBkZWZsYXRlX2Zhc3QoZmx1c2gpIHtcXG5cXHRcXHRcXHQvLyBzaG9ydCBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIHRoZSBoYXNoIGNoYWluXFxuXFx0XFx0XFx0dmFyIGhhc2hfaGVhZCA9IDA7IC8vIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW5cXG5cXHRcXHRcXHR2YXIgYmZsdXNoOyAvLyBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWRcXG5cXG5cXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxcblxcdFxcdFxcdFxcdC8vIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXFxuXFx0XFx0XFx0XFx0Ly8gZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cXG5cXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdFxcdGZpbGxfd2luZG93KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT0gWl9OT19GTFVTSCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxcblxcdFxcdFxcdFxcdC8vIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxcblxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhzdHJzdGFydCkgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikpICYgaGFzaF9tYXNrO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHByZXZbc3Ryc3RhcnQmd19tYXNrXT1oYXNoX2hlYWQ9aGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0aGFzaF9oZWFkID0gKGhlYWRbaW5zX2hdICYgMHhmZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRwcmV2W3N0cnN0YXJ0ICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdFxcdGhlYWRbaW5zX2hdID0gc3Ryc3RhcnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXFxuXFx0XFx0XFx0XFx0Ly8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcXG5cXG5cXHRcXHRcXHRcXHRpZiAoaGFzaF9oZWFkICE9PSAwICYmICgoc3Ryc3RhcnQgLSBoYXNoX2hlYWQpICYgMHhmZmZmKSA8PSB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRcXHQvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcXG5cXHRcXHRcXHRcXHRcXHQvLyBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cmF0ZWd5ICE9IFpfSFVGRk1BTl9PTkxZKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChoYXNoX2hlYWQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQvLyBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydFxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAobWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIGNoZWNrX21hdGNoKHN0cnN0YXJ0LCBtYXRjaF9zdGFydCwgbWF0Y2hfbGVuZ3RoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRiZmx1c2ggPSBfdHJfdGFsbHkoc3Ryc3RhcnQgLSBtYXRjaF9zdGFydCwgbWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb29rYWhlYWQgLT0gbWF0Y2hfbGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHQvLyBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxcblxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaF9sZW5ndGggPD0gbWF4X2xhenlfbWF0Y2ggJiYgbG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoX2xlbmd0aC0tOyAvLyBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiBoYXNoIHRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0Kys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zX2ggPSAoKGluc19oIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1soc3Ryc3RhcnQpICsgKE1JTl9NQVRDSCAtIDEpXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwcmV2W3N0cnN0YXJ0JndfbWFza109aGFzaF9oZWFkPWhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJldltzdHJzdGFydCAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoZWFkW2luc19oXSA9IHN0cnN0YXJ0O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxcblxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0tbWF0Y2hfbGVuZ3RoICE9PSAwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdHJzdGFydCsrO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQgKz0gbWF0Y2hfbGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoX2xlbmd0aCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zX2ggPSB3aW5kb3dbc3Ryc3RhcnRdICYgMHhmZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbc3Ryc3RhcnQgKyAxXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbm90XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlXFxuXFxuXFx0XFx0XFx0XFx0XFx0YmZsdXNoID0gX3RyX3RhbGx5KDAsIHdpbmRvd1tzdHJzdGFydF0gJiAweGZmKTtcXG5cXHRcXHRcXHRcXHRcXHRsb29rYWhlYWQtLTtcXG5cXHRcXHRcXHRcXHRcXHRzdHJzdGFydCsrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoYmZsdXNoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZsdXNoX2Jsb2NrX29ubHkoZmx1c2ggPT0gWl9GSU5JU0gpO1xcblxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdGlmIChmbHVzaCA9PSBaX0ZJTklTSClcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gRmluaXNoU3RhcnRlZDtcXG5cXHRcXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIE5lZWRNb3JlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZmx1c2ggPT0gWl9GSU5JU0ggPyBGaW5pc2hEb25lIDogQmxvY2tEb25lO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XFxuXFx0XFx0Ly8gZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xcblxcdFxcdC8vIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXFxuXFx0XFx0ZnVuY3Rpb24gZGVmbGF0ZV9zbG93KGZsdXNoKSB7XFxuXFx0XFx0XFx0Ly8gc2hvcnQgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiBoYXNoIGNoYWluXFxuXFx0XFx0XFx0dmFyIGhhc2hfaGVhZCA9IDA7IC8vIGhlYWQgb2YgaGFzaCBjaGFpblxcblxcdFxcdFxcdHZhciBiZmx1c2g7IC8vIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZFxcblxcdFxcdFxcdHZhciBtYXhfaW5zZXJ0O1xcblxcblxcdFxcdFxcdC8vIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLlxcblxcdFxcdFxcdHdoaWxlICh0cnVlKSB7XFxuXFx0XFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XFxuXFx0XFx0XFx0XFx0Ly8gYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcXG5cXHRcXHRcXHRcXHQvLyBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcXG5cXHRcXHRcXHRcXHQvLyBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxcblxcblxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZmlsbF93aW5kb3coKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PSBaX05PX0ZMVVNIKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIE5lZWRNb3JlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrOyAvLyBmbHVzaCB0aGUgY3VycmVudCBibG9ja1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXFxuXFx0XFx0XFx0XFx0Ly8gZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRoYXNoX2hlYWQgPSAoaGVhZFtpbnNfaF0gJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdFxcdHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0aGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cXG5cXHRcXHRcXHRcXHRwcmV2X2xlbmd0aCA9IG1hdGNoX2xlbmd0aDtcXG5cXHRcXHRcXHRcXHRwcmV2X21hdGNoID0gbWF0Y2hfc3RhcnQ7XFxuXFx0XFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoaGFzaF9oZWFkICE9PSAwICYmIHByZXZfbGVuZ3RoIDwgbWF4X2xhenlfbWF0Y2ggJiYgKChzdHJzdGFydCAtIGhhc2hfaGVhZCkgJiAweGZmZmYpIDw9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xcblxcdFxcdFxcdFxcdFxcdC8vIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxcblxcdFxcdFxcdFxcdFxcdC8vIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RyYXRlZ3kgIT0gWl9IVUZGTUFOX09OTFkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKGhhc2hfaGVhZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1hdGNoX2xlbmd0aCA8PSA1ICYmIChzdHJhdGVneSA9PSBaX0ZJTFRFUkVEIHx8IChtYXRjaF9sZW5ndGggPT0gTUlOX01BVENIICYmIHN0cnN0YXJ0IC0gbWF0Y2hfc3RhcnQgPiA0MDk2KSkpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XFxuXFx0XFx0XFx0XFx0Ly8gbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcXG5cXHRcXHRcXHRcXHRpZiAocHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIG1hdGNoX2xlbmd0aCA8PSBwcmV2X2xlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdG1heF9pbnNlcnQgPSBzdHJzdGFydCArIGxvb2thaGVhZCAtIE1JTl9NQVRDSDtcXG5cXHRcXHRcXHRcXHRcXHQvLyBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy5cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjaGVja19tYXRjaChzdHJzdGFydC0xLCBwcmV2X21hdGNoLCBwcmV2X2xlbmd0aCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmZsdXNoID0gX3RyX3RhbGx5KHN0cnN0YXJ0IC0gMSAtIHByZXZfbWF0Y2gsIHByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZSBoYXNoIHRhYmxlLlxcblxcdFxcdFxcdFxcdFxcdGxvb2thaGVhZCAtPSBwcmV2X2xlbmd0aCAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0cHJldl9sZW5ndGggLT0gMjtcXG5cXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCsrc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1soc3Ryc3RhcnQpICsgKE1JTl9NQVRDSCAtIDEpXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwcmV2W3N0cnN0YXJ0JndfbWFza109aGFzaF9oZWFkPWhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJldltzdHJzdGFydCAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoZWFkW2luc19oXSA9IHN0cnN0YXJ0O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLXByZXZfbGVuZ3RoICE9PSAwKTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9hdmFpbGFibGUgPSAwO1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQrKztcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoYmZsdXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtYXRjaF9hdmFpbGFibGUgIT09IDApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxcblxcdFxcdFxcdFxcdFxcdC8vIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcXG5cXHRcXHRcXHRcXHRcXHQvLyBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxcblxcblxcdFxcdFxcdFxcdFxcdGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnQgLSAxXSAmIDB4ZmYpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChiZmx1c2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQrKztcXG5cXHRcXHRcXHRcXHRcXHRsb29rYWhlYWQtLTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIE5lZWRNb3JlO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxcblxcblxcdFxcdFxcdFxcdFxcdG1hdGNoX2F2YWlsYWJsZSA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQrKztcXG5cXHRcXHRcXHRcXHRcXHRsb29rYWhlYWQtLTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChtYXRjaF9hdmFpbGFibGUgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRiZmx1c2ggPSBfdHJfdGFsbHkoMCwgd2luZG93W3N0cnN0YXJ0IC0gMV0gJiAweGZmKTtcXG5cXHRcXHRcXHRcXHRtYXRjaF9hdmFpbGFibGUgPSAwO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZsdXNoID09IFpfRklOSVNIKTtcXG5cXG5cXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRpZiAoZmx1c2ggPT0gWl9GSU5JU0gpXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEZpbmlzaFN0YXJ0ZWQ7XFxuXFx0XFx0XFx0XFx0ZWxzZVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcXG5cXHRcXHRcXHRzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xcblxcdFxcdFxcdHN0cm0ubXNnID0gbnVsbDsgLy9cXG5cXHRcXHRcXHRcXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmcgPSAwO1xcblxcdFxcdFxcdHRoYXQucGVuZGluZ19vdXQgPSAwO1xcblxcblxcdFxcdFxcdHN0YXR1cyA9IEJVU1lfU1RBVEU7XFxuXFxuXFx0XFx0XFx0bGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XFxuXFxuXFx0XFx0XFx0dHJfaW5pdCgpO1xcblxcdFxcdFxcdGxtX2luaXQoKTtcXG5cXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhhdC5kZWZsYXRlSW5pdCA9IGZ1bmN0aW9uKHN0cm0sIF9sZXZlbCwgYml0cywgX21ldGhvZCwgbWVtTGV2ZWwsIF9zdHJhdGVneSkge1xcblxcdFxcdFxcdGlmICghX21ldGhvZClcXG5cXHRcXHRcXHRcXHRfbWV0aG9kID0gWl9ERUZMQVRFRDtcXG5cXHRcXHRcXHRpZiAoIW1lbUxldmVsKVxcblxcdFxcdFxcdFxcdG1lbUxldmVsID0gREVGX01FTV9MRVZFTDtcXG5cXHRcXHRcXHRpZiAoIV9zdHJhdGVneSlcXG5cXHRcXHRcXHRcXHRfc3RyYXRlZ3kgPSBaX0RFRkFVTFRfU1RSQVRFR1k7XFxuXFxuXFx0XFx0XFx0Ly8gYnl0ZVtdIG15X3ZlcnNpb249WkxJQl9WRVJTSU9OO1xcblxcblxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0Ly8gaWYgKCF2ZXJzaW9uIHx8IHZlcnNpb25bMF0gIT0gbXlfdmVyc2lvblswXVxcblxcdFxcdFxcdC8vIHx8IHN0cmVhbV9zaXplICE9IHNpemVvZih6X3N0cmVhbSkpIHtcXG5cXHRcXHRcXHQvLyByZXR1cm4gWl9WRVJTSU9OX0VSUk9SO1xcblxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHRzdHJtLm1zZyA9IG51bGw7XFxuXFxuXFx0XFx0XFx0aWYgKF9sZXZlbCA9PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pXFxuXFx0XFx0XFx0XFx0X2xldmVsID0gNjtcXG5cXG5cXHRcXHRcXHRpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBfbWV0aG9kICE9IFpfREVGTEFURUQgfHwgYml0cyA8IDkgfHwgYml0cyA+IDE1IHx8IF9sZXZlbCA8IDAgfHwgX2xldmVsID4gOSB8fCBfc3RyYXRlZ3kgPCAwXFxuXFx0XFx0XFx0XFx0XFx0fHwgX3N0cmF0ZWd5ID4gWl9IVUZGTUFOX09OTFkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0cm0uZHN0YXRlID0gdGhhdDtcXG5cXG5cXHRcXHRcXHR3X2JpdHMgPSBiaXRzO1xcblxcdFxcdFxcdHdfc2l6ZSA9IDEgPDwgd19iaXRzO1xcblxcdFxcdFxcdHdfbWFzayA9IHdfc2l6ZSAtIDE7XFxuXFxuXFx0XFx0XFx0aGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xcblxcdFxcdFxcdGhhc2hfc2l6ZSA9IDEgPDwgaGFzaF9iaXRzO1xcblxcdFxcdFxcdGhhc2hfbWFzayA9IGhhc2hfc2l6ZSAtIDE7XFxuXFx0XFx0XFx0aGFzaF9zaGlmdCA9IE1hdGguZmxvb3IoKGhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcXG5cXG5cXHRcXHRcXHR3aW5kb3cgPSBuZXcgVWludDhBcnJheSh3X3NpemUgKiAyKTtcXG5cXHRcXHRcXHRwcmV2ID0gW107XFxuXFx0XFx0XFx0aGVhZCA9IFtdO1xcblxcblxcdFxcdFxcdGxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLy8gMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHRcXG5cXG5cXHRcXHRcXHQvLyBXZSBvdmVybGF5IHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1Zi4gVGhpcyB3b3JrcyBzaW5jZSB0aGUgYXZlcmFnZVxcblxcdFxcdFxcdC8vIG91dHB1dCBzaXplIGZvciAobGVuZ3RoLGRpc3RhbmNlKSBjb2RlcyBpcyA8PSAyNCBiaXRzLlxcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShsaXRfYnVmc2l6ZSAqIDQpO1xcblxcdFxcdFxcdHBlbmRpbmdfYnVmX3NpemUgPSBsaXRfYnVmc2l6ZSAqIDQ7XFxuXFxuXFx0XFx0XFx0ZF9idWYgPSBNYXRoLmZsb29yKGxpdF9idWZzaXplIC8gMik7XFxuXFx0XFx0XFx0bF9idWYgPSAoMSArIDIpICogbGl0X2J1ZnNpemU7XFxuXFxuXFx0XFx0XFx0bGV2ZWwgPSBfbGV2ZWw7XFxuXFxuXFx0XFx0XFx0c3RyYXRlZ3kgPSBfc3RyYXRlZ3k7XFxuXFx0XFx0XFx0bWV0aG9kID0gX21ldGhvZCAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuZGVmbGF0ZUVuZCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmIChzdGF0dXMgIT0gSU5JVF9TVEFURSAmJiBzdGF0dXMgIT0gQlVTWV9TVEFURSAmJiBzdGF0dXMgIT0gRklOSVNIX1NUQVRFKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBEZWFsbG9jYXRlIGluIHJldmVyc2Ugb3JkZXIgb2YgYWxsb2NhdGlvbnM6XFxuXFx0XFx0XFx0dGhhdC5wZW5kaW5nX2J1ZiA9IG51bGw7XFxuXFx0XFx0XFx0aGVhZCA9IG51bGw7XFxuXFx0XFx0XFx0cHJldiA9IG51bGw7XFxuXFx0XFx0XFx0d2luZG93ID0gbnVsbDtcXG5cXHRcXHRcXHQvLyBmcmVlXFxuXFx0XFx0XFx0dGhhdC5kc3RhdGUgPSBudWxsO1xcblxcdFxcdFxcdHJldHVybiBzdGF0dXMgPT0gQlVTWV9TVEFURSA/IFpfREFUQV9FUlJPUiA6IFpfT0s7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmRlZmxhdGVQYXJhbXMgPSBmdW5jdGlvbihzdHJtLCBfbGV2ZWwsIF9zdHJhdGVneSkge1xcblxcdFxcdFxcdHZhciBlcnIgPSBaX09LO1xcblxcblxcdFxcdFxcdGlmIChfbGV2ZWwgPT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XFxuXFx0XFx0XFx0XFx0X2xldmVsID0gNjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKF9sZXZlbCA8IDAgfHwgX2xldmVsID4gOSB8fCBfc3RyYXRlZ3kgPCAwIHx8IF9zdHJhdGVneSA+IFpfSFVGRk1BTl9PTkxZKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoY29uZmlnX3RhYmxlW2xldmVsXS5mdW5jICE9IGNvbmZpZ190YWJsZVtfbGV2ZWxdLmZ1bmMgJiYgc3RybS50b3RhbF9pbiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdC8vIEZsdXNoIHRoZSBsYXN0IGJ1ZmZlcjpcXG5cXHRcXHRcXHRcXHRlcnIgPSBzdHJtLmRlZmxhdGUoWl9QQVJUSUFMX0ZMVVNIKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGxldmVsICE9IF9sZXZlbCkge1xcblxcdFxcdFxcdFxcdGxldmVsID0gX2xldmVsO1xcblxcdFxcdFxcdFxcdG1heF9sYXp5X21hdGNoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfbGF6eTtcXG5cXHRcXHRcXHRcXHRnb29kX21hdGNoID0gY29uZmlnX3RhYmxlW2xldmVsXS5nb29kX2xlbmd0aDtcXG5cXHRcXHRcXHRcXHRuaWNlX21hdGNoID0gY29uZmlnX3RhYmxlW2xldmVsXS5uaWNlX2xlbmd0aDtcXG5cXHRcXHRcXHRcXHRtYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfY2hhaW47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHN0cmF0ZWd5ID0gX3N0cmF0ZWd5O1xcblxcdFxcdFxcdHJldHVybiBlcnI7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcblxcdFxcdFxcdHZhciBsZW5ndGggPSBkaWN0TGVuZ3RoO1xcblxcdFxcdFxcdHZhciBuLCBpbmRleCA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKCFkaWN0aW9uYXJ5IHx8IHN0YXR1cyAhPSBJTklUX1NUQVRFKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRpZiAobGVuZ3RoIDwgTUlOX01BVENIKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdFxcdGlmIChsZW5ndGggPiB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxuXFx0XFx0XFx0XFx0bGVuZ3RoID0gd19zaXplIC0gTUlOX0xPT0tBSEVBRDtcXG5cXHRcXHRcXHRcXHRpbmRleCA9IGRpY3RMZW5ndGggLSBsZW5ndGg7IC8vIHVzZSB0aGUgdGFpbCBvZiB0aGUgZGljdGlvbmFyeVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR3aW5kb3cuc2V0KGRpY3Rpb25hcnkuc3ViYXJyYXkoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKSwgMCk7XFxuXFxuXFx0XFx0XFx0c3Ryc3RhcnQgPSBsZW5ndGg7XFxuXFx0XFx0XFx0YmxvY2tfc3RhcnQgPSBsZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gSW5zZXJ0IGFsbCBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIChleGNlcHQgZm9yIHRoZSBsYXN0IHR3byBieXRlcykuXFxuXFx0XFx0XFx0Ly8gcy0+bG9va2FoZWFkIHN0YXlzIG51bGwsIHNvIHMtPmluc19oIHdpbGwgYmUgcmVjb21wdXRlZCBhdCB0aGUgbmV4dFxcblxcdFxcdFxcdC8vIGNhbGwgb2YgZmlsbF93aW5kb3cuXFxuXFxuXFx0XFx0XFx0aW5zX2ggPSB3aW5kb3dbMF0gJiAweGZmO1xcblxcdFxcdFxcdGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1sxXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXG5cXHRcXHRcXHRmb3IgKG4gPSAwOyBuIDw9IGxlbmd0aCAtIE1JTl9NQVRDSDsgbisrKSB7XFxuXFx0XFx0XFx0XFx0aW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhuKSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0cHJldltuICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdGhlYWRbaW5zX2hdID0gbjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmRlZmxhdGUgPSBmdW5jdGlvbihfc3RybSwgZmx1c2gpIHtcXG5cXHRcXHRcXHR2YXIgaSwgaGVhZGVyLCBsZXZlbF9mbGFncywgb2xkX2ZsdXNoLCBic3RhdGU7XFxuXFxuXFx0XFx0XFx0aWYgKGZsdXNoID4gWl9GSU5JU0ggfHwgZmx1c2ggPCAwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIV9zdHJtLm5leHRfb3V0IHx8ICghX3N0cm0ubmV4dF9pbiAmJiBfc3RybS5hdmFpbF9pbiAhPT0gMCkgfHwgKHN0YXR1cyA9PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT0gWl9GSU5JU0gpKSB7XFxuXFx0XFx0XFx0XFx0X3N0cm0ubXNnID0gel9lcnJtc2dbWl9ORUVEX0RJQ1QgLSAoWl9TVFJFQU1fRVJST1IpXTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChfc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX0JVRl9FUlJPUildO1xcblxcdFxcdFxcdFxcdHJldHVybiBaX0JVRl9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RybSA9IF9zdHJtOyAvLyBqdXN0IGluIGNhc2VcXG5cXHRcXHRcXHRvbGRfZmx1c2ggPSBsYXN0X2ZsdXNoO1xcblxcdFxcdFxcdGxhc3RfZmx1c2ggPSBmbHVzaDtcXG5cXG5cXHRcXHRcXHQvLyBXcml0ZSB0aGUgemxpYiBoZWFkZXJcXG5cXHRcXHRcXHRpZiAoc3RhdHVzID09IElOSVRfU1RBVEUpIHtcXG5cXHRcXHRcXHRcXHRoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgod19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XFxuXFx0XFx0XFx0XFx0bGV2ZWxfZmxhZ3MgPSAoKGxldmVsIC0gMSkgJiAweGZmKSA+PiAxO1xcblxcblxcdFxcdFxcdFxcdGlmIChsZXZlbF9mbGFncyA+IDMpXFxuXFx0XFx0XFx0XFx0XFx0bGV2ZWxfZmxhZ3MgPSAzO1xcblxcdFxcdFxcdFxcdGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cnN0YXJ0ICE9PSAwKVxcblxcdFxcdFxcdFxcdFxcdGhlYWRlciB8PSBQUkVTRVRfRElDVDtcXG5cXHRcXHRcXHRcXHRoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xcblxcblxcdFxcdFxcdFxcdHN0YXR1cyA9IEJVU1lfU1RBVEU7XFxuXFx0XFx0XFx0XFx0cHV0U2hvcnRNU0IoaGVhZGVyKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZVxcblxcdFxcdFxcdGlmICh0aGF0LnBlbmRpbmcgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXG5cXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhcXFwiIGF2YWlsX291dD09MFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdC8vIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcXG5cXHRcXHRcXHRcXHRcXHQvLyBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxcblxcdFxcdFxcdFxcdFxcdC8vIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxcblxcdFxcdFxcdFxcdFxcdC8vIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxcblxcdFxcdFxcdFxcdFxcdGxhc3RfZmx1c2ggPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlXFxuXFx0XFx0XFx0XFx0Ly8gY29uc2VjdXRpdmVcXG5cXHRcXHRcXHRcXHQvLyBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxcblxcdFxcdFxcdFxcdC8vIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRkZfRVJST1IuXFxuXFx0XFx0XFx0fSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIGZsdXNoIDw9IG9sZF9mbHVzaCAmJiBmbHVzaCAhPSBaX0ZJTklTSCkge1xcblxcdFxcdFxcdFxcdHN0cm0ubXNnID0gel9lcnJtc2dbWl9ORUVEX0RJQ1QgLSAoWl9CVUZfRVJST1IpXTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9CVUZfRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6XFxuXFx0XFx0XFx0aWYgKHN0YXR1cyA9PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdF9zdHJtLm1zZyA9IHpfZXJybXNnW1pfTkVFRF9ESUNUIC0gKFpfQlVGX0VSUk9SKV07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfQlVGX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXFxuXFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgbG9va2FoZWFkICE9PSAwIHx8IChmbHVzaCAhPSBaX05PX0ZMVVNIICYmIHN0YXR1cyAhPSBGSU5JU0hfU1RBVEUpKSB7XFxuXFx0XFx0XFx0XFx0YnN0YXRlID0gLTE7XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChjb25maWdfdGFibGVbbGV2ZWxdLmZ1bmMpIHtcXG5cXHRcXHRcXHRcXHRjYXNlIFNUT1JFRDpcXG5cXHRcXHRcXHRcXHRcXHRic3RhdGUgPSBkZWZsYXRlX3N0b3JlZChmbHVzaCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBGQVNUOlxcblxcdFxcdFxcdFxcdFxcdGJzdGF0ZSA9IGRlZmxhdGVfZmFzdChmbHVzaCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBTTE9XOlxcblxcdFxcdFxcdFxcdFxcdGJzdGF0ZSA9IGRlZmxhdGVfc2xvdyhmbHVzaCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGJzdGF0ZSA9PSBGaW5pc2hTdGFydGVkIHx8IGJzdGF0ZSA9PSBGaW5pc2hEb25lKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdHVzID0gRklOSVNIX1NUQVRFO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoYnN0YXRlID09IE5lZWRNb3JlIHx8IGJzdGF0ZSA9PSBGaW5pc2hTdGFydGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdF9mbHVzaCA9IC0xOyAvLyBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmVcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT09IDAsIHRoZSBuZXh0IGNhbGxcXG5cXHRcXHRcXHRcXHRcXHQvLyBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxcblxcdFxcdFxcdFxcdFxcdC8vIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxcblxcdFxcdFxcdFxcdFxcdC8vIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gb25lIGVtcHR5IGJsb2NrLlxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoYnN0YXRlID09IEJsb2NrRG9uZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChmbHVzaCA9PSBaX1BBUlRJQUxfRkxVU0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfdHJfYWxpZ24oKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgeyAvLyBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0hcXG5cXHRcXHRcXHRcXHRcXHRcXHRfdHJfc3RvcmVkX2Jsb2NrKDAsIDAsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGZsdXNoID09IFpfRlVMTF9GTFVTSCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHN0YXRlLmhlYWRbcy5oYXNoX3NpemUtMV09MDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgaGFzaF9zaXplLyotMSovOyBpKyspXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZm9yZ2V0IGhpc3RvcnlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRoZWFkW2ldID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHN0cm0uZmx1c2hfcGVuZGluZygpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RfZmx1c2ggPSAtMTsgLy8gYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGZsdXNoICE9IFpfRklOSVNIKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FTkQ7XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gWlN0cmVhbVxcblxcblxcdGZ1bmN0aW9uIFpTdHJlYW0oKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdHRoYXQubmV4dF9pbl9pbmRleCA9IDA7XFxuXFx0XFx0dGhhdC5uZXh0X291dF9pbmRleCA9IDA7XFxuXFx0XFx0Ly8gdGhhdC5uZXh0X2luOyAvLyBuZXh0IGlucHV0IGJ5dGVcXG5cXHRcXHR0aGF0LmF2YWlsX2luID0gMDsgLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBuZXh0X2luXFxuXFx0XFx0dGhhdC50b3RhbF9pbiA9IDA7IC8vIHRvdGFsIG5iIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyXFxuXFx0XFx0Ly8gdGhhdC5uZXh0X291dDsgLy8gbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlXFxuXFx0XFx0dGhhdC5hdmFpbF9vdXQgPSAwOyAvLyByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBuZXh0X291dFxcblxcdFxcdHRoYXQudG90YWxfb3V0ID0gMDsgLy8gdG90YWwgbmIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhclxcblxcdFxcdC8vIHRoYXQubXNnO1xcblxcdFxcdC8vIHRoYXQuZHN0YXRlO1xcblxcdH1cXG5cXG5cXHRaU3RyZWFtLnByb3RvdHlwZSA9IHtcXG5cXHRcXHRkZWZsYXRlSW5pdCA6IGZ1bmN0aW9uKGxldmVsLCBiaXRzKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdHRoYXQuZHN0YXRlID0gbmV3IERlZmxhdGUoKTtcXG5cXHRcXHRcXHRpZiAoIWJpdHMpXFxuXFx0XFx0XFx0XFx0Yml0cyA9IE1BWF9CSVRTO1xcblxcdFxcdFxcdHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlSW5pdCh0aGF0LCBsZXZlbCwgYml0cyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkZWZsYXRlIDogZnVuY3Rpb24oZmx1c2gpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmRzdGF0ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQuZHN0YXRlLmRlZmxhdGUodGhhdCwgZmx1c2gpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVmbGF0ZUVuZCA6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuZHN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR2YXIgcmV0ID0gdGhhdC5kc3RhdGUuZGVmbGF0ZUVuZCgpO1xcblxcdFxcdFxcdHRoYXQuZHN0YXRlID0gbnVsbDtcXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVmbGF0ZVBhcmFtcyA6IGZ1bmN0aW9uKGxldmVsLCBzdHJhdGVneSkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuZHN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZVBhcmFtcyh0aGF0LCBsZXZlbCwgc3RyYXRlZ3kpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVmbGF0ZVNldERpY3Rpb25hcnkgOiBmdW5jdGlvbihkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdGlmICghdGhhdC5kc3RhdGUpXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGF0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlXFxuXFx0XFx0Ly8gdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXFxuXFx0XFx0Ly8gdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcXG5cXHRcXHQvLyBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+bmV4dF9pbiBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cXG5cXHRcXHQvLyAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cXG5cXHRcXHRyZWFkX2J1ZiA6IGZ1bmN0aW9uKGJ1Ziwgc3RhcnQsIHNpemUpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0dmFyIGxlbiA9IHRoYXQuYXZhaWxfaW47XFxuXFx0XFx0XFx0aWYgKGxlbiA+IHNpemUpXFxuXFx0XFx0XFx0XFx0bGVuID0gc2l6ZTtcXG5cXHRcXHRcXHRpZiAobGVuID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdFxcdHRoYXQuYXZhaWxfaW4gLT0gbGVuO1xcblxcdFxcdFxcdGJ1Zi5zZXQodGhhdC5uZXh0X2luLnN1YmFycmF5KHRoYXQubmV4dF9pbl9pbmRleCwgdGhhdC5uZXh0X2luX2luZGV4ICsgbGVuKSwgc3RhcnQpO1xcblxcdFxcdFxcdHRoYXQubmV4dF9pbl9pbmRleCArPSBsZW47XFxuXFx0XFx0XFx0dGhhdC50b3RhbF9pbiArPSBsZW47XFxuXFx0XFx0XFx0cmV0dXJuIGxlbjtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcXG5cXHRcXHQvLyB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XFxuXFx0XFx0Ly8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfb3V0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxcblxcdFxcdC8vIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cXG5cXHRcXHRmbHVzaF9wZW5kaW5nIDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdHZhciBsZW4gPSB0aGF0LmRzdGF0ZS5wZW5kaW5nO1xcblxcblxcdFxcdFxcdGlmIChsZW4gPiB0aGF0LmF2YWlsX291dClcXG5cXHRcXHRcXHRcXHRsZW4gPSB0aGF0LmF2YWlsX291dDtcXG5cXHRcXHRcXHRpZiAobGVuID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHQvLyBpZiAodGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoIDw9IHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0IHx8IHRoYXQubmV4dF9vdXQubGVuZ3RoIDw9IHRoYXQubmV4dF9vdXRfaW5kZXhcXG5cXHRcXHRcXHQvLyB8fCB0aGF0LmRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGggPCAodGhhdC5kc3RhdGUucGVuZGluZ19vdXQgKyBsZW4pIHx8IHRoYXQubmV4dF9vdXQubGVuZ3RoIDwgKHRoYXQubmV4dF9vdXRfaW5kZXggK1xcblxcdFxcdFxcdC8vIGxlbikpIHtcXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyh0aGF0LmRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGggKyBcXFwiLCBcXFwiICsgdGhhdC5kc3RhdGUucGVuZGluZ19vdXQgKyBcXFwiLCBcXFwiICsgdGhhdC5uZXh0X291dC5sZW5ndGggKyBcXFwiLCBcXFwiICtcXG5cXHRcXHRcXHQvLyB0aGF0Lm5leHRfb3V0X2luZGV4ICsgXFxcIiwgXFxcIiArIGxlbik7XFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcImF2YWlsX291dD1cXFwiICsgdGhhdC5hdmFpbF9vdXQpO1xcblxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHR0aGF0Lm5leHRfb3V0LnNldCh0aGF0LmRzdGF0ZS5wZW5kaW5nX2J1Zi5zdWJhcnJheSh0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCwgdGhhdC5kc3RhdGUucGVuZGluZ19vdXQgKyBsZW4pLCB0aGF0Lm5leHRfb3V0X2luZGV4KTtcXG5cXG5cXHRcXHRcXHR0aGF0Lm5leHRfb3V0X2luZGV4ICs9IGxlbjtcXG5cXHRcXHRcXHR0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCArPSBsZW47XFxuXFx0XFx0XFx0dGhhdC50b3RhbF9vdXQgKz0gbGVuO1xcblxcdFxcdFxcdHRoYXQuYXZhaWxfb3V0IC09IGxlbjtcXG5cXHRcXHRcXHR0aGF0LmRzdGF0ZS5wZW5kaW5nIC09IGxlbjtcXG5cXHRcXHRcXHRpZiAodGhhdC5kc3RhdGUucGVuZGluZyA9PT0gMCkge1xcblxcdFxcdFxcdFxcdHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0Ly8gRGVmbGF0ZXJcXG5cXG5cXHRmdW5jdGlvbiBEZWZsYXRlcihvcHRpb25zKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdHZhciB6ID0gbmV3IFpTdHJlYW0oKTtcXG5cXHRcXHR2YXIgYnVmc2l6ZSA9IDUxMjtcXG5cXHRcXHR2YXIgZmx1c2ggPSBaX05PX0ZMVVNIO1xcblxcdFxcdHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZzaXplKTtcXG5cXHRcXHR2YXIgbGV2ZWwgPSBvcHRpb25zID8gb3B0aW9ucy5sZXZlbCA6IFpfREVGQVVMVF9DT01QUkVTU0lPTjtcXG5cXHRcXHRpZiAodHlwZW9mIGxldmVsID09IFxcXCJ1bmRlZmluZWRcXFwiKVxcblxcdFxcdFxcdGxldmVsID0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xcblxcdFxcdHouZGVmbGF0ZUluaXQobGV2ZWwpO1xcblxcdFxcdHoubmV4dF9vdXQgPSBidWY7XFxuXFxuXFx0XFx0dGhhdC5hcHBlbmQgPSBmdW5jdGlvbihkYXRhLCBvbnByb2dyZXNzKSB7XFxuXFx0XFx0XFx0dmFyIGVyciwgYnVmZmVycyA9IFtdLCBsYXN0SW5kZXggPSAwLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXG5cXHRcXHRcXHRpZiAoIWRhdGEubGVuZ3RoKVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSAwO1xcblxcdFxcdFxcdHoubmV4dF9pbiA9IGRhdGE7XFxuXFx0XFx0XFx0ei5hdmFpbF9pbiA9IGRhdGEubGVuZ3RoO1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHR6Lm5leHRfb3V0X2luZGV4ID0gMDtcXG5cXHRcXHRcXHRcXHR6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxuXFx0XFx0XFx0XFx0ZXJyID0gei5kZWZsYXRlKGZsdXNoKTtcXG5cXHRcXHRcXHRcXHRpZiAoZXJyICE9IFpfT0spXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJkZWZsYXRpbmc6IFxcXCIgKyB6Lm1zZyk7XFxuXFx0XFx0XFx0XFx0aWYgKHoubmV4dF9vdXRfaW5kZXgpXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHoubmV4dF9vdXRfaW5kZXggPT0gYnVmc2l6ZSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XFxuXFx0XFx0XFx0XFx0XFx0ZWxzZVxcblxcdFxcdFxcdFxcdFxcdFxcdGJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShidWYuc3ViYXJyYXkoMCwgei5uZXh0X291dF9pbmRleCkpKTtcXG5cXHRcXHRcXHRcXHRidWZmZXJTaXplICs9IHoubmV4dF9vdXRfaW5kZXg7XFxuXFx0XFx0XFx0XFx0aWYgKG9ucHJvZ3Jlc3MgJiYgei5uZXh0X2luX2luZGV4ID4gMCAmJiB6Lm5leHRfaW5faW5kZXggIT0gbGFzdEluZGV4KSB7XFxuXFx0XFx0XFx0XFx0XFx0b25wcm9ncmVzcyh6Lm5leHRfaW5faW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdGxhc3RJbmRleCA9IHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSB3aGlsZSAoei5hdmFpbF9pbiA+IDAgfHwgei5hdmFpbF9vdXQgPT09IDApO1xcblxcdFxcdFxcdGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyU2l6ZSk7XFxuXFx0XFx0XFx0YnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XFxuXFx0XFx0XFx0XFx0YXJyYXkuc2V0KGNodW5rLCBidWZmZXJJbmRleCk7XFxuXFx0XFx0XFx0XFx0YnVmZmVySW5kZXggKz0gY2h1bmsubGVuZ3RoO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXHRcXHR9O1xcblxcdFxcdHRoYXQuZmx1c2ggPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgZXJyLCBidWZmZXJzID0gW10sIGJ1ZmZlckluZGV4ID0gMCwgYnVmZmVyU2l6ZSA9IDAsIGFycmF5O1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHR6Lm5leHRfb3V0X2luZGV4ID0gMDtcXG5cXHRcXHRcXHRcXHR6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxuXFx0XFx0XFx0XFx0ZXJyID0gei5kZWZsYXRlKFpfRklOSVNIKTtcXG5cXHRcXHRcXHRcXHRpZiAoZXJyICE9IFpfU1RSRUFNX0VORCAmJiBlcnIgIT0gWl9PSylcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcImRlZmxhdGluZzogXFxcIiArIHoubXNnKTtcXG5cXHRcXHRcXHRcXHRpZiAoYnVmc2l6ZSAtIHouYXZhaWxfb3V0ID4gMClcXG5cXHRcXHRcXHRcXHRcXHRidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmLnN1YmFycmF5KDAsIHoubmV4dF9vdXRfaW5kZXgpKSk7XFxuXFx0XFx0XFx0XFx0YnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xcblxcdFxcdFxcdH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcXG5cXHRcXHRcXHR6LmRlZmxhdGVFbmQoKTtcXG5cXHRcXHRcXHRhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xcblxcdFxcdFxcdGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xcblxcdFxcdFxcdFxcdGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcblxcdFxcdFxcdFxcdGJ1ZmZlckluZGV4ICs9IGNodW5rLmxlbmd0aDtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gJ3ppcCcgbWF5IG5vdCBiZSBkZWZpbmVkIGluIHotd29ya2VyIGFuZCBzb21lIHRlc3RzXFxuXFx0dmFyIGVudiA9IGdsb2JhbC56aXAgfHwgZ2xvYmFsO1xcblxcdGVudi5EZWZsYXRlciA9IGVudi5fanpsaWJfRGVmbGF0ZXIgPSBEZWZsYXRlcjtcXG59KSh0aGlzKTtcXG5cIildLFxuICBpbmZsYXRlcjogW3pXb3JrZXIsIGNyZWF0ZVVybChcIi8qXFxuIENvcHlyaWdodCAoYykgMjAxMyBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG5cXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcblxcbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IFxcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcbiAqL1xcblxcbi8qXFxuICogVGhpcyBwcm9ncmFtIGlzIGJhc2VkIG9uIEpabGliIDEuMC4yIHltbmssIEpDcmFmdCxJbmMuXFxuICogSlpsaWIgaXMgYmFzZWQgb24gemxpYi0xLjEuMywgc28gYWxsIGNyZWRpdCBzaG91bGQgZ28gYXV0aG9yc1xcbiAqIEplYW4tbG91cCBHYWlsbHkoamxvdXBAZ3ppcC5vcmcpIGFuZCBNYXJrIEFkbGVyKG1hZGxlckBhbHVtbmkuY2FsdGVjaC5lZHUpXFxuICogYW5kIGNvbnRyaWJ1dG9ycyBvZiB6bGliLlxcbiAqL1xcblxcbihmdW5jdGlvbihnbG9iYWwpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0Ly8gR2xvYmFsXFxuXFx0dmFyIE1BWF9CSVRTID0gMTU7XFxuXFxuXFx0dmFyIFpfT0sgPSAwO1xcblxcdHZhciBaX1NUUkVBTV9FTkQgPSAxO1xcblxcdHZhciBaX05FRURfRElDVCA9IDI7XFxuXFx0dmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7XFxuXFx0dmFyIFpfREFUQV9FUlJPUiA9IC0zO1xcblxcdHZhciBaX01FTV9FUlJPUiA9IC00O1xcblxcdHZhciBaX0JVRl9FUlJPUiA9IC01O1xcblxcblxcdHZhciBpbmZsYXRlX21hc2sgPSBbIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDEsIDB4MDAwMDAwMDMsIDB4MDAwMDAwMDcsIDB4MDAwMDAwMGYsIDB4MDAwMDAwMWYsIDB4MDAwMDAwM2YsIDB4MDAwMDAwN2YsIDB4MDAwMDAwZmYsIDB4MDAwMDAxZmYsIDB4MDAwMDAzZmYsXFxuXFx0XFx0XFx0MHgwMDAwMDdmZiwgMHgwMDAwMGZmZiwgMHgwMDAwMWZmZiwgMHgwMDAwM2ZmZiwgMHgwMDAwN2ZmZiwgMHgwMDAwZmZmZiBdO1xcblxcblxcdHZhciBNQU5ZID0gMTQ0MDtcXG5cXG5cXHQvLyBKWmxpYiB2ZXJzaW9uIDogXFxcIjEuMC4yXFxcIlxcblxcdHZhciBaX05PX0ZMVVNIID0gMDtcXG5cXHR2YXIgWl9GSU5JU0ggPSA0O1xcblxcblxcdC8vIEluZlRyZWVcXG5cXHR2YXIgZml4ZWRfYmwgPSA5O1xcblxcdHZhciBmaXhlZF9iZCA9IDU7XFxuXFxuXFx0dmFyIGZpeGVkX3RsID0gWyA5NiwgNywgMjU2LCAwLCA4LCA4MCwgMCwgOCwgMTYsIDg0LCA4LCAxMTUsIDgyLCA3LCAzMSwgMCwgOCwgMTEyLCAwLCA4LCA0OCwgMCwgOSwgMTkyLCA4MCwgNywgMTAsIDAsIDgsIDk2LCAwLCA4LCAzMiwgMCwgOSwgMTYwLCAwLCA4LCAwLFxcblxcdFxcdFxcdDAsIDgsIDEyOCwgMCwgOCwgNjQsIDAsIDksIDIyNCwgODAsIDcsIDYsIDAsIDgsIDg4LCAwLCA4LCAyNCwgMCwgOSwgMTQ0LCA4MywgNywgNTksIDAsIDgsIDEyMCwgMCwgOCwgNTYsIDAsIDksIDIwOCwgODEsIDcsIDE3LCAwLCA4LCAxMDQsIDAsIDgsIDQwLFxcblxcdFxcdFxcdDAsIDksIDE3NiwgMCwgOCwgOCwgMCwgOCwgMTM2LCAwLCA4LCA3MiwgMCwgOSwgMjQwLCA4MCwgNywgNCwgMCwgOCwgODQsIDAsIDgsIDIwLCA4NSwgOCwgMjI3LCA4MywgNywgNDMsIDAsIDgsIDExNiwgMCwgOCwgNTIsIDAsIDksIDIwMCwgODEsIDcsIDEzLFxcblxcdFxcdFxcdDAsIDgsIDEwMCwgMCwgOCwgMzYsIDAsIDksIDE2OCwgMCwgOCwgNCwgMCwgOCwgMTMyLCAwLCA4LCA2OCwgMCwgOSwgMjMyLCA4MCwgNywgOCwgMCwgOCwgOTIsIDAsIDgsIDI4LCAwLCA5LCAxNTIsIDg0LCA3LCA4MywgMCwgOCwgMTI0LCAwLCA4LCA2MCxcXG5cXHRcXHRcXHQwLCA5LCAyMTYsIDgyLCA3LCAyMywgMCwgOCwgMTA4LCAwLCA4LCA0NCwgMCwgOSwgMTg0LCAwLCA4LCAxMiwgMCwgOCwgMTQwLCAwLCA4LCA3NiwgMCwgOSwgMjQ4LCA4MCwgNywgMywgMCwgOCwgODIsIDAsIDgsIDE4LCA4NSwgOCwgMTYzLCA4MywgNyxcXG5cXHRcXHRcXHQzNSwgMCwgOCwgMTE0LCAwLCA4LCA1MCwgMCwgOSwgMTk2LCA4MSwgNywgMTEsIDAsIDgsIDk4LCAwLCA4LCAzNCwgMCwgOSwgMTY0LCAwLCA4LCAyLCAwLCA4LCAxMzAsIDAsIDgsIDY2LCAwLCA5LCAyMjgsIDgwLCA3LCA3LCAwLCA4LCA5MCwgMCwgOCxcXG5cXHRcXHRcXHQyNiwgMCwgOSwgMTQ4LCA4NCwgNywgNjcsIDAsIDgsIDEyMiwgMCwgOCwgNTgsIDAsIDksIDIxMiwgODIsIDcsIDE5LCAwLCA4LCAxMDYsIDAsIDgsIDQyLCAwLCA5LCAxODAsIDAsIDgsIDEwLCAwLCA4LCAxMzgsIDAsIDgsIDc0LCAwLCA5LCAyNDQsIDgwLFxcblxcdFxcdFxcdDcsIDUsIDAsIDgsIDg2LCAwLCA4LCAyMiwgMTkyLCA4LCAwLCA4MywgNywgNTEsIDAsIDgsIDExOCwgMCwgOCwgNTQsIDAsIDksIDIwNCwgODEsIDcsIDE1LCAwLCA4LCAxMDIsIDAsIDgsIDM4LCAwLCA5LCAxNzIsIDAsIDgsIDYsIDAsIDgsIDEzNCwgMCxcXG5cXHRcXHRcXHQ4LCA3MCwgMCwgOSwgMjM2LCA4MCwgNywgOSwgMCwgOCwgOTQsIDAsIDgsIDMwLCAwLCA5LCAxNTYsIDg0LCA3LCA5OSwgMCwgOCwgMTI2LCAwLCA4LCA2MiwgMCwgOSwgMjIwLCA4MiwgNywgMjcsIDAsIDgsIDExMCwgMCwgOCwgNDYsIDAsIDksIDE4OCwgMCxcXG5cXHRcXHRcXHQ4LCAxNCwgMCwgOCwgMTQyLCAwLCA4LCA3OCwgMCwgOSwgMjUyLCA5NiwgNywgMjU2LCAwLCA4LCA4MSwgMCwgOCwgMTcsIDg1LCA4LCAxMzEsIDgyLCA3LCAzMSwgMCwgOCwgMTEzLCAwLCA4LCA0OSwgMCwgOSwgMTk0LCA4MCwgNywgMTAsIDAsIDgsIDk3LFxcblxcdFxcdFxcdDAsIDgsIDMzLCAwLCA5LCAxNjIsIDAsIDgsIDEsIDAsIDgsIDEyOSwgMCwgOCwgNjUsIDAsIDksIDIyNiwgODAsIDcsIDYsIDAsIDgsIDg5LCAwLCA4LCAyNSwgMCwgOSwgMTQ2LCA4MywgNywgNTksIDAsIDgsIDEyMSwgMCwgOCwgNTcsIDAsIDksIDIxMCxcXG5cXHRcXHRcXHQ4MSwgNywgMTcsIDAsIDgsIDEwNSwgMCwgOCwgNDEsIDAsIDksIDE3OCwgMCwgOCwgOSwgMCwgOCwgMTM3LCAwLCA4LCA3MywgMCwgOSwgMjQyLCA4MCwgNywgNCwgMCwgOCwgODUsIDAsIDgsIDIxLCA4MCwgOCwgMjU4LCA4MywgNywgNDMsIDAsIDgsIDExNyxcXG5cXHRcXHRcXHQwLCA4LCA1MywgMCwgOSwgMjAyLCA4MSwgNywgMTMsIDAsIDgsIDEwMSwgMCwgOCwgMzcsIDAsIDksIDE3MCwgMCwgOCwgNSwgMCwgOCwgMTMzLCAwLCA4LCA2OSwgMCwgOSwgMjM0LCA4MCwgNywgOCwgMCwgOCwgOTMsIDAsIDgsIDI5LCAwLCA5LCAxNTQsXFxuXFx0XFx0XFx0ODQsIDcsIDgzLCAwLCA4LCAxMjUsIDAsIDgsIDYxLCAwLCA5LCAyMTgsIDgyLCA3LCAyMywgMCwgOCwgMTA5LCAwLCA4LCA0NSwgMCwgOSwgMTg2LCAwLCA4LCAxMywgMCwgOCwgMTQxLCAwLCA4LCA3NywgMCwgOSwgMjUwLCA4MCwgNywgMywgMCwgOCwgODMsXFxuXFx0XFx0XFx0MCwgOCwgMTksIDg1LCA4LCAxOTUsIDgzLCA3LCAzNSwgMCwgOCwgMTE1LCAwLCA4LCA1MSwgMCwgOSwgMTk4LCA4MSwgNywgMTEsIDAsIDgsIDk5LCAwLCA4LCAzNSwgMCwgOSwgMTY2LCAwLCA4LCAzLCAwLCA4LCAxMzEsIDAsIDgsIDY3LCAwLCA5LCAyMzAsXFxuXFx0XFx0XFx0ODAsIDcsIDcsIDAsIDgsIDkxLCAwLCA4LCAyNywgMCwgOSwgMTUwLCA4NCwgNywgNjcsIDAsIDgsIDEyMywgMCwgOCwgNTksIDAsIDksIDIxNCwgODIsIDcsIDE5LCAwLCA4LCAxMDcsIDAsIDgsIDQzLCAwLCA5LCAxODIsIDAsIDgsIDExLCAwLCA4LCAxMzksXFxuXFx0XFx0XFx0MCwgOCwgNzUsIDAsIDksIDI0NiwgODAsIDcsIDUsIDAsIDgsIDg3LCAwLCA4LCAyMywgMTkyLCA4LCAwLCA4MywgNywgNTEsIDAsIDgsIDExOSwgMCwgOCwgNTUsIDAsIDksIDIwNiwgODEsIDcsIDE1LCAwLCA4LCAxMDMsIDAsIDgsIDM5LCAwLCA5LCAxNzQsXFxuXFx0XFx0XFx0MCwgOCwgNywgMCwgOCwgMTM1LCAwLCA4LCA3MSwgMCwgOSwgMjM4LCA4MCwgNywgOSwgMCwgOCwgOTUsIDAsIDgsIDMxLCAwLCA5LCAxNTgsIDg0LCA3LCA5OSwgMCwgOCwgMTI3LCAwLCA4LCA2MywgMCwgOSwgMjIyLCA4MiwgNywgMjcsIDAsIDgsIDExMSxcXG5cXHRcXHRcXHQwLCA4LCA0NywgMCwgOSwgMTkwLCAwLCA4LCAxNSwgMCwgOCwgMTQzLCAwLCA4LCA3OSwgMCwgOSwgMjU0LCA5NiwgNywgMjU2LCAwLCA4LCA4MCwgMCwgOCwgMTYsIDg0LCA4LCAxMTUsIDgyLCA3LCAzMSwgMCwgOCwgMTEyLCAwLCA4LCA0OCwgMCwgOSxcXG5cXHRcXHRcXHQxOTMsIDgwLCA3LCAxMCwgMCwgOCwgOTYsIDAsIDgsIDMyLCAwLCA5LCAxNjEsIDAsIDgsIDAsIDAsIDgsIDEyOCwgMCwgOCwgNjQsIDAsIDksIDIyNSwgODAsIDcsIDYsIDAsIDgsIDg4LCAwLCA4LCAyNCwgMCwgOSwgMTQ1LCA4MywgNywgNTksIDAsIDgsXFxuXFx0XFx0XFx0MTIwLCAwLCA4LCA1NiwgMCwgOSwgMjA5LCA4MSwgNywgMTcsIDAsIDgsIDEwNCwgMCwgOCwgNDAsIDAsIDksIDE3NywgMCwgOCwgOCwgMCwgOCwgMTM2LCAwLCA4LCA3MiwgMCwgOSwgMjQxLCA4MCwgNywgNCwgMCwgOCwgODQsIDAsIDgsIDIwLCA4NSwgOCxcXG5cXHRcXHRcXHQyMjcsIDgzLCA3LCA0MywgMCwgOCwgMTE2LCAwLCA4LCA1MiwgMCwgOSwgMjAxLCA4MSwgNywgMTMsIDAsIDgsIDEwMCwgMCwgOCwgMzYsIDAsIDksIDE2OSwgMCwgOCwgNCwgMCwgOCwgMTMyLCAwLCA4LCA2OCwgMCwgOSwgMjMzLCA4MCwgNywgOCwgMCwgOCxcXG5cXHRcXHRcXHQ5MiwgMCwgOCwgMjgsIDAsIDksIDE1MywgODQsIDcsIDgzLCAwLCA4LCAxMjQsIDAsIDgsIDYwLCAwLCA5LCAyMTcsIDgyLCA3LCAyMywgMCwgOCwgMTA4LCAwLCA4LCA0NCwgMCwgOSwgMTg1LCAwLCA4LCAxMiwgMCwgOCwgMTQwLCAwLCA4LCA3NiwgMCwgOSxcXG5cXHRcXHRcXHQyNDksIDgwLCA3LCAzLCAwLCA4LCA4MiwgMCwgOCwgMTgsIDg1LCA4LCAxNjMsIDgzLCA3LCAzNSwgMCwgOCwgMTE0LCAwLCA4LCA1MCwgMCwgOSwgMTk3LCA4MSwgNywgMTEsIDAsIDgsIDk4LCAwLCA4LCAzNCwgMCwgOSwgMTY1LCAwLCA4LCAyLCAwLCA4LFxcblxcdFxcdFxcdDEzMCwgMCwgOCwgNjYsIDAsIDksIDIyOSwgODAsIDcsIDcsIDAsIDgsIDkwLCAwLCA4LCAyNiwgMCwgOSwgMTQ5LCA4NCwgNywgNjcsIDAsIDgsIDEyMiwgMCwgOCwgNTgsIDAsIDksIDIxMywgODIsIDcsIDE5LCAwLCA4LCAxMDYsIDAsIDgsIDQyLCAwLCA5LFxcblxcdFxcdFxcdDE4MSwgMCwgOCwgMTAsIDAsIDgsIDEzOCwgMCwgOCwgNzQsIDAsIDksIDI0NSwgODAsIDcsIDUsIDAsIDgsIDg2LCAwLCA4LCAyMiwgMTkyLCA4LCAwLCA4MywgNywgNTEsIDAsIDgsIDExOCwgMCwgOCwgNTQsIDAsIDksIDIwNSwgODEsIDcsIDE1LCAwLCA4LFxcblxcdFxcdFxcdDEwMiwgMCwgOCwgMzgsIDAsIDksIDE3MywgMCwgOCwgNiwgMCwgOCwgMTM0LCAwLCA4LCA3MCwgMCwgOSwgMjM3LCA4MCwgNywgOSwgMCwgOCwgOTQsIDAsIDgsIDMwLCAwLCA5LCAxNTcsIDg0LCA3LCA5OSwgMCwgOCwgMTI2LCAwLCA4LCA2MiwgMCwgOSxcXG5cXHRcXHRcXHQyMjEsIDgyLCA3LCAyNywgMCwgOCwgMTEwLCAwLCA4LCA0NiwgMCwgOSwgMTg5LCAwLCA4LCAxNCwgMCwgOCwgMTQyLCAwLCA4LCA3OCwgMCwgOSwgMjUzLCA5NiwgNywgMjU2LCAwLCA4LCA4MSwgMCwgOCwgMTcsIDg1LCA4LCAxMzEsIDgyLCA3LCAzMSwgMCxcXG5cXHRcXHRcXHQ4LCAxMTMsIDAsIDgsIDQ5LCAwLCA5LCAxOTUsIDgwLCA3LCAxMCwgMCwgOCwgOTcsIDAsIDgsIDMzLCAwLCA5LCAxNjMsIDAsIDgsIDEsIDAsIDgsIDEyOSwgMCwgOCwgNjUsIDAsIDksIDIyNywgODAsIDcsIDYsIDAsIDgsIDg5LCAwLCA4LCAyNSwgMCwgOSxcXG5cXHRcXHRcXHQxNDcsIDgzLCA3LCA1OSwgMCwgOCwgMTIxLCAwLCA4LCA1NywgMCwgOSwgMjExLCA4MSwgNywgMTcsIDAsIDgsIDEwNSwgMCwgOCwgNDEsIDAsIDksIDE3OSwgMCwgOCwgOSwgMCwgOCwgMTM3LCAwLCA4LCA3MywgMCwgOSwgMjQzLCA4MCwgNywgNCwgMCwgOCxcXG5cXHRcXHRcXHQ4NSwgMCwgOCwgMjEsIDgwLCA4LCAyNTgsIDgzLCA3LCA0MywgMCwgOCwgMTE3LCAwLCA4LCA1MywgMCwgOSwgMjAzLCA4MSwgNywgMTMsIDAsIDgsIDEwMSwgMCwgOCwgMzcsIDAsIDksIDE3MSwgMCwgOCwgNSwgMCwgOCwgMTMzLCAwLCA4LCA2OSwgMCwgOSxcXG5cXHRcXHRcXHQyMzUsIDgwLCA3LCA4LCAwLCA4LCA5MywgMCwgOCwgMjksIDAsIDksIDE1NSwgODQsIDcsIDgzLCAwLCA4LCAxMjUsIDAsIDgsIDYxLCAwLCA5LCAyMTksIDgyLCA3LCAyMywgMCwgOCwgMTA5LCAwLCA4LCA0NSwgMCwgOSwgMTg3LCAwLCA4LCAxMywgMCwgOCxcXG5cXHRcXHRcXHQxNDEsIDAsIDgsIDc3LCAwLCA5LCAyNTEsIDgwLCA3LCAzLCAwLCA4LCA4MywgMCwgOCwgMTksIDg1LCA4LCAxOTUsIDgzLCA3LCAzNSwgMCwgOCwgMTE1LCAwLCA4LCA1MSwgMCwgOSwgMTk5LCA4MSwgNywgMTEsIDAsIDgsIDk5LCAwLCA4LCAzNSwgMCwgOSxcXG5cXHRcXHRcXHQxNjcsIDAsIDgsIDMsIDAsIDgsIDEzMSwgMCwgOCwgNjcsIDAsIDksIDIzMSwgODAsIDcsIDcsIDAsIDgsIDkxLCAwLCA4LCAyNywgMCwgOSwgMTUxLCA4NCwgNywgNjcsIDAsIDgsIDEyMywgMCwgOCwgNTksIDAsIDksIDIxNSwgODIsIDcsIDE5LCAwLCA4LFxcblxcdFxcdFxcdDEwNywgMCwgOCwgNDMsIDAsIDksIDE4MywgMCwgOCwgMTEsIDAsIDgsIDEzOSwgMCwgOCwgNzUsIDAsIDksIDI0NywgODAsIDcsIDUsIDAsIDgsIDg3LCAwLCA4LCAyMywgMTkyLCA4LCAwLCA4MywgNywgNTEsIDAsIDgsIDExOSwgMCwgOCwgNTUsIDAsIDksXFxuXFx0XFx0XFx0MjA3LCA4MSwgNywgMTUsIDAsIDgsIDEwMywgMCwgOCwgMzksIDAsIDksIDE3NSwgMCwgOCwgNywgMCwgOCwgMTM1LCAwLCA4LCA3MSwgMCwgOSwgMjM5LCA4MCwgNywgOSwgMCwgOCwgOTUsIDAsIDgsIDMxLCAwLCA5LCAxNTksIDg0LCA3LCA5OSwgMCwgOCxcXG5cXHRcXHRcXHQxMjcsIDAsIDgsIDYzLCAwLCA5LCAyMjMsIDgyLCA3LCAyNywgMCwgOCwgMTExLCAwLCA4LCA0NywgMCwgOSwgMTkxLCAwLCA4LCAxNSwgMCwgOCwgMTQzLCAwLCA4LCA3OSwgMCwgOSwgMjU1IF07XFxuXFx0dmFyIGZpeGVkX3RkID0gWyA4MCwgNSwgMSwgODcsIDUsIDI1NywgODMsIDUsIDE3LCA5MSwgNSwgNDA5NywgODEsIDUsIDUsIDg5LCA1LCAxMDI1LCA4NSwgNSwgNjUsIDkzLCA1LCAxNjM4NSwgODAsIDUsIDMsIDg4LCA1LCA1MTMsIDg0LCA1LCAzMywgOTIsIDUsXFxuXFx0XFx0XFx0ODE5MywgODIsIDUsIDksIDkwLCA1LCAyMDQ5LCA4NiwgNSwgMTI5LCAxOTIsIDUsIDI0NTc3LCA4MCwgNSwgMiwgODcsIDUsIDM4NSwgODMsIDUsIDI1LCA5MSwgNSwgNjE0NSwgODEsIDUsIDcsIDg5LCA1LCAxNTM3LCA4NSwgNSwgOTcsIDkzLCA1LFxcblxcdFxcdFxcdDI0NTc3LCA4MCwgNSwgNCwgODgsIDUsIDc2OSwgODQsIDUsIDQ5LCA5MiwgNSwgMTIyODksIDgyLCA1LCAxMywgOTAsIDUsIDMwNzMsIDg2LCA1LCAxOTMsIDE5MiwgNSwgMjQ1NzcgXTtcXG5cXG5cXHQvLyBUYWJsZXMgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxcblxcdHZhciBjcGxlbnMgPSBbIC8vIENvcHkgbGVuZ3RocyBmb3IgbGl0ZXJhbCBjb2RlcyAyNTcuLjI4NVxcblxcdDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwIF07XFxuXFxuXFx0Ly8gc2VlIG5vdGUgIzEzIGFib3ZlIGFib3V0IDI1OFxcblxcdHZhciBjcGxleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcXG5cXHQwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAxMTIsIDExMiAvLyAxMTI9PWludmFsaWRcXG5cXHRdO1xcblxcblxcdHZhciBjcGRpc3QgPSBbIC8vIENvcHkgb2Zmc2V0cyBmb3IgZGlzdGFuY2UgY29kZXMgMC4uMjlcXG5cXHQxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSwgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NyBdO1xcblxcblxcdHZhciBjcGRleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVzXFxuXFx0MCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzIF07XFxuXFxuXFx0Ly8gSWYgQk1BWCBuZWVkcyB0byBiZSBsYXJnZXIgdGhhbiAxNiwgdGhlbiBoIGFuZCB4W10gc2hvdWxkIGJlIHVMb25nLlxcblxcdHZhciBCTUFYID0gMTU7IC8vIG1heGltdW0gYml0IGxlbmd0aCBvZiBhbnkgY29kZVxcblxcblxcdGZ1bmN0aW9uIEluZlRyZWUoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdHZhciBobjsgLy8gaHVmdHMgdXNlZCBpbiBzcGFjZVxcblxcdFxcdHZhciB2OyAvLyB3b3JrIGFyZWEgZm9yIGh1ZnRfYnVpbGRcXG5cXHRcXHR2YXIgYzsgLy8gYml0IGxlbmd0aCBjb3VudCB0YWJsZVxcblxcdFxcdHZhciByOyAvLyB0YWJsZSBlbnRyeSBmb3Igc3RydWN0dXJlIGFzc2lnbm1lbnRcXG5cXHRcXHR2YXIgdTsgLy8gdGFibGUgc3RhY2tcXG5cXHRcXHR2YXIgeDsgLy8gYml0IG9mZnNldHMsIHRoZW4gY29kZSBzdGFja1xcblxcblxcdFxcdGZ1bmN0aW9uIGh1ZnRfYnVpbGQoYiwgLy8gY29kZSBsZW5ndGhzIGluIGJpdHMgKGFsbCBhc3N1bWVkIDw9XFxuXFx0XFx0Ly8gQk1BWClcXG5cXHRcXHRiaW5kZXgsIG4sIC8vIG51bWJlciBvZiBjb2RlcyAoYXNzdW1lZCA8PSAyODgpXFxuXFx0XFx0cywgLy8gbnVtYmVyIG9mIHNpbXBsZS12YWx1ZWQgY29kZXMgKDAuLnMtMSlcXG5cXHRcXHRkLCAvLyBsaXN0IG9mIGJhc2UgdmFsdWVzIGZvciBub24tc2ltcGxlIGNvZGVzXFxuXFx0XFx0ZSwgLy8gbGlzdCBvZiBleHRyYSBiaXRzIGZvciBub24tc2ltcGxlIGNvZGVzXFxuXFx0XFx0dCwgLy8gcmVzdWx0OiBzdGFydGluZyB0YWJsZVxcblxcdFxcdG0sIC8vIG1heGltdW0gbG9va3VwIGJpdHMsIHJldHVybnMgYWN0dWFsXFxuXFx0XFx0aHAsLy8gc3BhY2UgZm9yIHRyZWVzXFxuXFx0XFx0aG4sLy8gaHVmdHMgdXNlZCBpbiBzcGFjZVxcblxcdFxcdHYgLy8gd29ya2luZyBhcmVhOiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aFxcblxcdFxcdCkge1xcblxcdFxcdFxcdC8vIEdpdmVuIGEgbGlzdCBvZiBjb2RlIGxlbmd0aHMgYW5kIGEgbWF4aW11bSB0YWJsZSBzaXplLCBtYWtlIGEgc2V0IG9mXFxuXFx0XFx0XFx0Ly8gdGFibGVzIHRvIGRlY29kZSB0aGF0IHNldCBvZiBjb2Rlcy4gUmV0dXJuIFpfT0sgb24gc3VjY2VzcyxcXG5cXHRcXHRcXHQvLyBaX0JVRl9FUlJPUlxcblxcdFxcdFxcdC8vIGlmIHRoZSBnaXZlbiBjb2RlIHNldCBpcyBpbmNvbXBsZXRlICh0aGUgdGFibGVzIGFyZSBzdGlsbCBidWlsdCBpblxcblxcdFxcdFxcdC8vIHRoaXNcXG5cXHRcXHRcXHQvLyBjYXNlKSwgWl9EQVRBX0VSUk9SIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkIChhbiBvdmVyLXN1YnNjcmliZWQgc2V0XFxuXFx0XFx0XFx0Ly8gb2ZcXG5cXHRcXHRcXHQvLyBsZW5ndGhzKSwgb3IgWl9NRU1fRVJST1IgaWYgbm90IGVub3VnaCBtZW1vcnkuXFxuXFxuXFx0XFx0XFx0dmFyIGE7IC8vIGNvdW50ZXIgZm9yIGNvZGVzIG9mIGxlbmd0aCBrXFxuXFx0XFx0XFx0dmFyIGY7IC8vIGkgcmVwZWF0cyBpbiB0YWJsZSBldmVyeSBmIGVudHJpZXNcXG5cXHRcXHRcXHR2YXIgZzsgLy8gbWF4aW11bSBjb2RlIGxlbmd0aFxcblxcdFxcdFxcdHZhciBoOyAvLyB0YWJsZSBsZXZlbFxcblxcdFxcdFxcdHZhciBpOyAvLyBjb3VudGVyLCBjdXJyZW50IGNvZGVcXG5cXHRcXHRcXHR2YXIgajsgLy8gY291bnRlclxcblxcdFxcdFxcdHZhciBrOyAvLyBudW1iZXIgb2YgYml0cyBpbiBjdXJyZW50IGNvZGVcXG5cXHRcXHRcXHR2YXIgbDsgLy8gYml0cyBwZXIgdGFibGUgKHJldHVybmVkIGluIG0pXFxuXFx0XFx0XFx0dmFyIG1hc2s7IC8vICgxIDw8IHcpIC0gMSwgdG8gYXZvaWQgY2MgLU8gYnVnIG9uIEhQXFxuXFx0XFx0XFx0dmFyIHA7IC8vIHBvaW50ZXIgaW50byBjW10sIGJbXSwgb3IgdltdXFxuXFx0XFx0XFx0dmFyIHE7IC8vIHBvaW50cyB0byBjdXJyZW50IHRhYmxlXFxuXFx0XFx0XFx0dmFyIHc7IC8vIGJpdHMgYmVmb3JlIHRoaXMgdGFibGUgPT0gKGwgKiBoKVxcblxcdFxcdFxcdHZhciB4cDsgLy8gcG9pbnRlciBpbnRvIHhcXG5cXHRcXHRcXHR2YXIgeTsgLy8gbnVtYmVyIG9mIGR1bW15IGNvZGVzIGFkZGVkXFxuXFx0XFx0XFx0dmFyIHo7IC8vIG51bWJlciBvZiBlbnRyaWVzIGluIGN1cnJlbnQgdGFibGVcXG5cXG5cXHRcXHRcXHQvLyBHZW5lcmF0ZSBjb3VudHMgZm9yIGVhY2ggYml0IGxlbmd0aFxcblxcblxcdFxcdFxcdHAgPSAwO1xcblxcdFxcdFxcdGkgPSBuO1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRjW2JbYmluZGV4ICsgcF1dKys7XFxuXFx0XFx0XFx0XFx0cCsrO1xcblxcdFxcdFxcdFxcdGktLTsgLy8gYXNzdW1lIGFsbCBlbnRyaWVzIDw9IEJNQVhcXG5cXHRcXHRcXHR9IHdoaWxlIChpICE9PSAwKTtcXG5cXG5cXHRcXHRcXHRpZiAoY1swXSA9PSBuKSB7IC8vIG51bGwgaW5wdXQtLWFsbCB6ZXJvIGxlbmd0aCBjb2Rlc1xcblxcdFxcdFxcdFxcdHRbMF0gPSAtMTtcXG5cXHRcXHRcXHRcXHRtWzBdID0gMDtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRmluZCBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCwgYm91bmQgKm0gYnkgdGhvc2VcXG5cXHRcXHRcXHRsID0gbVswXTtcXG5cXHRcXHRcXHRmb3IgKGogPSAxOyBqIDw9IEJNQVg7IGorKylcXG5cXHRcXHRcXHRcXHRpZiAoY1tqXSAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRrID0gajsgLy8gbWluaW11bSBjb2RlIGxlbmd0aFxcblxcdFxcdFxcdGlmIChsIDwgaikge1xcblxcdFxcdFxcdFxcdGwgPSBqO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IgKGkgPSBCTUFYOyBpICE9PSAwOyBpLS0pIHtcXG5cXHRcXHRcXHRcXHRpZiAoY1tpXSAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZyA9IGk7IC8vIG1heGltdW0gY29kZSBsZW5ndGhcXG5cXHRcXHRcXHRpZiAobCA+IGkpIHtcXG5cXHRcXHRcXHRcXHRsID0gaTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bVswXSA9IGw7XFxuXFxuXFx0XFx0XFx0Ly8gQWRqdXN0IGxhc3QgbGVuZ3RoIGNvdW50IHRvIGZpbGwgb3V0IGNvZGVzLCBpZiBuZWVkZWRcXG5cXHRcXHRcXHRmb3IgKHkgPSAxIDw8IGo7IGogPCBpOyBqKyssIHkgPDw9IDEpIHtcXG5cXHRcXHRcXHRcXHRpZiAoKHkgLT0gY1tqXSkgPCAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgoeSAtPSBjW2ldKSA8IDApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRjW2ldICs9IHk7XFxuXFxuXFx0XFx0XFx0Ly8gR2VuZXJhdGUgc3RhcnRpbmcgb2Zmc2V0cyBpbnRvIHRoZSB2YWx1ZSB0YWJsZSBmb3IgZWFjaCBsZW5ndGhcXG5cXHRcXHRcXHR4WzFdID0gaiA9IDA7XFxuXFx0XFx0XFx0cCA9IDE7XFxuXFx0XFx0XFx0eHAgPSAyO1xcblxcdFxcdFxcdHdoaWxlICgtLWkgIT09IDApIHsgLy8gbm90ZSB0aGF0IGkgPT0gZyBmcm9tIGFib3ZlXFxuXFx0XFx0XFx0XFx0eFt4cF0gPSAoaiArPSBjW3BdKTtcXG5cXHRcXHRcXHRcXHR4cCsrO1xcblxcdFxcdFxcdFxcdHArKztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBhIHRhYmxlIG9mIHZhbHVlcyBpbiBvcmRlciBvZiBiaXQgbGVuZ3Roc1xcblxcdFxcdFxcdGkgPSAwO1xcblxcdFxcdFxcdHAgPSAwO1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRpZiAoKGogPSBiW2JpbmRleCArIHBdKSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdHZbeFtqXSsrXSA9IGk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHArKztcXG5cXHRcXHRcXHR9IHdoaWxlICgrK2kgPCBuKTtcXG5cXHRcXHRcXHRuID0geFtnXTsgLy8gc2V0IG4gdG8gbGVuZ3RoIG9mIHZcXG5cXG5cXHRcXHRcXHQvLyBHZW5lcmF0ZSB0aGUgSHVmZm1hbiBjb2RlcyBhbmQgZm9yIGVhY2gsIG1ha2UgdGhlIHRhYmxlIGVudHJpZXNcXG5cXHRcXHRcXHR4WzBdID0gaSA9IDA7IC8vIGZpcnN0IEh1ZmZtYW4gY29kZSBpcyB6ZXJvXFxuXFx0XFx0XFx0cCA9IDA7IC8vIGdyYWIgdmFsdWVzIGluIGJpdCBvcmRlclxcblxcdFxcdFxcdGggPSAtMTsgLy8gbm8gdGFibGVzIHlldC0tbGV2ZWwgLTFcXG5cXHRcXHRcXHR3ID0gLWw7IC8vIGJpdHMgZGVjb2RlZCA9PSAobCAqIGgpXFxuXFx0XFx0XFx0dVswXSA9IDA7IC8vIGp1c3QgdG8ga2VlcCBjb21waWxlcnMgaGFwcHlcXG5cXHRcXHRcXHRxID0gMDsgLy8gZGl0dG9cXG5cXHRcXHRcXHR6ID0gMDsgLy8gZGl0dG9cXG5cXG5cXHRcXHRcXHQvLyBnbyB0aHJvdWdoIHRoZSBiaXQgbGVuZ3RocyAoayBhbHJlYWR5IGlzIGJpdHMgaW4gc2hvcnRlc3QgY29kZSlcXG5cXHRcXHRcXHRmb3IgKDsgayA8PSBnOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRhID0gY1trXTtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoYS0tICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gaGVyZSBpIGlzIHRoZSBIdWZmbWFuIGNvZGUgb2YgbGVuZ3RoIGsgYml0cyBmb3IgdmFsdWUgKnBcXG5cXHRcXHRcXHRcXHRcXHQvLyBtYWtlIHRhYmxlcyB1cCB0byByZXF1aXJlZCBsZXZlbFxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrID4gdyArIGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoKys7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dyArPSBsOyAvLyBwcmV2aW91cyB0YWJsZSBhbHdheXMgbCBiaXRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gY29tcHV0ZSBtaW5pbXVtIHNpemUgdGFibGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGwgYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdHogPSBnIC0gdztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gKHogPiBsKSA/IGwgOiB6OyAvLyB0YWJsZSBzaXplIHVwcGVyIGxpbWl0XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKChmID0gMSA8PCAoaiA9IGsgLSB3KSkgPiBhICsgMSkgeyAvLyB0cnkgYSBrLXcgYml0IHRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gdG9vIGZldyBjb2RlcyBmb3JcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBrLXcgYml0IHRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZiAtPSBhICsgMTsgLy8gZGVkdWN0IGNvZGVzIGZyb20gcGF0dGVybnMgbGVmdFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHhwID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaiA8IHopIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoKytqIDwgeikgeyAvLyB0cnkgc21hbGxlciB0YWJsZXMgdXAgdG8geiBiaXRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKChmIDw8PSAxKSA8PSBjWysreHBdKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrOyAvLyBlbm91Z2ggY29kZXMgdG8gdXNlIHVwIGogYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGYgLT0gY1t4cF07IC8vIGVsc2UgZGVkdWN0IGNvZGVzIGZyb20gcGF0dGVybnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gMSA8PCBqOyAvLyB0YWJsZSBlbnRyaWVzIGZvciBqLWJpdCB0YWJsZVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFsbG9jYXRlIG5ldyB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChoblswXSArIHogPiBNQU5ZKSB7IC8vIChub3RlOiBkb2Vzbid0IG1hdHRlciBmb3IgZml4ZWQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfREFUQV9FUlJPUjsgLy8gb3ZlcmZsb3cgb2YgTUFOWVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR1W2hdID0gcSA9IC8qIGhwKyAqL2huWzBdOyAvLyBERUJVR1xcblxcdFxcdFxcdFxcdFxcdFxcdGhuWzBdICs9IHo7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gY29ubmVjdCB0byBsYXN0IHRhYmxlLCBpZiB0aGVyZSBpcyBvbmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaCAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHhbaF0gPSBpOyAvLyBzYXZlIHBhdHRlcm4gZm9yIGJhY2tpbmcgdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyWzBdID0gLyogKGJ5dGUpICovajsgLy8gYml0cyBpbiB0aGlzIHRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0clsxXSA9IC8qIChieXRlKSAqL2w7IC8vIGJpdHMgdG8gZHVtcCBiZWZvcmUgdGhpcyB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGogPSBpID4+PiAodyAtIGwpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJbMl0gPSAvKiAoaW50KSAqLyhxIC0gdVtoIC0gMV0gLSBqKTsgLy8gb2Zmc2V0IHRvIHRoaXMgdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRocC5zZXQociwgKHVbaCAtIDFdICsgaikgKiAzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB0b1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxhc3RcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dFswXSA9IHE7IC8vIGZpcnN0IHRhYmxlIGlzIHJldHVybmVkIHJlc3VsdFxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2V0IHVwIHRhYmxlIGVudHJ5IGluIHJcXG5cXHRcXHRcXHRcXHRcXHRyWzFdID0gLyogKGJ5dGUpICovKGsgLSB3KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocCA+PSBuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0clswXSA9IDEyOCArIDY0OyAvLyBvdXQgb2YgdmFsdWVzLS1pbnZhbGlkIGNvZGVcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHZbcF0gPCBzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0clswXSA9IC8qIChieXRlKSAqLyh2W3BdIDwgMjU2ID8gMCA6IDMyICsgNjQpOyAvLyAyNTYgaXNcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBlbmQtb2YtYmxvY2tcXG5cXHRcXHRcXHRcXHRcXHRcXHRyWzJdID0gdltwKytdOyAvLyBzaW1wbGUgY29kZSBpcyBqdXN0IHRoZSB2YWx1ZVxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0clswXSA9IC8qIChieXRlKSAqLyhlW3ZbcF0gLSBzXSArIDE2ICsgNjQpOyAvLyBub24tc2ltcGxlLS1sb29rXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdXAgaW4gbGlzdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRyWzJdID0gZFt2W3ArK10gLSBzXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmlsbCBjb2RlLWxpa2UgZW50cmllcyB3aXRoIHJcXG5cXHRcXHRcXHRcXHRcXHRmID0gMSA8PCAoayAtIHcpO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaiA9IGkgPj4+IHc7IGogPCB6OyBqICs9IGYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRocC5zZXQociwgKHEgKyBqKSAqIDMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBrLWJpdCBjb2RlIGlcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGogPSAxIDw8IChrIC0gMSk7IChpICYgaikgIT09IDA7IGogPj4+PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aSBePSBqO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpIF49IGo7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYmFja3VwIG92ZXIgZmluaXNoZWQgdGFibGVzXFxuXFx0XFx0XFx0XFx0XFx0bWFzayA9ICgxIDw8IHcpIC0gMTsgLy8gbmVlZGVkIG9uIEhQLCBjYyAtTyBidWdcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoKGkgJiBtYXNrKSAhPSB4W2hdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aC0tOyAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSBxXFxuXFx0XFx0XFx0XFx0XFx0XFx0dyAtPSBsO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hc2sgPSAoMSA8PCB3KSAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gUmV0dXJuIFpfQlVGX0VSUk9SIGlmIHdlIHdlcmUgZ2l2ZW4gYW4gaW5jb21wbGV0ZSB0YWJsZVxcblxcdFxcdFxcdHJldHVybiB5ICE9PSAwICYmIGcgIT0gMSA/IFpfQlVGX0VSUk9SIDogWl9PSztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdFdvcmtBcmVhKHZzaXplKSB7XFxuXFx0XFx0XFx0dmFyIGk7XFxuXFx0XFx0XFx0aWYgKCFobikge1xcblxcdFxcdFxcdFxcdGhuID0gW107IC8vIFtdOyAvL25ldyBBcnJheSgxKTtcXG5cXHRcXHRcXHRcXHR2ID0gW107IC8vIG5ldyBBcnJheSh2c2l6ZSk7XFxuXFx0XFx0XFx0XFx0YyA9IG5ldyBJbnQzMkFycmF5KEJNQVggKyAxKTsgLy8gbmV3IEFycmF5KEJNQVggKyAxKTtcXG5cXHRcXHRcXHRcXHRyID0gW107IC8vIG5ldyBBcnJheSgzKTtcXG5cXHRcXHRcXHRcXHR1ID0gbmV3IEludDMyQXJyYXkoQk1BWCk7IC8vIG5ldyBBcnJheShCTUFYKTtcXG5cXHRcXHRcXHRcXHR4ID0gbmV3IEludDMyQXJyYXkoQk1BWCArIDEpOyAvLyBuZXcgQXJyYXkoQk1BWCArIDEpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodi5sZW5ndGggPCB2c2l6ZSkge1xcblxcdFxcdFxcdFxcdHYgPSBbXTsgLy8gbmV3IEFycmF5KHZzaXplKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHZzaXplOyBpKyspIHtcXG5cXHRcXHRcXHRcXHR2W2ldID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IEJNQVggKyAxOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRjW2ldID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xcblxcdFxcdFxcdFxcdHJbaV0gPSAwO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBmb3IoaW50IGk9MDsgaTxCTUFYOyBpKyspe3VbaV09MDt9XFxuXFx0XFx0XFx0dS5zZXQoYy5zdWJhcnJheSgwLCBCTUFYKSwgMCk7XFxuXFx0XFx0XFx0Ly8gZm9yKGludCBpPTA7IGk8Qk1BWCsxOyBpKyspe3hbaV09MDt9XFxuXFx0XFx0XFx0eC5zZXQoYy5zdWJhcnJheSgwLCBCTUFYICsgMSksIDApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGF0LmluZmxhdGVfdHJlZXNfYml0cyA9IGZ1bmN0aW9uKGMsIC8vIDE5IGNvZGUgbGVuZ3Roc1xcblxcdFxcdGJiLCAvLyBiaXRzIHRyZWUgZGVzaXJlZC9hY3R1YWwgZGVwdGhcXG5cXHRcXHR0YiwgLy8gYml0cyB0cmVlIHJlc3VsdFxcblxcdFxcdGhwLCAvLyBzcGFjZSBmb3IgdHJlZXNcXG5cXHRcXHR6IC8vIGZvciBtZXNzYWdlc1xcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciByZXN1bHQ7XFxuXFx0XFx0XFx0aW5pdFdvcmtBcmVhKDE5KTtcXG5cXHRcXHRcXHRoblswXSA9IDA7XFxuXFx0XFx0XFx0cmVzdWx0ID0gaHVmdF9idWlsZChjLCAwLCAxOSwgMTksIG51bGwsIG51bGwsIHRiLCBiYiwgaHAsIGhuLCB2KTtcXG5cXG5cXHRcXHRcXHRpZiAocmVzdWx0ID09IFpfREFUQV9FUlJPUikge1xcblxcdFxcdFxcdFxcdHoubXNnID0gXFxcIm92ZXJzdWJzY3JpYmVkIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVxcXCI7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChyZXN1bHQgPT0gWl9CVUZfRVJST1IgfHwgYmJbMF0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbmNvbXBsZXRlIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVxcXCI7XFxuXFx0XFx0XFx0XFx0cmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5pbmZsYXRlX3RyZWVzX2R5bmFtaWMgPSBmdW5jdGlvbihubCwgLy8gbnVtYmVyIG9mIGxpdGVyYWwvbGVuZ3RoIGNvZGVzXFxuXFx0XFx0bmQsIC8vIG51bWJlciBvZiBkaXN0YW5jZSBjb2Rlc1xcblxcdFxcdGMsIC8vIHRoYXQgbWFueSAodG90YWwpIGNvZGUgbGVuZ3Roc1xcblxcdFxcdGJsLCAvLyBsaXRlcmFsIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxcblxcdFxcdGJkLCAvLyBkaXN0YW5jZSBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcXG5cXHRcXHR0bCwgLy8gbGl0ZXJhbC9sZW5ndGggdHJlZSByZXN1bHRcXG5cXHRcXHR0ZCwgLy8gZGlzdGFuY2UgdHJlZSByZXN1bHRcXG5cXHRcXHRocCwgLy8gc3BhY2UgZm9yIHRyZWVzXFxuXFx0XFx0eiAvLyBmb3IgbWVzc2FnZXNcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0O1xcblxcblxcdFxcdFxcdC8vIGJ1aWxkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcXG5cXHRcXHRcXHRpbml0V29ya0FyZWEoMjg4KTtcXG5cXHRcXHRcXHRoblswXSA9IDA7XFxuXFx0XFx0XFx0cmVzdWx0ID0gaHVmdF9idWlsZChjLCAwLCBubCwgMjU3LCBjcGxlbnMsIGNwbGV4dCwgdGwsIGJsLCBocCwgaG4sIHYpO1xcblxcdFxcdFxcdGlmIChyZXN1bHQgIT0gWl9PSyB8fCBibFswXSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwib3ZlcnN1YnNjcmliZWQgbGl0ZXJhbC9sZW5ndGggdHJlZVxcXCI7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChyZXN1bHQgIT0gWl9NRU1fRVJST1IpIHtcXG5cXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbmNvbXBsZXRlIGxpdGVyYWwvbGVuZ3RoIHRyZWVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYnVpbGQgZGlzdGFuY2UgdHJlZVxcblxcdFxcdFxcdGluaXRXb3JrQXJlYSgyODgpO1xcblxcdFxcdFxcdHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgbmwsIG5kLCAwLCBjcGRpc3QsIGNwZGV4dCwgdGQsIGJkLCBocCwgaG4sIHYpO1xcblxcblxcdFxcdFxcdGlmIChyZXN1bHQgIT0gWl9PSyB8fCAoYmRbMF0gPT09IDAgJiYgbmwgPiAyNTcpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1IpIHtcXG5cXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJvdmVyc3Vic2NyaWJlZCBkaXN0YW5jZSB0cmVlXFxcIjtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHJlc3VsdCA9PSBaX0JVRl9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImluY29tcGxldGUgZGlzdGFuY2UgdHJlZVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiZW1wdHkgZGlzdGFuY2UgdHJlZSB3aXRoIGxlbmd0aHNcXFwiO1xcblxcdFxcdFxcdFxcdFxcdHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0SW5mVHJlZS5pbmZsYXRlX3RyZWVzX2ZpeGVkID0gZnVuY3Rpb24oYmwsIC8vIGxpdGVyYWwgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxuXFx0YmQsIC8vIGRpc3RhbmNlIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxcblxcdHRsLC8vIGxpdGVyYWwvbGVuZ3RoIHRyZWUgcmVzdWx0XFxuXFx0dGQvLyBkaXN0YW5jZSB0cmVlIHJlc3VsdFxcblxcdCkge1xcblxcdFxcdGJsWzBdID0gZml4ZWRfYmw7XFxuXFx0XFx0YmRbMF0gPSBmaXhlZF9iZDtcXG5cXHRcXHR0bFswXSA9IGZpeGVkX3RsO1xcblxcdFxcdHRkWzBdID0gZml4ZWRfdGQ7XFxuXFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0fTtcXG5cXG5cXHQvLyBJbmZDb2Rlc1xcblxcblxcdC8vIHdhaXRpbmcgZm9yIFxcXCJpOlxcXCI9aW5wdXQsXFxuXFx0Ly8gXFxcIm86XFxcIj1vdXRwdXQsXFxuXFx0Ly8gXFxcIng6XFxcIj1ub3RoaW5nXFxuXFx0dmFyIFNUQVJUID0gMDsgLy8geDogc2V0IHVwIGZvciBMRU5cXG5cXHR2YXIgTEVOID0gMTsgLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XFxuXFx0dmFyIExFTkVYVCA9IDI7IC8vIGk6IGdldHRpbmcgbGVuZ3RoIGV4dHJhIChoYXZlIGJhc2UpXFxuXFx0dmFyIERJU1QgPSAzOyAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxcblxcdHZhciBESVNURVhUID0gNDsvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXFxuXFx0dmFyIENPUFkgPSA1OyAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZ1xcblxcdC8vIGZvciBzcGFjZVxcblxcdHZhciBMSVQgPSA2OyAvLyBvOiBnb3QgbGl0ZXJhbCwgd2FpdGluZyBmb3Igb3V0cHV0XFxuXFx0Ly8gc3BhY2VcXG5cXHR2YXIgV0FTSCA9IDc7IC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IHN0aWxsIG91dHB1dFxcblxcdC8vIHdhaXRpbmdcXG5cXHR2YXIgRU5EID0gODsgLy8geDogZ290IGVvYiBhbmQgYWxsIGRhdGEgZmx1c2hlZFxcblxcdHZhciBCQURDT0RFID0gOTsvLyB4OiBnb3QgZXJyb3JcXG5cXG5cXHRmdW5jdGlvbiBJbmZDb2RlcygpIHtcXG5cXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFxuXFx0XFx0dmFyIG1vZGU7IC8vIGN1cnJlbnQgaW5mbGF0ZV9jb2RlcyBtb2RlXFxuXFxuXFx0XFx0Ly8gbW9kZSBkZXBlbmRlbnQgaW5mb3JtYXRpb25cXG5cXHRcXHR2YXIgbGVuID0gMDtcXG5cXG5cXHRcXHR2YXIgdHJlZTsgLy8gcG9pbnRlciBpbnRvIHRyZWVcXG5cXHRcXHR2YXIgdHJlZV9pbmRleCA9IDA7XFxuXFx0XFx0dmFyIG5lZWQgPSAwOyAvLyBiaXRzIG5lZWRlZFxcblxcblxcdFxcdHZhciBsaXQgPSAwO1xcblxcblxcdFxcdC8vIGlmIEVYVCBvciBDT1BZLCB3aGVyZSBhbmQgaG93IG11Y2hcXG5cXHRcXHR2YXIgZ2V0ID0gMDsgLy8gYml0cyB0byBnZXQgZm9yIGV4dHJhXFxuXFx0XFx0dmFyIGRpc3QgPSAwOyAvLyBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgZnJvbVxcblxcblxcdFxcdHZhciBsYml0cyA9IDA7IC8vIGx0cmVlIGJpdHMgZGVjb2RlZCBwZXIgYnJhbmNoXFxuXFx0XFx0dmFyIGRiaXRzID0gMDsgLy8gZHRyZWUgYml0cyBkZWNvZGVyIHBlciBicmFuY2hcXG5cXHRcXHR2YXIgbHRyZWU7IC8vIGxpdGVyYWwvbGVuZ3RoL2VvYiB0cmVlXFxuXFx0XFx0dmFyIGx0cmVlX2luZGV4ID0gMDsgLy8gbGl0ZXJhbC9sZW5ndGgvZW9iIHRyZWVcXG5cXHRcXHR2YXIgZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcXG5cXHRcXHR2YXIgZHRyZWVfaW5kZXggPSAwOyAvLyBkaXN0YW5jZSB0cmVlXFxuXFxuXFx0XFx0Ly8gQ2FsbGVkIHdpdGggbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gd3JpdGUgaW4gd2luZG93IGF0IGxlYXN0IDI1OFxcblxcdFxcdC8vICh0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoKSBhbmQgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIGF2YWlsYWJsZVxcblxcdFxcdC8vIGF0IGxlYXN0IHRlbi4gVGhlIHRlbiBieXRlcyBhcmUgc2l4IGJ5dGVzIGZvciB0aGUgbG9uZ2VzdCBsZW5ndGgvXFxuXFx0XFx0Ly8gZGlzdGFuY2UgcGFpciBwbHVzIGZvdXIgYnl0ZXMgZm9yIG92ZXJsb2FkaW5nIHRoZSBiaXQgYnVmZmVyLlxcblxcblxcdFxcdGZ1bmN0aW9uIGluZmxhdGVfZmFzdChibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCBzLCB6KSB7XFxuXFx0XFx0XFx0dmFyIHQ7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIHRwOyAvLyB0ZW1wb3JhcnkgcG9pbnRlclxcblxcdFxcdFxcdHZhciB0cF9pbmRleDsgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgZTsgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cXG5cXHRcXHRcXHR2YXIgYjsgLy8gYml0IGJ1ZmZlclxcblxcdFxcdFxcdHZhciBrOyAvLyBiaXRzIGluIGJpdCBidWZmZXJcXG5cXHRcXHRcXHR2YXIgcDsgLy8gaW5wdXQgZGF0YSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG47IC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxcblxcdFxcdFxcdHZhciBxOyAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgbTsgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgbWw7IC8vIG1hc2sgZm9yIGxpdGVyYWwvbGVuZ3RoIHRyZWVcXG5cXHRcXHRcXHR2YXIgbWQ7IC8vIG1hc2sgZm9yIGRpc3RhbmNlIHRyZWVcXG5cXHRcXHRcXHR2YXIgYzsgLy8gYnl0ZXMgdG8gY29weVxcblxcdFxcdFxcdHZhciBkOyAvLyBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgZnJvbVxcblxcdFxcdFxcdHZhciByOyAvLyBjb3B5IHNvdXJjZSBwb2ludGVyXFxuXFxuXFx0XFx0XFx0dmFyIHRwX2luZGV4X3RfMzsgLy8gKHRwX2luZGV4K3QpKjNcXG5cXG5cXHRcXHRcXHQvLyBsb2FkIGlucHV0LCBvdXRwdXQsIGJpdCB2YWx1ZXNcXG5cXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdG4gPSB6LmF2YWlsX2luO1xcblxcdFxcdFxcdGIgPSBzLmJpdGI7XFxuXFx0XFx0XFx0ayA9IHMuYml0aztcXG5cXHRcXHRcXHRxID0gcy53cml0ZTtcXG5cXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcblxcdFxcdFxcdC8vIGluaXRpYWxpemUgbWFza3NcXG5cXHRcXHRcXHRtbCA9IGluZmxhdGVfbWFza1tibF07XFxuXFx0XFx0XFx0bWQgPSBpbmZsYXRlX21hc2tbYmRdO1xcblxcblxcdFxcdFxcdC8vIGRvIHVudGlsIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IHNwYWNlIGZvciBmYXN0IGxvb3BcXG5cXHRcXHRcXHRkbyB7IC8vIGFzc3VtZSBjYWxsZWQgd2l0aCBtID49IDI1OCAmJiBuID49IDEwXFxuXFx0XFx0XFx0XFx0Ly8gZ2V0IGxpdGVyYWwvbGVuZ3RoIGNvZGVcXG5cXHRcXHRcXHRcXHR3aGlsZSAoayA8ICgyMCkpIHsgLy8gbWF4IGJpdHMgZm9yIGxpdGVyYWwvbGVuZ3RoIGNvZGVcXG5cXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0ID0gYiAmIG1sO1xcblxcdFxcdFxcdFxcdHRwID0gdGw7XFxuXFx0XFx0XFx0XFx0dHBfaW5kZXggPSB0bF9pbmRleDtcXG5cXHRcXHRcXHRcXHR0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxuXFx0XFx0XFx0XFx0aWYgKChlID0gdHBbdHBfaW5kZXhfdF8zXSkgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRiID4+PSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gLyogKGJ5dGUpICovdHBbdHBfaW5kZXhfdF8zICsgMl07XFxuXFx0XFx0XFx0XFx0XFx0bS0tO1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXHRcXHRcXHRcXHRcXHRrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgMTYpICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZSAmPSAxNTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gdHBbdHBfaW5kZXhfdF8zICsgMl0gKyAoLyogKGludCkgKi9iICYgaW5mbGF0ZV9tYXNrW2VdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+PSBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkZWNvZGUgZGlzdGFuY2UgYmFzZSBvZiBibG9jayB0byBjb3B5XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoMTUpKSB7IC8vIG1heCBiaXRzIGZvciBkaXN0YW5jZSBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dCA9IGIgJiBtZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cCA9IHRkO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRwX2luZGV4ID0gdGRfaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHBfaW5kZXhfdF8zID0gKHRwX2luZGV4ICsgdCkgKiAzO1xcblxcdFxcdFxcdFxcdFxcdFxcdGUgPSB0cFt0cF9pbmRleF90XzNdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID4+PSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoKGUgJiAxNikgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBnZXQgZXh0cmEgYml0cyB0byBhZGQgdG8gZGlzdGFuY2UgYmFzZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGUgJj0gMTU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoZSkpIHsgLy8gZ2V0IGV4dHJhIGJpdHMgKHVwIHRvIDEzKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGQgPSB0cFt0cF9pbmRleF90XzMgKyAyXSArIChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiID4+PSAoZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAoZSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZG8gdGhlIGNvcHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtIC09IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPj0gZCkgeyAvLyBvZmZzZXQgYmVmb3JlIGRlc3RcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBqdXN0IGNvcHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gcSAtIGQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgLSByID4gMCAmJiAyID4gKHEgLSByKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdOyAvLyBtaW5pbXVtXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gY291bnQgaXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB0aHJlZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTsgLy8gc28gdW5yb2xsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gbG9vcCBhXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gbGl0dGxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyAtPSAyO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHIsIHIgKyAyKSwgcSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSArPSAyO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgKz0gMjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjIC09IDI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7IC8vIGVsc2Ugb2Zmc2V0IGFmdGVyIGRlc3RpbmF0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IHEgLSBkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyICs9IHMuZW5kOyAvLyBmb3JjZSBwb2ludGVyIGluIHdpbmRvd1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKHIgPCAwKTsgLy8gY292ZXJzIGludmFsaWQgZGlzdGFuY2VzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZSA9IHMuZW5kIC0gcjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYyA+IGUpIHsgLy8gaWYgc291cmNlIGNyb3NzZXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyAtPSBlOyAvLyB3cmFwcGVkIGNvcHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocSAtIHIgPiAwICYmIGUgPiAocSAtIHIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0tZSAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkociwgciArIGUpLCBxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRxICs9IGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciArPSBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGUgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gMDsgLy8gY29weSByZXN0IGZyb20gc3RhcnQgb2Ygd2luZG93XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBjb3B5IGFsbCBvciB3aGF0J3MgbGVmdFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChxIC0gciA+IDAgJiYgYyA+IChxIC0gcikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSB3aGlsZSAoLS1jICE9PSAwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShyLCByICsgYyksIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgKz0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyICs9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoKGUgJiA2NCkgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0ICs9IHRwW3RwX2luZGV4X3RfMyArIDJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gKGIgJiBpbmZsYXRlX21hc2tbZV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRwX2luZGV4X3RfMyA9ICh0cF9pbmRleCArIHQpICogMztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlID0gdHBbdHBfaW5kZXhfdF8zXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgZGlzdGFuY2UgY29kZVxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IHouYXZhaWxfaW4gLSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSAoayA+PiAzKSA8IGMgPyBrID4+IDMgOiBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG4gKz0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwIC09IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ayAtPSBjIDw8IDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGUgJiA2NCkgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ICs9IHRwW3RwX2luZGV4X3RfMyArIDJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgKz0gKGIgJiBpbmZsYXRlX21hc2tbZV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRwX2luZGV4X3RfMyA9ICh0cF9pbmRleCArIHQpICogMztcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoKGUgPSB0cFt0cF9pbmRleF90XzNdKSA9PT0gMCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgPj49ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93W3ErK10gPSAvKiAoYnl0ZSkgKi90cFt0cF9pbmRleF90XzMgKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoKGUgJiAzMikgIT09IDApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gei5hdmFpbF9pbiAtIG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IChrID4+IDMpIDwgYyA/IGsgPj4gMyA6IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0biArPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdHAgLT0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09IGMgPDwgMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VORDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHouYXZhaWxfaW4gLSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSAoayA+PiAzKSA8IGMgPyBrID4+IDMgOiBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdG4gKz0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRwIC09IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSBjIDw8IDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gd2hpbGUgKHRydWUpO1xcblxcdFxcdFxcdH0gd2hpbGUgKG0gPj0gMjU4ICYmIG4gPj0gMTApO1xcblxcblxcdFxcdFxcdC8vIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0LS1yZXN0b3JlIHBvaW50ZXJzIGFuZCByZXR1cm5cXG5cXHRcXHRcXHRjID0gei5hdmFpbF9pbiAtIG47XFxuXFx0XFx0XFx0YyA9IChrID4+IDMpIDwgYyA/IGsgPj4gMyA6IGM7XFxuXFx0XFx0XFx0biArPSBjO1xcblxcdFxcdFxcdHAgLT0gYztcXG5cXHRcXHRcXHRrIC09IGMgPDwgMztcXG5cXG5cXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoYXQuaW5pdCA9IGZ1bmN0aW9uKGJsLCBiZCwgdGwsIHRsX2luZGV4LCB0ZCwgdGRfaW5kZXgpIHtcXG5cXHRcXHRcXHRtb2RlID0gU1RBUlQ7XFxuXFx0XFx0XFx0bGJpdHMgPSAvKiAoYnl0ZSkgKi9ibDtcXG5cXHRcXHRcXHRkYml0cyA9IC8qIChieXRlKSAqL2JkO1xcblxcdFxcdFxcdGx0cmVlID0gdGw7XFxuXFx0XFx0XFx0bHRyZWVfaW5kZXggPSB0bF9pbmRleDtcXG5cXHRcXHRcXHRkdHJlZSA9IHRkO1xcblxcdFxcdFxcdGR0cmVlX2luZGV4ID0gdGRfaW5kZXg7XFxuXFx0XFx0XFx0dHJlZSA9IG51bGw7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LnByb2MgPSBmdW5jdGlvbihzLCB6LCByKSB7XFxuXFx0XFx0XFx0dmFyIGo7IC8vIHRlbXBvcmFyeSBzdG9yYWdlXFxuXFx0XFx0XFx0dmFyIHRpbmRleDsgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgZTsgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cXG5cXHRcXHRcXHR2YXIgYiA9IDA7IC8vIGJpdCBidWZmZXJcXG5cXHRcXHRcXHR2YXIgayA9IDA7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcblxcdFxcdFxcdHZhciBwID0gMDsgLy8gaW5wdXQgZGF0YSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG47IC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxcblxcdFxcdFxcdHZhciBxOyAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgbTsgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgZjsgLy8gcG9pbnRlciB0byBjb3B5IHN0cmluZ3MgZnJvbVxcblxcblxcdFxcdFxcdC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxcblxcdFxcdFxcdHAgPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0biA9IHouYXZhaWxfaW47XFxuXFx0XFx0XFx0YiA9IHMuYml0YjtcXG5cXHRcXHRcXHRrID0gcy5iaXRrO1xcblxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0Ly8gcHJvY2VzcyBpbnB1dCBhbmQgb3V0cHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcXG5cXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdHN3aXRjaCAobW9kZSkge1xcblxcdFxcdFxcdFxcdC8vIHdhaXRpbmcgZm9yIFxcXCJpOlxcXCI9aW5wdXQsIFxcXCJvOlxcXCI9b3V0cHV0LCBcXFwieDpcXFwiPW5vdGhpbmdcXG5cXHRcXHRcXHRcXHRjYXNlIFNUQVJUOiAvLyB4OiBzZXQgdXAgZm9yIExFTlxcblxcdFxcdFxcdFxcdFxcdGlmIChtID49IDI1OCAmJiBuID49IDEwKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHIgPSBpbmZsYXRlX2Zhc3QobGJpdHMsIGRiaXRzLCBsdHJlZSwgbHRyZWVfaW5kZXgsIGR0cmVlLCBkdHJlZV9pbmRleCwgcywgeik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cCA9IHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuID0gei5hdmFpbF9pbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID0gcy5iaXRiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgPSBzLmJpdGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cSA9IHMud3JpdGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAociAhPSBaX09LKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IHIgPT0gWl9TVFJFQU1fRU5EID8gV0FTSCA6IEJBRENPREU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRuZWVkID0gbGJpdHM7XFxuXFx0XFx0XFx0XFx0XFx0dHJlZSA9IGx0cmVlO1xcblxcdFxcdFxcdFxcdFxcdHRyZWVfaW5kZXggPSBsdHJlZV9pbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gTEVOO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIExFTjogLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XFxuXFx0XFx0XFx0XFx0XFx0aiA9IG5lZWQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGluZGV4ID0gKHRyZWVfaW5kZXggKyAoYiAmIGluZmxhdGVfbWFza1tqXSkpICogMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRiID4+Pj0gKHRyZWVbdGluZGV4ICsgMV0pO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gKHRyZWVbdGluZGV4ICsgMV0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGUgPSB0cmVlW3RpbmRleF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGUgPT09IDApIHsgLy8gbGl0ZXJhbFxcblxcdFxcdFxcdFxcdFxcdFxcdGxpdCA9IHRyZWVbdGluZGV4ICsgMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IExJVDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgMTYpICE9PSAwKSB7IC8vIGxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdFxcdGdldCA9IGUgJiAxNTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZW4gPSB0cmVlW3RpbmRleCArIDJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBMRU5FWFQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgoZSAmIDY0KSA9PT0gMCkgeyAvLyBuZXh0IHRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmVlZCA9IGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJlZV9pbmRleCA9IHRpbmRleCAvIDMgKyB0cmVlW3RpbmRleCArIDJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGUgJiAzMikgIT09IDApIHsgLy8gZW5kIG9mIGJsb2NrXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IFdBU0g7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCQURDT0RFOyAvLyBpbnZhbGlkIGNvZGVcXG5cXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBMRU5FWFQ6IC8vIGk6IGdldHRpbmcgbGVuZ3RoIGV4dHJhIChoYXZlIGJhc2UpXFxuXFx0XFx0XFx0XFx0XFx0aiA9IGdldDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8IChqKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRsZW4gKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGIgPj49IGo7XFxuXFx0XFx0XFx0XFx0XFx0ayAtPSBqO1xcblxcblxcdFxcdFxcdFxcdFxcdG5lZWQgPSBkYml0cztcXG5cXHRcXHRcXHRcXHRcXHR0cmVlID0gZHRyZWU7XFxuXFx0XFx0XFx0XFx0XFx0dHJlZV9pbmRleCA9IGR0cmVlX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBESVNUO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERJU1Q6IC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XFxuXFx0XFx0XFx0XFx0XFx0aiA9IG5lZWQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGluZGV4ID0gKHRyZWVfaW5kZXggKyAoYiAmIGluZmxhdGVfbWFza1tqXSkpICogMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRiID4+PSB0cmVlW3RpbmRleCArIDFdO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gdHJlZVt0aW5kZXggKyAxXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlID0gKHRyZWVbdGluZGV4XSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgMTYpICE9PSAwKSB7IC8vIGRpc3RhbmNlXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0ID0gZSAmIDE1O1xcblxcdFxcdFxcdFxcdFxcdFxcdGRpc3QgPSB0cmVlW3RpbmRleCArIDJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBESVNURVhUO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGUgJiA2NCkgPT09IDApIHsgLy8gbmV4dCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdG5lZWQgPSBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyZWVfaW5kZXggPSB0aW5kZXggLyAzICsgdHJlZVt0aW5kZXggKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IEJBRENPREU7IC8vIGludmFsaWQgY29kZVxcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgZGlzdGFuY2UgY29kZVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIERJU1RFWFQ6IC8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcXG5cXHRcXHRcXHRcXHRcXHRqID0gZ2V0O1xcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKGopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGRpc3QgKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGIgPj49IGo7XFxuXFx0XFx0XFx0XFx0XFx0ayAtPSBqO1xcblxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBDT1BZO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIENPUFk6IC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nIGZvciBzcGFjZVxcblxcdFxcdFxcdFxcdFxcdGYgPSBxIC0gZGlzdDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoZiA8IDApIHsgLy8gbW9kdWxvIHdpbmRvdyBzaXplLVxcXCJ3aGlsZVxcXCIgaW5zdGVhZFxcblxcdFxcdFxcdFxcdFxcdFxcdGYgKz0gcy5lbmQ7IC8vIG9mIFxcXCJpZlxcXCIgaGFuZGxlcyBpbnZhbGlkIGRpc3RhbmNlc1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAobGVuICE9PSAwKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocSA9PSBzLmVuZCAmJiBzLnJlYWQgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRxID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IHMud3JpdGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocSA9PSBzLmVuZCAmJiBzLnJlYWQgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRxID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93W3ErK10gPSBzLndpbmRvd1tmKytdO1xcblxcdFxcdFxcdFxcdFxcdFxcdG0tLTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZiA9PSBzLmVuZClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZW4tLTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IFNUQVJUO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgTElUOiAvLyBvOiBnb3QgbGl0ZXJhbCwgd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocSA9PSBzLmVuZCAmJiBzLnJlYWQgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRxID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IHMud3JpdGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocSA9PSBzLmVuZCAmJiBzLnJlYWQgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRxID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcblxcdFxcdFxcdFxcdFxcdHMud2luZG93W3ErK10gPSAvKiAoYnl0ZSkgKi9saXQ7XFxuXFx0XFx0XFx0XFx0XFx0bS0tO1xcblxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBTVEFSVDtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFdBU0g6IC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IG1vcmUgb3V0cHV0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGsgPiA3KSB7IC8vIHJldHVybiB1bnVzZWQgYnl0ZSwgaWYgYW55XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSA4O1xcblxcdFxcdFxcdFxcdFxcdFxcdG4rKztcXG5cXHRcXHRcXHRcXHRcXHRcXHRwLS07IC8vIGNhbiBhbHdheXMgcmV0dXJuIG9uZVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyID0gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHMucmVhZCAhPSBzLndyaXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBFTkQ7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRU5EOlxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX1NUUkVBTV9FTkQ7XFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBCQURDT0RFOiAvLyB4OiBnb3QgZXJyb3JcXG5cXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9EQVRBX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfU1RSRUFNX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmZyZWUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHQvLyBaRlJFRSh6LCBjKTtcXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvLyBJbmZCbG9ja3NcXG5cXG5cXHQvLyBUYWJsZSBmb3IgZGVmbGF0ZSBmcm9tIFBLWklQJ3MgYXBwbm90ZS50eHQuXFxuXFx0dmFyIGJvcmRlciA9IFsgLy8gT3JkZXIgb2YgdGhlIGJpdCBsZW5ndGggY29kZSBsZW5ndGhzXFxuXFx0MTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xcblxcblxcdHZhciBUWVBFID0gMDsgLy8gZ2V0IHR5cGUgYml0cyAoMywgaW5jbHVkaW5nIGVuZCBiaXQpXFxuXFx0dmFyIExFTlMgPSAxOyAvLyBnZXQgbGVuZ3RocyBmb3Igc3RvcmVkXFxuXFx0dmFyIFNUT1JFRCA9IDI7Ly8gcHJvY2Vzc2luZyBzdG9yZWQgYmxvY2tcXG5cXHR2YXIgVEFCTEUgPSAzOyAvLyBnZXQgdGFibGUgbGVuZ3Roc1xcblxcdHZhciBCVFJFRSA9IDQ7IC8vIGdldCBiaXQgbGVuZ3RocyB0cmVlIGZvciBhIGR5bmFtaWNcXG5cXHQvLyBibG9ja1xcblxcdHZhciBEVFJFRSA9IDU7IC8vIGdldCBsZW5ndGgsIGRpc3RhbmNlIHRyZWVzIGZvciBhXFxuXFx0Ly8gZHluYW1pYyBibG9ja1xcblxcdHZhciBDT0RFUyA9IDY7IC8vIHByb2Nlc3NpbmcgZml4ZWQgb3IgZHluYW1pYyBibG9ja1xcblxcdHZhciBEUlkgPSA3OyAvLyBvdXRwdXQgcmVtYWluaW5nIHdpbmRvdyBieXRlc1xcblxcdHZhciBET05FTE9DS1MgPSA4OyAvLyBmaW5pc2hlZCBsYXN0IGJsb2NrLCBkb25lXFxuXFx0dmFyIEJBREJMT0NLUyA9IDk7IC8vIG90IGEgZGF0YSBlcnJvci0tc3R1Y2sgaGVyZVxcblxcblxcdGZ1bmN0aW9uIEluZkJsb2Nrcyh6LCB3KSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdHZhciBtb2RlID0gVFlQRTsgLy8gY3VycmVudCBpbmZsYXRlX2Jsb2NrIG1vZGVcXG5cXG5cXHRcXHR2YXIgbGVmdCA9IDA7IC8vIGlmIFNUT1JFRCwgYnl0ZXMgbGVmdCB0byBjb3B5XFxuXFxuXFx0XFx0dmFyIHRhYmxlID0gMDsgLy8gdGFibGUgbGVuZ3RocyAoMTQgYml0cylcXG5cXHRcXHR2YXIgaW5kZXggPSAwOyAvLyBpbmRleCBpbnRvIGJsZW5zIChvciBib3JkZXIpXFxuXFx0XFx0dmFyIGJsZW5zOyAvLyBiaXQgbGVuZ3RocyBvZiBjb2Rlc1xcblxcdFxcdHZhciBiYiA9IFsgMCBdOyAvLyBiaXQgbGVuZ3RoIHRyZWUgZGVwdGhcXG5cXHRcXHR2YXIgdGIgPSBbIDAgXTsgLy8gYml0IGxlbmd0aCBkZWNvZGluZyB0cmVlXFxuXFxuXFx0XFx0dmFyIGNvZGVzID0gbmV3IEluZkNvZGVzKCk7IC8vIGlmIENPREVTLCBjdXJyZW50IHN0YXRlXFxuXFxuXFx0XFx0dmFyIGxhc3QgPSAwOyAvLyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgdGhlIGxhc3QgYmxvY2tcXG5cXG5cXHRcXHR2YXIgaHVmdHMgPSBuZXcgSW50MzJBcnJheShNQU5ZICogMyk7IC8vIHNpbmdsZSBtYWxsb2MgZm9yIHRyZWUgc3BhY2VcXG5cXHRcXHR2YXIgY2hlY2sgPSAwOyAvLyBjaGVjayBvbiBvdXRwdXRcXG5cXHRcXHR2YXIgaW5mdHJlZSA9IG5ldyBJbmZUcmVlKCk7XFxuXFxuXFx0XFx0dGhhdC5iaXRrID0gMDsgLy8gYml0cyBpbiBiaXQgYnVmZmVyXFxuXFx0XFx0dGhhdC5iaXRiID0gMDsgLy8gYml0IGJ1ZmZlclxcblxcdFxcdHRoYXQud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkodyk7IC8vIHNsaWRpbmcgd2luZG93XFxuXFx0XFx0dGhhdC5lbmQgPSB3OyAvLyBvbmUgYnl0ZSBhZnRlciBzbGlkaW5nIHdpbmRvd1xcblxcdFxcdHRoYXQucmVhZCA9IDA7IC8vIHdpbmRvdyByZWFkIHBvaW50ZXJcXG5cXHRcXHR0aGF0LndyaXRlID0gMDsgLy8gd2luZG93IHdyaXRlIHBvaW50ZXJcXG5cXG5cXHRcXHR0aGF0LnJlc2V0ID0gZnVuY3Rpb24oeiwgYykge1xcblxcdFxcdFxcdGlmIChjKVxcblxcdFxcdFxcdFxcdGNbMF0gPSBjaGVjaztcXG5cXHRcXHRcXHQvLyBpZiAobW9kZSA9PSBCVFJFRSB8fCBtb2RlID09IERUUkVFKSB7XFxuXFx0XFx0XFx0Ly8gfVxcblxcdFxcdFxcdGlmIChtb2RlID09IENPREVTKSB7XFxuXFx0XFx0XFx0XFx0Y29kZXMuZnJlZSh6KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bW9kZSA9IFRZUEU7XFxuXFx0XFx0XFx0dGhhdC5iaXRrID0gMDtcXG5cXHRcXHRcXHR0aGF0LmJpdGIgPSAwO1xcblxcdFxcdFxcdHRoYXQucmVhZCA9IHRoYXQud3JpdGUgPSAwO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5yZXNldCh6LCBudWxsKTtcXG5cXG5cXHRcXHQvLyBjb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgc2xpZGluZyB3aW5kb3cgdG8gdGhlIG91dHB1dCBhcmVhXFxuXFx0XFx0dGhhdC5pbmZsYXRlX2ZsdXNoID0gZnVuY3Rpb24oeiwgcikge1xcblxcdFxcdFxcdHZhciBuO1xcblxcdFxcdFxcdHZhciBwO1xcblxcdFxcdFxcdHZhciBxO1xcblxcblxcdFxcdFxcdC8vIGxvY2FsIGNvcGllcyBvZiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHBvaW50ZXJzXFxuXFx0XFx0XFx0cCA9IHoubmV4dF9vdXRfaW5kZXg7XFxuXFx0XFx0XFx0cSA9IHRoYXQucmVhZDtcXG5cXG5cXHRcXHRcXHQvLyBjb21wdXRlIG51bWJlciBvZiBieXRlcyB0byBjb3B5IGFzIGZhciBhcyBlbmQgb2Ygd2luZG93XFxuXFx0XFx0XFx0biA9IC8qIChpbnQpICovKChxIDw9IHRoYXQud3JpdGUgPyB0aGF0LndyaXRlIDogdGhhdC5lbmQpIC0gcSk7XFxuXFx0XFx0XFx0aWYgKG4gPiB6LmF2YWlsX291dClcXG5cXHRcXHRcXHRcXHRuID0gei5hdmFpbF9vdXQ7XFxuXFx0XFx0XFx0aWYgKG4gIT09IDAgJiYgciA9PSBaX0JVRl9FUlJPUilcXG5cXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXG5cXHRcXHRcXHQvLyB1cGRhdGUgY291bnRlcnNcXG5cXHRcXHRcXHR6LmF2YWlsX291dCAtPSBuO1xcblxcdFxcdFxcdHoudG90YWxfb3V0ICs9IG47XFxuXFxuXFx0XFx0XFx0Ly8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xcblxcdFxcdFxcdHoubmV4dF9vdXQuc2V0KHRoYXQud2luZG93LnN1YmFycmF5KHEsIHEgKyBuKSwgcCk7XFxuXFx0XFx0XFx0cCArPSBuO1xcblxcdFxcdFxcdHEgKz0gbjtcXG5cXG5cXHRcXHRcXHQvLyBzZWUgaWYgbW9yZSB0byBjb3B5IGF0IGJlZ2lubmluZyBvZiB3aW5kb3dcXG5cXHRcXHRcXHRpZiAocSA9PSB0aGF0LmVuZCkge1xcblxcdFxcdFxcdFxcdC8vIHdyYXAgcG9pbnRlcnNcXG5cXHRcXHRcXHRcXHRxID0gMDtcXG5cXHRcXHRcXHRcXHRpZiAodGhhdC53cml0ZSA9PSB0aGF0LmVuZClcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjb21wdXRlIGJ5dGVzIHRvIGNvcHlcXG5cXHRcXHRcXHRcXHRuID0gdGhhdC53cml0ZSAtIHE7XFxuXFx0XFx0XFx0XFx0aWYgKG4gPiB6LmF2YWlsX291dClcXG5cXHRcXHRcXHRcXHRcXHRuID0gei5hdmFpbF9vdXQ7XFxuXFx0XFx0XFx0XFx0aWYgKG4gIT09IDAgJiYgciA9PSBaX0JVRl9FUlJPUilcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXG5cXHRcXHRcXHRcXHQvLyB1cGRhdGUgY291bnRlcnNcXG5cXHRcXHRcXHRcXHR6LmF2YWlsX291dCAtPSBuO1xcblxcdFxcdFxcdFxcdHoudG90YWxfb3V0ICs9IG47XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY29weVxcblxcdFxcdFxcdFxcdHoubmV4dF9vdXQuc2V0KHRoYXQud2luZG93LnN1YmFycmF5KHEsIHEgKyBuKSwgcCk7XFxuXFx0XFx0XFx0XFx0cCArPSBuO1xcblxcdFxcdFxcdFxcdHEgKz0gbjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHBvaW50ZXJzXFxuXFx0XFx0XFx0ei5uZXh0X291dF9pbmRleCA9IHA7XFxuXFx0XFx0XFx0dGhhdC5yZWFkID0gcTtcXG5cXG5cXHRcXHRcXHQvLyBkb25lXFxuXFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LnByb2MgPSBmdW5jdGlvbih6LCByKSB7XFxuXFx0XFx0XFx0dmFyIHQ7IC8vIHRlbXBvcmFyeSBzdG9yYWdlXFxuXFx0XFx0XFx0dmFyIGI7IC8vIGJpdCBidWZmZXJcXG5cXHRcXHRcXHR2YXIgazsgLy8gYml0cyBpbiBiaXQgYnVmZmVyXFxuXFx0XFx0XFx0dmFyIHA7IC8vIGlucHV0IGRhdGEgcG9pbnRlclxcblxcdFxcdFxcdHZhciBuOyAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcXG5cXHRcXHRcXHR2YXIgcTsgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG07IC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXFxuXFxuXFx0XFx0XFx0dmFyIGk7XFxuXFxuXFx0XFx0XFx0Ly8gY29weSBpbnB1dC9vdXRwdXQgaW5mb3JtYXRpb24gdG8gbG9jYWxzIChVUERBVEUgbWFjcm8gcmVzdG9yZXMpXFxuXFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdHAgPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0biA9IHouYXZhaWxfaW47XFxuXFx0XFx0XFx0YiA9IHRoYXQuYml0YjtcXG5cXHRcXHRcXHRrID0gdGhhdC5iaXRrO1xcblxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0cSA9IHRoYXQud3JpdGU7XFxuXFx0XFx0XFx0bSA9IC8qIChpbnQpICovKHEgPCB0aGF0LnJlYWQgPyB0aGF0LnJlYWQgLSBxIC0gMSA6IHRoYXQuZW5kIC0gcSk7XFxuXFx0XFx0XFx0Ly8gfVxcblxcblxcdFxcdFxcdC8vIHByb2Nlc3MgaW5wdXQgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxcblxcdFxcdFxcdC8vIERFQlVHIGR0cmVlXFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKG1vZGUpIHtcXG5cXHRcXHRcXHRcXHRjYXNlIFRZUEU6XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoMykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHQgPSAvKiAoaW50KSAqLyhiICYgNyk7XFxuXFx0XFx0XFx0XFx0XFx0bGFzdCA9IHQgJiAxO1xcblxcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAodCA+Pj4gMSkge1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMDogLy8gc3RvcmVkXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBrICYgNzsgLy8gZ28gdG8gYnl0ZSBib3VuZGFyeVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gTEVOUzsgLy8gZ2V0IGxlbmd0aCBvZiBzdG9yZWQgYmxvY2tcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDE6IC8vIGZpeGVkXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBibCA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJkID0gW107IC8vIG5ldyBBcnJheSgxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdGwgPSBbIFtdIF07IC8vIG5ldyBBcnJheSgxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdGQgPSBbIFtdIF07IC8vIG5ldyBBcnJheSgxKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRJbmZUcmVlLmluZmxhdGVfdHJlZXNfZml4ZWQoYmwsIGJkLCB0bCwgdGQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvZGVzLmluaXQoYmxbMF0sIGJkWzBdLCB0bFswXSwgMCwgdGRbMF0sIDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49ICgzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09ICgzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IENPREVTO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMjogLy8gZHluYW1pY1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gVEFCTEU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzOiAvLyBpbGxlZ2FsXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCQURCTE9DS1M7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW52YWxpZCBibG9jayB0eXBlXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9EQVRBX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIExFTlM6XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoMzIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKCgofmIpID4+PiAxNikgJiAweGZmZmYpICE9IChiICYgMHhmZmZmKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCQURCTE9DS1M7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Roc1xcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bGVmdCA9IChiICYgMHhmZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRiID0gayA9IDA7IC8vIGR1bXAgYml0c1xcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBsZWZ0ICE9PSAwID8gU1RPUkVEIDogKGxhc3QgIT09IDAgPyBEUlkgOiBUWVBFKTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFNUT1JFRDpcXG5cXHRcXHRcXHRcXHRcXHRpZiAobiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChxID09IHRoYXQuZW5kICYmIHRoYXQucmVhZCAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IHRoYXQud3JpdGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IC8qIChpbnQpICovKHEgPCB0aGF0LnJlYWQgPyB0aGF0LnJlYWQgLSBxIC0gMSA6IHRoYXQuZW5kIC0gcSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gdGhhdC5lbmQgJiYgdGhhdC5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IC8qIChpbnQpICovKHEgPCB0aGF0LnJlYWQgPyB0aGF0LnJlYWQgLSBxIC0gMSA6IHRoYXQuZW5kIC0gcSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChtID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dCA9IGxlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHQgPiBuKVxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBuO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0ID4gbSlcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ID0gbTtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LndpbmRvdy5zZXQoei5yZWFkX2J1ZihwLCB0KSwgcSk7XFxuXFx0XFx0XFx0XFx0XFx0cCArPSB0O1xcblxcdFxcdFxcdFxcdFxcdG4gLT0gdDtcXG5cXHRcXHRcXHRcXHRcXHRxICs9IHQ7XFxuXFx0XFx0XFx0XFx0XFx0bSAtPSB0O1xcblxcdFxcdFxcdFxcdFxcdGlmICgobGVmdCAtPSB0KSAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gbGFzdCAhPT0gMCA/IERSWSA6IFRZUEU7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBUQUJMRTpcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8ICgxNCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRhYmxlID0gdCA9IChiICYgMHgzZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKHQgJiAweDFmKSA+IDI5IHx8ICgodCA+PiA1KSAmIDB4MWYpID4gMjkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9EQVRBX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0ID0gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpO1xcblxcdFxcdFxcdFxcdFxcdGlmICghYmxlbnMgfHwgYmxlbnMubGVuZ3RoIDwgdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zID0gW107IC8vIG5ldyBBcnJheSh0KTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCB0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRibGVuc1tpXSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj49ICgxNCk7XFxuXFx0XFx0XFx0XFx0XFx0ayAtPSAoMTQpO1xcblxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IEJUUkVFO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIEJUUkVFOlxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChpbmRleCA8IDQgKyAodGFibGUgPj4+IDEwKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKDMpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRibGVuc1tib3JkZXJbaW5kZXgrK11dID0gYiAmIDc7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoaW5kZXggPCAxOSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zW2JvcmRlcltpbmRleCsrXV0gPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRiYlswXSA9IDc7XFxuXFx0XFx0XFx0XFx0XFx0dCA9IGluZnRyZWUuaW5mbGF0ZV90cmVlc19iaXRzKGJsZW5zLCBiYiwgdGIsIGh1ZnRzLCB6KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodCAhPSBaX09LKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ciA9IHQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHIgPT0gWl9EQVRBX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmxlbnMgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCQURCTE9DS1M7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IERUUkVFO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERUUkVFOlxcblxcdFxcdFxcdFxcdFxcdHdoaWxlICh0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dCA9IHRhYmxlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChpbmRleCA+PSAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGosIGM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dCA9IGJiWzBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKHQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBpZiAodGJbMF0gPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTeXN0ZW0uZXJyLnByaW50bG4oXFxcIm51bGwuLi5cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dCA9IGh1ZnRzWyh0YlswXSArIChiICYgaW5mbGF0ZV9tYXNrW3RdKSkgKiAzICsgMV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IGh1ZnRzWyh0YlswXSArIChiICYgaW5mbGF0ZV9tYXNrW3RdKSkgKiAzICsgMl07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGMgPCAxNikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAodCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAodCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmxlbnNbaW5kZXgrK10gPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7IC8vIGMgPT0gMTYuLjE4XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aSA9IGMgPT0gMTggPyA3IDogYyAtIDE0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGogPSBjID09IDE4ID8gMTEgOiAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKHQgKyBpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49ICh0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrIC09ICh0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqICs9IChiICYgaW5mbGF0ZV9tYXNrW2ldKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKGkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKGkpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBpbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0ID0gdGFibGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGkgKyBqID4gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpIHx8IChjID09IDE2ICYmIGkgPCAxKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSBjID09IDE2ID8gYmxlbnNbaSAtIDFdIDogMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YmxlbnNbaSsrXSA9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSB3aGlsZSAoLS1qICE9PSAwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbmRleCA9IGk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0YlswXSA9IC0xO1xcblxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYmxfID0gW107IC8vIG5ldyBBcnJheSgxKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYmRfID0gW107IC8vIG5ldyBBcnJheSgxKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGxfID0gW107IC8vIG5ldyBBcnJheSgxKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGRfID0gW107IC8vIG5ldyBBcnJheSgxKTtcXG5cXHRcXHRcXHRcXHRcXHRibF9bMF0gPSA5OyAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xcblxcdFxcdFxcdFxcdFxcdGJkX1swXSA9IDY7IC8vIG11c3QgYmUgPD0gOSBmb3IgbG9va2FoZWFkIGFzc3VtcHRpb25zXFxuXFxuXFx0XFx0XFx0XFx0XFx0dCA9IHRhYmxlO1xcblxcdFxcdFxcdFxcdFxcdHQgPSBpbmZ0cmVlLmluZmxhdGVfdHJlZXNfZHluYW1pYygyNTcgKyAodCAmIDB4MWYpLCAxICsgKCh0ID4+IDUpICYgMHgxZiksIGJsZW5zLCBibF8sIGJkXywgdGxfLCB0ZF8sIGh1ZnRzLCB6KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAodCAhPSBaX09LKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmxlbnMgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCQURCTE9DS1M7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHIgPSB0O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRjb2Rlcy5pbml0KGJsX1swXSwgYmRfWzBdLCBodWZ0cywgdGxfWzBdLCBodWZ0cywgdGRfWzBdKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IENPREVTO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIENPREVTOlxcblxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKHIgPSBjb2Rlcy5wcm9jKHRoYXQsIHosIHIpKSAhPSBaX1NUUkVBTV9FTkQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRjb2Rlcy5mcmVlKHopO1xcblxcblxcdFxcdFxcdFxcdFxcdHAgPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0biA9IHouYXZhaWxfaW47XFxuXFx0XFx0XFx0XFx0XFx0YiA9IHRoYXQuYml0YjtcXG5cXHRcXHRcXHRcXHRcXHRrID0gdGhhdC5iaXRrO1xcblxcdFxcdFxcdFxcdFxcdHEgPSB0aGF0LndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChsYXN0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IFRZUEU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBEUlk7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRFJZOlxcblxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHIgPSB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0cSA9IHRoYXQud3JpdGU7XFxuXFx0XFx0XFx0XFx0XFx0bSA9IC8qIChpbnQpICovKHEgPCB0aGF0LnJlYWQgPyB0aGF0LnJlYWQgLSBxIC0gMSA6IHRoYXQuZW5kIC0gcSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoYXQucmVhZCAhPSB0aGF0LndyaXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBET05FTE9DS1M7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRE9ORUxPQ0tTOlxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX1NUUkVBTV9FTkQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0Y2FzZSBCQURCTE9DS1M6XFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXG5cXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX1NUUkVBTV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5mcmVlID0gZnVuY3Rpb24oeikge1xcblxcdFxcdFxcdHRoYXQucmVzZXQoeiwgbnVsbCk7XFxuXFx0XFx0XFx0dGhhdC53aW5kb3cgPSBudWxsO1xcblxcdFxcdFxcdGh1ZnRzID0gbnVsbDtcXG5cXHRcXHRcXHQvLyBaRlJFRSh6LCBzKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuc2V0X2RpY3Rpb25hcnkgPSBmdW5jdGlvbihkLCBzdGFydCwgbikge1xcblxcdFxcdFxcdHRoYXQud2luZG93LnNldChkLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIG4pLCAwKTtcXG5cXHRcXHRcXHR0aGF0LnJlYWQgPSB0aGF0LndyaXRlID0gbjtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXFxuXFx0XFx0Ly8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC5cXG5cXHRcXHR0aGF0LnN5bmNfcG9pbnQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gbW9kZSA9PSBMRU5TID8gMSA6IDA7XFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gSW5mbGF0ZVxcblxcblxcdC8vIHByZXNldCBkaWN0aW9uYXJ5IGZsYWcgaW4gemxpYiBoZWFkZXJcXG5cXHR2YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xcblxcblxcdHZhciBaX0RFRkxBVEVEID0gODtcXG5cXG5cXHR2YXIgTUVUSE9EID0gMDsgLy8gd2FpdGluZyBmb3IgbWV0aG9kIGJ5dGVcXG5cXHR2YXIgRkxBRyA9IDE7IC8vIHdhaXRpbmcgZm9yIGZsYWcgYnl0ZVxcblxcdHZhciBESUNUNCA9IDI7IC8vIGZvdXIgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xcblxcdHZhciBESUNUMyA9IDM7IC8vIHRocmVlIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cXG5cXHR2YXIgRElDVDIgPSA0OyAvLyB0d28gZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xcblxcdHZhciBESUNUMSA9IDU7IC8vIG9uZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGUgdG8gZ29cXG5cXHR2YXIgRElDVDAgPSA2OyAvLyB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeVxcblxcdHZhciBCTE9DS1MgPSA3OyAvLyBkZWNvbXByZXNzaW5nIGJsb2Nrc1xcblxcdHZhciBET05FID0gMTI7IC8vIGZpbmlzaGVkIGNoZWNrLCBkb25lXFxuXFx0dmFyIEJBRCA9IDEzOyAvLyBnb3QgYW4gZXJyb3ItLXN0YXkgaGVyZVxcblxcblxcdHZhciBtYXJrID0gWyAwLCAwLCAweGZmLCAweGZmIF07XFxuXFxuXFx0ZnVuY3Rpb24gSW5mbGF0ZSgpIHtcXG5cXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFxuXFx0XFx0dGhhdC5tb2RlID0gMDsgLy8gY3VycmVudCBpbmZsYXRlIG1vZGVcXG5cXG5cXHRcXHQvLyBtb2RlIGRlcGVuZGVudCBpbmZvcm1hdGlvblxcblxcdFxcdHRoYXQubWV0aG9kID0gMDsgLy8gaWYgRkxBR1MsIG1ldGhvZCBieXRlXFxuXFxuXFx0XFx0Ly8gaWYgQ0hFQ0ssIGNoZWNrIHZhbHVlcyB0byBjb21wYXJlXFxuXFx0XFx0dGhhdC53YXMgPSBbIDAgXTsgLy8gbmV3IEFycmF5KDEpOyAvLyBjb21wdXRlZCBjaGVjayB2YWx1ZVxcblxcdFxcdHRoYXQubmVlZCA9IDA7IC8vIHN0cmVhbSBjaGVjayB2YWx1ZVxcblxcblxcdFxcdC8vIGlmIEJBRCwgaW5mbGF0ZVN5bmMncyBtYXJrZXIgYnl0ZXMgY291bnRcXG5cXHRcXHR0aGF0Lm1hcmtlciA9IDA7XFxuXFxuXFx0XFx0Ly8gbW9kZSBpbmRlcGVuZGVudCBpbmZvcm1hdGlvblxcblxcdFxcdHRoYXQud2JpdHMgPSAwOyAvLyBsb2cyKHdpbmRvdyBzaXplKSAoOC4uMTUsIGRlZmF1bHRzIHRvIDE1KVxcblxcblxcdFxcdC8vIHRoaXMuYmxvY2tzOyAvLyBjdXJyZW50IGluZmxhdGVfYmxvY2tzIHN0YXRlXFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHopIHtcXG5cXHRcXHRcXHRpZiAoIXogfHwgIXouaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXG5cXHRcXHRcXHR6LnRvdGFsX2luID0gei50b3RhbF9vdXQgPSAwO1xcblxcdFxcdFxcdHoubXNnID0gbnVsbDtcXG5cXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcblxcdFxcdFxcdHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCBudWxsKTtcXG5cXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhhdC5pbmZsYXRlRW5kID0gZnVuY3Rpb24oeikge1xcblxcdFxcdFxcdGlmICh0aGF0LmJsb2NrcylcXG5cXHRcXHRcXHRcXHR0aGF0LmJsb2Nrcy5mcmVlKHopO1xcblxcdFxcdFxcdHRoYXQuYmxvY2tzID0gbnVsbDtcXG5cXHRcXHRcXHQvLyBaRlJFRSh6LCB6LT5zdGF0ZSk7XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmluZmxhdGVJbml0ID0gZnVuY3Rpb24oeiwgdykge1xcblxcdFxcdFxcdHoubXNnID0gbnVsbDtcXG5cXHRcXHRcXHR0aGF0LmJsb2NrcyA9IG51bGw7XFxuXFxuXFx0XFx0XFx0Ly8gc2V0IHdpbmRvdyBzaXplXFxuXFx0XFx0XFx0aWYgKHcgPCA4IHx8IHcgPiAxNSkge1xcblxcdFxcdFxcdFxcdHRoYXQuaW5mbGF0ZUVuZCh6KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoYXQud2JpdHMgPSB3O1xcblxcblxcdFxcdFxcdHouaXN0YXRlLmJsb2NrcyA9IG5ldyBJbmZCbG9ja3MoeiwgMSA8PCB3KTtcXG5cXG5cXHRcXHRcXHQvLyByZXNldCBzdGF0ZVxcblxcdFxcdFxcdGluZmxhdGVSZXNldCh6KTtcXG5cXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuaW5mbGF0ZSA9IGZ1bmN0aW9uKHosIGYpIHtcXG5cXHRcXHRcXHR2YXIgcjtcXG5cXHRcXHRcXHR2YXIgYjtcXG5cXG5cXHRcXHRcXHRpZiAoIXogfHwgIXouaXN0YXRlIHx8ICF6Lm5leHRfaW4pXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdGYgPSBmID09IFpfRklOSVNIID8gWl9CVUZfRVJST1IgOiBaX09LO1xcblxcdFxcdFxcdHIgPSBaX0JVRl9FUlJPUjtcXG5cXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdC8vIFN5c3RlbS5vdXQucHJpbnRsbihcXFwibW9kZTogXFxcIit6LmlzdGF0ZS5tb2RlKTtcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKHouaXN0YXRlLm1vZGUpIHtcXG5cXHRcXHRcXHRcXHRjYXNlIE1FVEhPRDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luLS07XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbisrO1xcblxcdFxcdFxcdFxcdFxcdGlmICgoKHouaXN0YXRlLm1ldGhvZCA9IHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSkgJiAweGYpICE9IFpfREVGTEFURUQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSA1OyAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCh6LmlzdGF0ZS5tZXRob2QgPj4gNCkgKyA4ID4gei5pc3RhdGUud2JpdHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgd2luZG93IHNpemVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1hcmtlciA9IDU7IC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gRkxBRztcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBGTEFHOlxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh6LmF2YWlsX2luID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4tLTtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luKys7XFxuXFx0XFx0XFx0XFx0XFx0YiA9ICh6LnJlYWRfYnl0ZSh6Lm5leHRfaW5faW5kZXgrKykpICYgMHhmZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKCgoei5pc3RhdGUubWV0aG9kIDw8IDgpICsgYikgJSAzMSkgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImluY29ycmVjdCBoZWFkZXIgY2hlY2tcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1hcmtlciA9IDU7IC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGIgJiBQUkVTRVRfRElDVCkgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gRElDVDQ7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRElDVDQ6XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHouYXZhaWxfaW4gPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IGY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbi0tO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4rKztcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5uZWVkID0gKCh6LnJlYWRfYnl0ZSh6Lm5leHRfaW5faW5kZXgrKykgJiAweGZmKSA8PCAyNCkgJiAweGZmMDAwMDAwO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBESUNUMztcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBESUNUMzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luLS07XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbisrO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm5lZWQgKz0gKCh6LnJlYWRfYnl0ZSh6Lm5leHRfaW5faW5kZXgrKykgJiAweGZmKSA8PCAxNikgJiAweGZmMDAwMDtcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gRElDVDI7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRElDVDI6XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHouYXZhaWxfaW4gPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IGY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbi0tO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4rKztcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5uZWVkICs9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgOCkgJiAweGZmMDA7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IERJQ1QxO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERJQ1QxOlxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh6LmF2YWlsX2luID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4tLTtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luKys7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubmVlZCArPSAoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZik7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IERJQ1QwO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX05FRURfRElDVDtcXG5cXHRcXHRcXHRcXHRjYXNlIERJQ1QwOlxcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBCQUQ7XFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwibmVlZCBkaWN0aW9uYXJ5XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSAwOyAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdFxcdGNhc2UgQkxPQ0tTOlxcblxcblxcdFxcdFxcdFxcdFxcdHIgPSB6LmlzdGF0ZS5ibG9ja3MucHJvYyh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAociA9PSBaX0RBVEFfRVJST1IpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1hcmtlciA9IDA7IC8vIGNhbiB0cnkgaW5mbGF0ZVN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHIgPT0gWl9PSykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAociAhPSBaX1NUUkVBTV9FTkQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ciA9IGY7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIHouaXN0YXRlLndhcyk7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IERPTkU7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRE9ORTpcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRU5EO1xcblxcdFxcdFxcdFxcdGNhc2UgQkFEOlxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbih6LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gMDtcXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcXG5cXHRcXHRcXHRpZiAoIXogfHwgIXouaXN0YXRlIHx8IHouaXN0YXRlLm1vZGUgIT0gRElDVDApXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcblxcdFxcdFxcdGlmIChsZW5ndGggPj0gKDEgPDwgei5pc3RhdGUud2JpdHMpKSB7XFxuXFx0XFx0XFx0XFx0bGVuZ3RoID0gKDEgPDwgei5pc3RhdGUud2JpdHMpIC0gMTtcXG5cXHRcXHRcXHRcXHRpbmRleCA9IGRpY3RMZW5ndGggLSBsZW5ndGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHouaXN0YXRlLmJsb2Nrcy5zZXRfZGljdGlvbmFyeShkaWN0aW9uYXJ5LCBpbmRleCwgbGVuZ3RoKTtcXG5cXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uKHopIHtcXG5cXHRcXHRcXHR2YXIgbjsgLy8gbnVtYmVyIG9mIGJ5dGVzIHRvIGxvb2sgYXRcXG5cXHRcXHRcXHR2YXIgcDsgLy8gcG9pbnRlciB0byBieXRlc1xcblxcdFxcdFxcdHZhciBtOyAvLyBudW1iZXIgb2YgbWFya2VyIGJ5dGVzIGZvdW5kIGluIGEgcm93XFxuXFx0XFx0XFx0dmFyIHIsIHc7IC8vIHRlbXBvcmFyaWVzIHRvIHNhdmUgdG90YWxfaW4gYW5kIHRvdGFsX291dFxcblxcblxcdFxcdFxcdC8vIHNldCB1cFxcblxcdFxcdFxcdGlmICgheiB8fCAhei5pc3RhdGUpXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdGlmICh6LmlzdGF0ZS5tb2RlICE9IEJBRCkge1xcblxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBCQUQ7XFxuXFx0XFx0XFx0XFx0ei5pc3RhdGUubWFya2VyID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKChuID0gei5hdmFpbF9pbikgPT09IDApXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfQlVGX0VSUk9SO1xcblxcdFxcdFxcdHAgPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0bSA9IHouaXN0YXRlLm1hcmtlcjtcXG5cXG5cXHRcXHRcXHQvLyBzZWFyY2hcXG5cXHRcXHRcXHR3aGlsZSAobiAhPT0gMCAmJiBtIDwgNCkge1xcblxcdFxcdFxcdFxcdGlmICh6LnJlYWRfYnl0ZShwKSA9PSBtYXJrW21dKSB7XFxuXFx0XFx0XFx0XFx0XFx0bSsrO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoei5yZWFkX2J5dGUocCkgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRtID0gMDtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdG0gPSA0IC0gbTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cCsrO1xcblxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gcmVzdG9yZVxcblxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdHouaXN0YXRlLm1hcmtlciA9IG07XFxuXFxuXFx0XFx0XFx0Ly8gcmV0dXJuIG5vIGpveSBvciBzZXQgdXAgdG8gcmVzdGFydCBvbiBhIG5ldyBibG9ja1xcblxcdFxcdFxcdGlmIChtICE9IDQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyID0gei50b3RhbF9pbjtcXG5cXHRcXHRcXHR3ID0gei50b3RhbF9vdXQ7XFxuXFx0XFx0XFx0aW5mbGF0ZVJlc2V0KHopO1xcblxcdFxcdFxcdHoudG90YWxfaW4gPSByO1xcblxcdFxcdFxcdHoudG90YWxfb3V0ID0gdztcXG5cXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gUmV0dXJucyB0cnVlIGlmIGluZmxhdGUgaXMgY3VycmVudGx5IGF0IHRoZSBlbmQgb2YgYSBibG9jayBnZW5lcmF0ZWRcXG5cXHRcXHQvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgb25lIFBQUFxcblxcdFxcdC8vIGltcGxlbWVudGF0aW9uIHRvIHByb3ZpZGUgYW4gYWRkaXRpb25hbCBzYWZldHkgY2hlY2suIFBQUCB1c2VzXFxuXFx0XFx0Ly8gWl9TWU5DX0ZMVVNIXFxuXFx0XFx0Ly8gYnV0IHJlbW92ZXMgdGhlIGxlbmd0aCBieXRlcyBvZiB0aGUgcmVzdWx0aW5nIGVtcHR5IHN0b3JlZCBibG9jay4gV2hlblxcblxcdFxcdC8vIGRlY29tcHJlc3NpbmcsIFBQUCBjaGVja3MgdGhhdCBhdCB0aGUgZW5kIG9mIGlucHV0IHBhY2tldCwgaW5mbGF0ZSBpc1xcblxcdFxcdC8vIHdhaXRpbmcgZm9yIHRoZXNlIGxlbmd0aCBieXRlcy5cXG5cXHRcXHR0aGF0LmluZmxhdGVTeW5jUG9pbnQgPSBmdW5jdGlvbih6KSB7XFxuXFx0XFx0XFx0aWYgKCF6IHx8ICF6LmlzdGF0ZSB8fCAhei5pc3RhdGUuYmxvY2tzKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gei5pc3RhdGUuYmxvY2tzLnN5bmNfcG9pbnQoKTtcXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHQvLyBaU3RyZWFtXFxuXFxuXFx0ZnVuY3Rpb24gWlN0cmVhbSgpIHtcXG5cXHR9XFxuXFxuXFx0WlN0cmVhbS5wcm90b3R5cGUgPSB7XFxuXFx0XFx0aW5mbGF0ZUluaXQgOiBmdW5jdGlvbihiaXRzKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdHRoYXQuaXN0YXRlID0gbmV3IEluZmxhdGUoKTtcXG5cXHRcXHRcXHRpZiAoIWJpdHMpXFxuXFx0XFx0XFx0XFx0Yml0cyA9IE1BWF9CSVRTO1xcblxcdFxcdFxcdHJldHVybiB0aGF0LmlzdGF0ZS5pbmZsYXRlSW5pdCh0aGF0LCBiaXRzKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGluZmxhdGUgOiBmdW5jdGlvbihmKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdGlmICghdGhhdC5pc3RhdGUpXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdHJldHVybiB0aGF0LmlzdGF0ZS5pbmZsYXRlKHRoYXQsIGYpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW5mbGF0ZUVuZCA6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR2YXIgcmV0ID0gdGhhdC5pc3RhdGUuaW5mbGF0ZUVuZCh0aGF0KTtcXG5cXHRcXHRcXHR0aGF0LmlzdGF0ZSA9IG51bGw7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGluZmxhdGVTeW5jIDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdGlmICghdGhhdC5pc3RhdGUpXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdHJldHVybiB0aGF0LmlzdGF0ZS5pbmZsYXRlU3luYyh0aGF0KTtcXG5cXHRcXHR9LFxcblxcdFxcdGluZmxhdGVTZXREaWN0aW9uYXJ5IDogZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhhdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7XFxuXFx0XFx0fSxcXG5cXHRcXHRyZWFkX2J5dGUgOiBmdW5jdGlvbihzdGFydCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5uZXh0X2luLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIDEpWzBdO1xcblxcdFxcdH0sXFxuXFx0XFx0cmVhZF9idWYgOiBmdW5jdGlvbihzdGFydCwgc2l6ZSkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5uZXh0X2luLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIHNpemUpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8vIEluZmxhdGVyXFxuXFxuXFx0ZnVuY3Rpb24gSW5mbGF0ZXIoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdHZhciB6ID0gbmV3IFpTdHJlYW0oKTtcXG5cXHRcXHR2YXIgYnVmc2l6ZSA9IDUxMjtcXG5cXHRcXHR2YXIgZmx1c2ggPSBaX05PX0ZMVVNIO1xcblxcdFxcdHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZzaXplKTtcXG5cXHRcXHR2YXIgbm9tb3JlaW5wdXQgPSBmYWxzZTtcXG5cXG5cXHRcXHR6LmluZmxhdGVJbml0KCk7XFxuXFx0XFx0ei5uZXh0X291dCA9IGJ1ZjtcXG5cXG5cXHRcXHR0aGF0LmFwcGVuZCA9IGZ1bmN0aW9uKGRhdGEsIG9ucHJvZ3Jlc3MpIHtcXG5cXHRcXHRcXHR2YXIgZXJyLCBidWZmZXJzID0gW10sIGxhc3RJbmRleCA9IDAsIGJ1ZmZlckluZGV4ID0gMCwgYnVmZmVyU2l6ZSA9IDAsIGFycmF5O1xcblxcdFxcdFxcdGlmIChkYXRhLmxlbmd0aCA9PT0gMClcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gMDtcXG5cXHRcXHRcXHR6Lm5leHRfaW4gPSBkYXRhO1xcblxcdFxcdFxcdHouYXZhaWxfaW4gPSBkYXRhLmxlbmd0aDtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0ei5uZXh0X291dF9pbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0ei5hdmFpbF9vdXQgPSBidWZzaXplO1xcblxcdFxcdFxcdFxcdGlmICgoei5hdmFpbF9pbiA9PT0gMCkgJiYgKCFub21vcmVpbnB1dCkpIHsgLy8gaWYgYnVmZmVyIGlzIGVtcHR5IGFuZCBtb3JlIGlucHV0IGlzIGF2YWlsYWJsZSwgcmVmaWxsIGl0XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRub21vcmVpbnB1dCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGVyciA9IHouaW5mbGF0ZShmbHVzaCk7XFxuXFx0XFx0XFx0XFx0aWYgKG5vbW9yZWlucHV0ICYmIChlcnIgPT09IFpfQlVGX0VSUk9SKSkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh6LmF2YWlsX2luICE9PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiaW5mbGF0aW5nOiBiYWQgaW5wdXRcXFwiKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGVyciAhPT0gWl9PSyAmJiBlcnIgIT09IFpfU1RSRUFNX0VORClcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcImluZmxhdGluZzogXFxcIiArIHoubXNnKTtcXG5cXHRcXHRcXHRcXHRpZiAoKG5vbW9yZWlucHV0IHx8IGVyciA9PT0gWl9TVFJFQU1fRU5EKSAmJiAoei5hdmFpbF9pbiA9PT0gZGF0YS5sZW5ndGgpKVxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiaW5mbGF0aW5nOiBiYWQgaW5wdXRcXFwiKTtcXG5cXHRcXHRcXHRcXHRpZiAoei5uZXh0X291dF9pbmRleClcXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5uZXh0X291dF9pbmRleCA9PT0gYnVmc2l6ZSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XFxuXFx0XFx0XFx0XFx0XFx0ZWxzZVxcblxcdFxcdFxcdFxcdFxcdFxcdGJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShidWYuc3ViYXJyYXkoMCwgei5uZXh0X291dF9pbmRleCkpKTtcXG5cXHRcXHRcXHRcXHRidWZmZXJTaXplICs9IHoubmV4dF9vdXRfaW5kZXg7XFxuXFx0XFx0XFx0XFx0aWYgKG9ucHJvZ3Jlc3MgJiYgei5uZXh0X2luX2luZGV4ID4gMCAmJiB6Lm5leHRfaW5faW5kZXggIT0gbGFzdEluZGV4KSB7XFxuXFx0XFx0XFx0XFx0XFx0b25wcm9ncmVzcyh6Lm5leHRfaW5faW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdGxhc3RJbmRleCA9IHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSB3aGlsZSAoei5hdmFpbF9pbiA+IDAgfHwgei5hdmFpbF9vdXQgPT09IDApO1xcblxcdFxcdFxcdGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyU2l6ZSk7XFxuXFx0XFx0XFx0YnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XFxuXFx0XFx0XFx0XFx0YXJyYXkuc2V0KGNodW5rLCBidWZmZXJJbmRleCk7XFxuXFx0XFx0XFx0XFx0YnVmZmVySW5kZXggKz0gY2h1bmsubGVuZ3RoO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXHRcXHR9O1xcblxcdFxcdHRoYXQuZmx1c2ggPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR6LmluZmxhdGVFbmQoKTtcXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHQvLyAnemlwJyBtYXkgbm90IGJlIGRlZmluZWQgaW4gei13b3JrZXIgYW5kIHNvbWUgdGVzdHNcXG5cXHR2YXIgZW52ID0gZ2xvYmFsLnppcCB8fCBnbG9iYWw7XFxuXFx0ZW52LkluZmxhdGVyID0gZW52Ll9qemxpYl9JbmZsYXRlciA9IEluZmxhdGVyO1xcbn0pKHRoaXMpO1xcblwiKV1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gemlwO1xuXG4iLCI7IHZhciBfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vKlxuIENvcHlyaWdodCAoYykgMjAxMyBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpblxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24ob2JqKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBFUlJfQkFEX0ZPUk1BVCA9IFwiRmlsZSBmb3JtYXQgaXMgbm90IHJlY29nbml6ZWQuXCI7XG5cdHZhciBFUlJfQ1JDID0gXCJDUkMgZmFpbGVkLlwiO1xuXHR2YXIgRVJSX0VOQ1JZUFRFRCA9IFwiRmlsZSBjb250YWlucyBlbmNyeXB0ZWQgZW50cnkuXCI7XG5cdHZhciBFUlJfWklQNjQgPSBcIkZpbGUgaXMgdXNpbmcgWmlwNjQgKDRnYisgZmlsZSBzaXplKS5cIjtcblx0dmFyIEVSUl9SRUFEID0gXCJFcnJvciB3aGlsZSByZWFkaW5nIHppcCBmaWxlLlwiO1xuXHR2YXIgRVJSX1dSSVRFID0gXCJFcnJvciB3aGlsZSB3cml0aW5nIHppcCBmaWxlLlwiO1xuXHR2YXIgRVJSX1dSSVRFX0RBVEEgPSBcIkVycm9yIHdoaWxlIHdyaXRpbmcgZmlsZSBkYXRhLlwiO1xuXHR2YXIgRVJSX1JFQURfREFUQSA9IFwiRXJyb3Igd2hpbGUgcmVhZGluZyBmaWxlIGRhdGEuXCI7XG5cdHZhciBFUlJfRFVQTElDQVRFRF9OQU1FID0gXCJGaWxlIGFscmVhZHkgZXhpc3RzLlwiO1xuXHR2YXIgQ0hVTktfU0laRSA9IDUxMiAqIDEwMjQ7XG5cdFxuXHR2YXIgVEVYVF9QTEFJTiA9IFwidGV4dC9wbGFpblwiO1xuXG5cdHZhciBhcHBlbmRBQlZpZXdTdXBwb3J0ZWQ7XG5cdHRyeSB7XG5cdFx0YXBwZW5kQUJWaWV3U3VwcG9ydGVkID0gbmV3IEJsb2IoWyBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSBdKS5zaXplID09PSAwO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cblxuXHRmdW5jdGlvbiBDcmMzMigpIHtcblx0XHR0aGlzLmNyYyA9IC0xO1xuXHR9XG5cdENyYzMyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoZGF0YSkge1xuXHRcdHZhciBjcmMgPSB0aGlzLmNyYyB8IDAsIHRhYmxlID0gdGhpcy50YWJsZTtcblx0XHRmb3IgKHZhciBvZmZzZXQgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aCB8IDA7IG9mZnNldCA8IGxlbjsgb2Zmc2V0KyspXG5cdFx0XHRjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlWyhjcmMgXiBkYXRhW29mZnNldF0pICYgMHhGRl07XG5cdFx0dGhpcy5jcmMgPSBjcmM7XG5cdH07XG5cdENyYzMyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0cmV0dXJuIH50aGlzLmNyYztcblx0fTtcblx0Q3JjMzIucHJvdG90eXBlLnRhYmxlID0gKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpLCBqLCB0LCB0YWJsZSA9IFtdOyAvLyBVaW50MzJBcnJheSBpcyBhY3R1YWxseSBzbG93ZXIgdGhhbiBbXVxuXHRcdGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHRcdFx0dCA9IGk7XG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgODsgaisrKVxuXHRcdFx0XHRpZiAodCAmIDEpXG5cdFx0XHRcdFx0dCA9ICh0ID4+PiAxKSBeIDB4RURCODgzMjA7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0ID0gdCA+Pj4gMTtcblx0XHRcdHRhYmxlW2ldID0gdDtcblx0XHR9XG5cdFx0cmV0dXJuIHRhYmxlO1xuXHR9KSgpO1xuXHRcblx0Ly8gXCJuby1vcFwiIGNvZGVjXG5cdGZ1bmN0aW9uIE5PT1AoKSB7fVxuXHROT09QLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoYnl0ZXMsIG9ucHJvZ3Jlc3MpIHtcblx0XHRyZXR1cm4gYnl0ZXM7XG5cdH07XG5cdE5PT1AucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7fTtcblxuXHRmdW5jdGlvbiBibG9iU2xpY2UoYmxvYiwgaW5kZXgsIGxlbmd0aCkge1xuXHRcdGlmIChpbmRleCA8IDAgfHwgbGVuZ3RoIDwgMCB8fCBpbmRleCArIGxlbmd0aCA+IGJsb2Iuc2l6ZSlcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQ6JyArIGluZGV4ICsgJywgbGVuZ3RoOicgKyBsZW5ndGggKyAnLCBzaXplOicgKyBibG9iLnNpemUpO1xuXHRcdGlmIChibG9iLnNsaWNlKVxuXHRcdFx0cmV0dXJuIGJsb2Iuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcblx0XHRlbHNlIGlmIChibG9iLndlYmtpdFNsaWNlKVxuXHRcdFx0cmV0dXJuIGJsb2Iud2Via2l0U2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcblx0XHRlbHNlIGlmIChibG9iLm1velNsaWNlKVxuXHRcdFx0cmV0dXJuIGJsb2IubW96U2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcblx0XHRlbHNlIGlmIChibG9iLm1zU2xpY2UpXG5cdFx0XHRyZXR1cm4gYmxvYi5tc1NsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXREYXRhSGVscGVyKGJ5dGVMZW5ndGgsIGJ5dGVzKSB7XG5cdFx0dmFyIGRhdGFCdWZmZXIsIGRhdGFBcnJheTtcblx0XHRkYXRhQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuXHRcdGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGFCdWZmZXIpO1xuXHRcdGlmIChieXRlcylcblx0XHRcdGRhdGFBcnJheS5zZXQoYnl0ZXMsIDApO1xuXHRcdHJldHVybiB7XG5cdFx0XHRidWZmZXIgOiBkYXRhQnVmZmVyLFxuXHRcdFx0YXJyYXkgOiBkYXRhQXJyYXksXG5cdFx0XHR2aWV3IDogbmV3IERhdGFWaWV3KGRhdGFCdWZmZXIpXG5cdFx0fTtcblx0fVxuXG5cdC8vIFJlYWRlcnNcblx0ZnVuY3Rpb24gUmVhZGVyKCkge1xuXHR9XG5cblx0ZnVuY3Rpb24gVGV4dFJlYWRlcih0ZXh0KSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLCBibG9iUmVhZGVyO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdChjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdFx0dmFyIGJsb2IgPSBuZXcgQmxvYihbIHRleHQgXSwge1xuXHRcdFx0XHR0eXBlIDogVEVYVF9QTEFJTlxuXHRcdFx0fSk7XG5cdFx0XHRibG9iUmVhZGVyID0gbmV3IEJsb2JSZWFkZXIoYmxvYik7XG5cdFx0XHRibG9iUmVhZGVyLmluaXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQuc2l6ZSA9IGJsb2JSZWFkZXIuc2l6ZTtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH0sIG9uZXJyb3IpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrLCBvbmVycm9yKSB7XG5cdFx0XHRibG9iUmVhZGVyLnJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrLCBvbmVycm9yKTtcblx0XHR9XG5cblx0XHR0aGF0LnNpemUgPSAwO1xuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xuXHR9XG5cdFRleHRSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xuXHRUZXh0UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRSZWFkZXI7XG5cblx0ZnVuY3Rpb24gRGF0YTY0VVJJUmVhZGVyKGRhdGFVUkkpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsIGRhdGFTdGFydDtcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdHZhciBkYXRhRW5kID0gZGF0YVVSSS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoZGF0YVVSSS5jaGFyQXQoZGF0YUVuZCAtIDEpID09IFwiPVwiKVxuXHRcdFx0XHRkYXRhRW5kLS07XG5cdFx0XHRkYXRhU3RhcnQgPSBkYXRhVVJJLmluZGV4T2YoXCIsXCIpICsgMTtcblx0XHRcdHRoYXQuc2l6ZSA9IE1hdGguZmxvb3IoKGRhdGFFbmQgLSBkYXRhU3RhcnQpICogMC43NSk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaSwgZGF0YSA9IGdldERhdGFIZWxwZXIobGVuZ3RoKTtcblx0XHRcdHZhciBzdGFydCA9IE1hdGguZmxvb3IoaW5kZXggLyAzKSAqIDQ7XG5cdFx0XHR2YXIgZW5kID0gTWF0aC5jZWlsKChpbmRleCArIGxlbmd0aCkgLyAzKSAqIDQ7XG5cdFx0XHR2YXIgYnl0ZXMgPSBvYmouYXRvYihkYXRhVVJJLnN1YnN0cmluZyhzdGFydCArIGRhdGFTdGFydCwgZW5kICsgZGF0YVN0YXJ0KSk7XG5cdFx0XHR2YXIgZGVsdGEgPSBpbmRleCAtIE1hdGguZmxvb3Ioc3RhcnQgLyA0KSAqIDM7XG5cdFx0XHRmb3IgKGkgPSBkZWx0YTsgaSA8IGRlbHRhICsgbGVuZ3RoOyBpKyspXG5cdFx0XHRcdGRhdGEuYXJyYXlbaSAtIGRlbHRhXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRjYWxsYmFjayhkYXRhLmFycmF5KTtcblx0XHR9XG5cblx0XHR0aGF0LnNpemUgPSAwO1xuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xuXHR9XG5cdERhdGE2NFVSSVJlYWRlci5wcm90b3R5cGUgPSBuZXcgUmVhZGVyKCk7XG5cdERhdGE2NFVSSVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhNjRVUklSZWFkZXI7XG5cblx0ZnVuY3Rpb24gQmxvYlJlYWRlcihibG9iKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdChjYWxsYmFjaykge1xuXHRcdFx0dGhhdC5zaXplID0gYmxvYi5zaXplO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgVWludDhBcnJheShlLnRhcmdldC5yZXN1bHQpKTtcblx0XHRcdH07XG5cdFx0XHRyZWFkZXIub25lcnJvciA9IG9uZXJyb3I7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYlNsaWNlKGJsb2IsIGluZGV4LCBsZW5ndGgpKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0b25lcnJvcihlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGF0LnNpemUgPSAwO1xuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xuXHR9XG5cdEJsb2JSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xuXHRCbG9iUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsb2JSZWFkZXI7XG5cblx0Ly8gV3JpdGVyc1xuXG5cdGZ1bmN0aW9uIFdyaXRlcigpIHtcblx0fVxuXHRXcml0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrKHRoaXMuZGF0YSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gVGV4dFdyaXRlcihlbmNvZGluZykge1xuXHRcdHZhciB0aGF0ID0gdGhpcywgYmxvYjtcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdGJsb2IgPSBuZXcgQmxvYihbXSwge1xuXHRcdFx0XHR0eXBlIDogVEVYVF9QTEFJTlxuXHRcdFx0fSk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheShhcnJheSwgY2FsbGJhY2spIHtcblx0XHRcdGJsb2IgPSBuZXcgQmxvYihbIGJsb2IsIGFwcGVuZEFCVmlld1N1cHBvcnRlZCA/IGFycmF5IDogYXJyYXkuYnVmZmVyIF0sIHtcblx0XHRcdFx0dHlwZSA6IFRFWFRfUExBSU5cblx0XHRcdH0pO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREYXRhKGNhbGxiYWNrLCBvbmVycm9yKSB7XG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGUudGFyZ2V0LnJlc3VsdCk7XG5cdFx0XHR9O1xuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBvbmVycm9yO1xuXHRcdFx0cmVhZGVyLnJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpO1xuXHRcdH1cblxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XG5cdFx0dGhhdC53cml0ZVVpbnQ4QXJyYXkgPSB3cml0ZVVpbnQ4QXJyYXk7XG5cdFx0dGhhdC5nZXREYXRhID0gZ2V0RGF0YTtcblx0fVxuXHRUZXh0V3JpdGVyLnByb3RvdHlwZSA9IG5ldyBXcml0ZXIoKTtcblx0VGV4dFdyaXRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0V3JpdGVyO1xuXG5cdGZ1bmN0aW9uIERhdGE2NFVSSVdyaXRlcihjb250ZW50VHlwZSkge1xuXHRcdHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IFwiXCIsIHBlbmRpbmcgPSBcIlwiO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdChjYWxsYmFjaykge1xuXHRcdFx0ZGF0YSArPSBcImRhdGE6XCIgKyAoY29udGVudFR5cGUgfHwgXCJcIikgKyBcIjtiYXNlNjQsXCI7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheShhcnJheSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBpLCBkZWx0YSA9IHBlbmRpbmcubGVuZ3RoLCBkYXRhU3RyaW5nID0gcGVuZGluZztcblx0XHRcdHBlbmRpbmcgPSBcIlwiO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IChNYXRoLmZsb29yKChkZWx0YSArIGFycmF5Lmxlbmd0aCkgLyAzKSAqIDMpIC0gZGVsdGE7IGkrKylcblx0XHRcdFx0ZGF0YVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcblx0XHRcdGZvciAoOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHBlbmRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG5cdFx0XHRpZiAoZGF0YVN0cmluZy5sZW5ndGggPiAyKVxuXHRcdFx0XHRkYXRhICs9IG9iai5idG9hKGRhdGFTdHJpbmcpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwZW5kaW5nID0gZGF0YVN0cmluZztcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2soZGF0YSArIG9iai5idG9hKHBlbmRpbmcpKTtcblx0XHR9XG5cblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQud3JpdGVVaW50OEFycmF5ID0gd3JpdGVVaW50OEFycmF5O1xuXHRcdHRoYXQuZ2V0RGF0YSA9IGdldERhdGE7XG5cdH1cblx0RGF0YTY0VVJJV3JpdGVyLnByb3RvdHlwZSA9IG5ldyBXcml0ZXIoKTtcblx0RGF0YTY0VVJJV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERhdGE2NFVSSVdyaXRlcjtcblxuXHRmdW5jdGlvbiBCbG9iV3JpdGVyKGNvbnRlbnRUeXBlKSB7XG5cdFx0dmFyIGJsb2IsIHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdChjYWxsYmFjaykge1xuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFtdLCB7XG5cdFx0XHRcdHR5cGUgOiBjb250ZW50VHlwZVxuXHRcdFx0fSk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheShhcnJheSwgY2FsbGJhY2spIHtcblx0XHRcdGJsb2IgPSBuZXcgQmxvYihbIGJsb2IsIGFwcGVuZEFCVmlld1N1cHBvcnRlZCA/IGFycmF5IDogYXJyYXkuYnVmZmVyIF0sIHtcblx0XHRcdFx0dHlwZSA6IGNvbnRlbnRUeXBlXG5cdFx0XHR9KTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2soYmxvYik7XG5cdFx0fVxuXG5cdFx0dGhhdC5pbml0ID0gaW5pdDtcblx0XHR0aGF0LndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcblx0XHR0aGF0LmdldERhdGEgPSBnZXREYXRhO1xuXHR9XG5cdEJsb2JXcml0ZXIucHJvdG90eXBlID0gbmV3IFdyaXRlcigpO1xuXHRCbG9iV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsb2JXcml0ZXI7XG5cblx0LyoqIFxuXHQgKiBpbmZsYXRlL2RlZmxhdGUgY29yZSBmdW5jdGlvbnNcblx0ICogQHBhcmFtIHdvcmtlciB7V29ya2VyfSB3ZWIgd29ya2VyIGZvciB0aGUgdGFzay5cblx0ICogQHBhcmFtIGluaXRpYWxNZXNzYWdlIHtPYmplY3R9IGluaXRpYWwgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSB3b3JrZXIuIHNob3VsZCBjb250YWluXG5cdCAqICAgc24oc2VyaWFsIG51bWJlciBmb3IgZGlzdGluZ3Vpc2hpbmcgbXVsdGlwbGUgdGFza3Mgc2VudCB0byB0aGUgd29ya2VyKSwgYW5kIGNvZGVjQ2xhc3MuXG5cdCAqICAgVGhpcyBmdW5jdGlvbiBtYXkgYWRkIG1vcmUgcHJvcGVydGllcyBiZWZvcmUgc2VuZGluZy5cblx0ICovXG5cdGZ1bmN0aW9uIGxhdW5jaFdvcmtlclByb2Nlc3Mod29ya2VyLCBpbml0aWFsTWVzc2FnZSwgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY2h1bmtJbmRleCA9IDAsIGluZGV4LCBvdXRwdXRTaXplLCBzbiA9IGluaXRpYWxNZXNzYWdlLnNuLCBjcmM7XG5cblx0XHRmdW5jdGlvbiBvbmZsdXNoKCkge1xuXHRcdFx0d29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdG9uZW5kKG91dHB1dFNpemUsIGNyYyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IGV2ZW50LmRhdGEsIGRhdGEgPSBtZXNzYWdlLmRhdGEsIGVyciA9IG1lc3NhZ2UuZXJyb3I7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGVyci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdFcnJvcjogJyArIHRoaXMubWVzc2FnZTsgfTtcblx0XHRcdFx0b25yZWFkZXJyb3IoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1lc3NhZ2Uuc24gIT09IHNuKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAodHlwZW9mIG1lc3NhZ2UuY29kZWNUaW1lID09PSAnbnVtYmVyJylcblx0XHRcdFx0d29ya2VyLmNvZGVjVGltZSArPSBtZXNzYWdlLmNvZGVjVGltZTsgLy8gc2hvdWxkIGJlIGJlZm9yZSBvbmZsdXNoKClcblx0XHRcdGlmICh0eXBlb2YgbWVzc2FnZS5jcmNUaW1lID09PSAnbnVtYmVyJylcblx0XHRcdFx0d29ya2VyLmNyY1RpbWUgKz0gbWVzc2FnZS5jcmNUaW1lO1xuXG5cdFx0XHRzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuXHRcdFx0XHRjYXNlICdhcHBlbmQnOlxuXHRcdFx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRvdXRwdXRTaXplICs9IGRhdGEubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShkYXRhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0c3RlcCgpO1xuXHRcdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdHN0ZXAoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZmx1c2gnOlxuXHRcdFx0XHRcdGNyYyA9IG1lc3NhZ2UuY3JjO1xuXHRcdFx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRvdXRwdXRTaXplICs9IGRhdGEubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShkYXRhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0b25mbHVzaCgpO1xuXHRcdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdG9uZmx1c2goKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAncHJvZ3Jlc3MnOlxuXHRcdFx0XHRcdGlmIChvbnByb2dyZXNzKVxuXHRcdFx0XHRcdFx0b25wcm9ncmVzcyhpbmRleCArIG1lc3NhZ2UubG9hZGVkLCBzaXplKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnaW1wb3J0U2NyaXB0cyc6IC8vbm8gbmVlZCB0byBoYW5kbGUgaGVyZVxuXHRcdFx0XHRjYXNlICduZXdUYXNrJzpcblx0XHRcdFx0Y2FzZSAnZWNobyc6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCd6aXAuanM6bGF1bmNoV29ya2VyUHJvY2VzczogdW5rbm93biBtZXNzYWdlOiAnLCBtZXNzYWdlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdGVwKCkge1xuXHRcdFx0aW5kZXggPSBjaHVua0luZGV4ICogQ0hVTktfU0laRTtcblx0XHRcdC8vIHVzZSBgPD1gIGluc3RlYWQgb2YgYDxgLCBiZWNhdXNlIGBzaXplYCBtYXkgYmUgMC5cblx0XHRcdGlmIChpbmRleCA8PSBzaXplKSB7XG5cdFx0XHRcdHJlYWRlci5yZWFkVWludDhBcnJheShvZmZzZXQgKyBpbmRleCwgTWF0aC5taW4oQ0hVTktfU0laRSwgc2l6ZSAtIGluZGV4KSwgZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRcdFx0XHRpZiAob25wcm9ncmVzcylcblx0XHRcdFx0XHRcdG9ucHJvZ3Jlc3MoaW5kZXgsIHNpemUpO1xuXHRcdFx0XHRcdHZhciBtc2cgPSBpbmRleCA9PT0gMCA/IGluaXRpYWxNZXNzYWdlIDoge3NuIDogc259O1xuXHRcdFx0XHRcdG1zZy50eXBlID0gJ2FwcGVuZCc7XG5cdFx0XHRcdFx0bXNnLmRhdGEgPSBhcnJheTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBwb3N0aW5nIGEgbWVzc2FnZSB3aXRoIHRyYW5zZmVyYWJsZXMgd2lsbCBmYWlsIG9uIElFMTBcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW2FycmF5LmJ1ZmZlcl0pO1xuXHRcdFx0XHRcdH0gY2F0Y2goZXgpIHtcblx0XHRcdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZShtc2cpOyAvLyByZXRyeSB3aXRob3V0IHRyYW5zZmVyYWJsZXNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2h1bmtJbmRleCsrO1xuXHRcdFx0XHR9LCBvbnJlYWRlcnJvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRcdHNuOiBzbixcblx0XHRcdFx0XHR0eXBlOiAnZmx1c2gnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG91dHB1dFNpemUgPSAwO1xuXHRcdHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0c3RlcCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbGF1bmNoUHJvY2Vzcyhwcm9jZXNzLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcikge1xuXHRcdHZhciBjaHVua0luZGV4ID0gMCwgaW5kZXgsIG91dHB1dFNpemUgPSAwLFxuXHRcdFx0Y3JjSW5wdXQgPSBjcmNUeXBlID09PSAnaW5wdXQnLFxuXHRcdFx0Y3JjT3V0cHV0ID0gY3JjVHlwZSA9PT0gJ291dHB1dCcsXG5cdFx0XHRjcmMgPSBuZXcgQ3JjMzIoKTtcblx0XHRmdW5jdGlvbiBzdGVwKCkge1xuXHRcdFx0dmFyIG91dHB1dERhdGE7XG5cdFx0XHRpbmRleCA9IGNodW5rSW5kZXggKiBDSFVOS19TSVpFO1xuXHRcdFx0aWYgKGluZGV4IDwgc2l6ZSlcblx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KG9mZnNldCArIGluZGV4LCBNYXRoLm1pbihDSFVOS19TSVpFLCBzaXplIC0gaW5kZXgpLCBmdW5jdGlvbihpbnB1dERhdGEpIHtcblx0XHRcdFx0XHR2YXIgb3V0cHV0RGF0YTtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0b3V0cHV0RGF0YSA9IHByb2Nlc3MuYXBwZW5kKGlucHV0RGF0YSwgZnVuY3Rpb24obG9hZGVkKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvbnByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHRcdG9ucHJvZ3Jlc3MoaW5kZXggKyBsb2FkZWQsIHNpemUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0b25yZWFkZXJyb3IoZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChvdXRwdXREYXRhKSB7XG5cdFx0XHRcdFx0XHRvdXRwdXRTaXplICs9IG91dHB1dERhdGEubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShvdXRwdXREYXRhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y2h1bmtJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuXHRcdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0XHRcdGlmIChjcmNPdXRwdXQpXG5cdFx0XHRcdFx0XHRcdGNyYy5hcHBlbmQob3V0cHV0RGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNodW5rSW5kZXgrKztcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoc3RlcCwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjcmNJbnB1dClcblx0XHRcdFx0XHRcdGNyYy5hcHBlbmQoaW5wdXREYXRhKTtcblx0XHRcdFx0XHRpZiAob25wcm9ncmVzcylcblx0XHRcdFx0XHRcdG9ucHJvZ3Jlc3MoaW5kZXgsIHNpemUpO1xuXHRcdFx0XHR9LCBvbnJlYWRlcnJvcik7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRvdXRwdXREYXRhID0gcHJvY2Vzcy5mbHVzaCgpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0b25yZWFkZXJyb3IoZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvdXRwdXREYXRhKSB7XG5cdFx0XHRcdFx0aWYgKGNyY091dHB1dClcblx0XHRcdFx0XHRcdGNyYy5hcHBlbmQob3V0cHV0RGF0YSk7XG5cdFx0XHRcdFx0b3V0cHV0U2l6ZSArPSBvdXRwdXREYXRhLmxlbmd0aDtcblx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KG91dHB1dERhdGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0b25lbmQob3V0cHV0U2l6ZSwgY3JjLmdldCgpKTtcblx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRvbmVuZChvdXRwdXRTaXplLCBjcmMuZ2V0KCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0ZXAoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluZmxhdGUod29ya2VyLCBzbiwgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgY29tcHV0ZUNyYzMyLCBvbmVuZCwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcikge1xuXHRcdHZhciBjcmNUeXBlID0gY29tcHV0ZUNyYzMyID8gJ291dHB1dCcgOiAnbm9uZSc7XG5cdFx0aWYgKG9iai56aXAudXNlV2ViV29ya2Vycykge1xuXHRcdFx0dmFyIGluaXRpYWxNZXNzYWdlID0ge1xuXHRcdFx0XHRzbjogc24sXG5cdFx0XHRcdGNvZGVjQ2xhc3M6ICdJbmZsYXRlcicsXG5cdFx0XHRcdGNyY1R5cGU6IGNyY1R5cGUsXG5cdFx0XHR9O1xuXHRcdFx0bGF1bmNoV29ya2VyUHJvY2Vzcyh3b3JrZXIsIGluaXRpYWxNZXNzYWdlLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0fSBlbHNlXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBvYmouemlwLkluZmxhdGVyKCksIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNyY1R5cGUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlZmxhdGUod29ya2VyLCBzbiwgcmVhZGVyLCB3cml0ZXIsIGxldmVsLCBvbmVuZCwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcikge1xuXHRcdHZhciBjcmNUeXBlID0gJ2lucHV0Jztcblx0XHRpZiAob2JqLnppcC51c2VXZWJXb3JrZXJzKSB7XG5cdFx0XHR2YXIgaW5pdGlhbE1lc3NhZ2UgPSB7XG5cdFx0XHRcdHNuOiBzbixcblx0XHRcdFx0b3B0aW9uczoge2xldmVsOiBsZXZlbH0sXG5cdFx0XHRcdGNvZGVjQ2xhc3M6ICdEZWZsYXRlcicsXG5cdFx0XHRcdGNyY1R5cGU6IGNyY1R5cGUsXG5cdFx0XHR9O1xuXHRcdFx0bGF1bmNoV29ya2VyUHJvY2Vzcyh3b3JrZXIsIGluaXRpYWxNZXNzYWdlLCByZWFkZXIsIHdyaXRlciwgMCwgcmVhZGVyLnNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0XHR9IGVsc2Vcblx0XHRcdGxhdW5jaFByb2Nlc3MobmV3IG9iai56aXAuRGVmbGF0ZXIoKSwgcmVhZGVyLCB3cml0ZXIsIDAsIHJlYWRlci5zaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdH1cblxuXHRmdW5jdGlvbiBjb3B5KHdvcmtlciwgc24sIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNvbXB1dGVDcmMzMiwgb25lbmQsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY3JjVHlwZSA9ICdpbnB1dCc7XG5cdFx0aWYgKG9iai56aXAudXNlV2ViV29ya2VycyAmJiBjb21wdXRlQ3JjMzIpIHtcblx0XHRcdHZhciBpbml0aWFsTWVzc2FnZSA9IHtcblx0XHRcdFx0c246IHNuLFxuXHRcdFx0XHRjb2RlY0NsYXNzOiAnTk9PUCcsXG5cdFx0XHRcdGNyY1R5cGU6IGNyY1R5cGUsXG5cdFx0XHR9O1xuXHRcdFx0bGF1bmNoV29ya2VyUHJvY2Vzcyh3b3JrZXIsIGluaXRpYWxNZXNzYWdlLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0fSBlbHNlXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBOT09QKCksIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNyY1R5cGUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0fVxuXG5cdC8vIFppcFJlYWRlclxuXG5cdGZ1bmN0aW9uIGRlY29kZUFTQ0lJKHN0cikge1xuXHRcdHZhciBpLCBvdXQgPSBcIlwiLCBjaGFyQ29kZSwgZXh0ZW5kZWRBU0NJSSA9IFsgJ1xcdTAwQzcnLCAnXFx1MDBGQycsICdcXHUwMEU5JywgJ1xcdTAwRTInLCAnXFx1MDBFNCcsICdcXHUwMEUwJywgJ1xcdTAwRTUnLCAnXFx1MDBFNycsICdcXHUwMEVBJywgJ1xcdTAwRUInLFxuXHRcdFx0XHQnXFx1MDBFOCcsICdcXHUwMEVGJywgJ1xcdTAwRUUnLCAnXFx1MDBFQycsICdcXHUwMEM0JywgJ1xcdTAwQzUnLCAnXFx1MDBDOScsICdcXHUwMEU2JywgJ1xcdTAwQzYnLCAnXFx1MDBGNCcsICdcXHUwMEY2JywgJ1xcdTAwRjInLCAnXFx1MDBGQicsICdcXHUwMEY5Jyxcblx0XHRcdFx0J1xcdTAwRkYnLCAnXFx1MDBENicsICdcXHUwMERDJywgJ1xcdTAwRjgnLCAnXFx1MDBBMycsICdcXHUwMEQ4JywgJ1xcdTAwRDcnLCAnXFx1MDE5MicsICdcXHUwMEUxJywgJ1xcdTAwRUQnLCAnXFx1MDBGMycsICdcXHUwMEZBJywgJ1xcdTAwRjEnLCAnXFx1MDBEMScsXG5cdFx0XHRcdCdcXHUwMEFBJywgJ1xcdTAwQkEnLCAnXFx1MDBCRicsICdcXHUwMEFFJywgJ1xcdTAwQUMnLCAnXFx1MDBCRCcsICdcXHUwMEJDJywgJ1xcdTAwQTEnLCAnXFx1MDBBQicsICdcXHUwMEJCJywgJ18nLCAnXycsICdfJywgJ1xcdTAwQTYnLCAnXFx1MDBBNicsXG5cdFx0XHRcdCdcXHUwMEMxJywgJ1xcdTAwQzInLCAnXFx1MDBDMCcsICdcXHUwMEE5JywgJ1xcdTAwQTYnLCAnXFx1MDBBNicsICcrJywgJysnLCAnXFx1MDBBMicsICdcXHUwMEE1JywgJysnLCAnKycsICctJywgJy0nLCAnKycsICctJywgJysnLCAnXFx1MDBFMycsXG5cdFx0XHRcdCdcXHUwMEMzJywgJysnLCAnKycsICctJywgJy0nLCAnXFx1MDBBNicsICctJywgJysnLCAnXFx1MDBBNCcsICdcXHUwMEYwJywgJ1xcdTAwRDAnLCAnXFx1MDBDQScsICdcXHUwMENCJywgJ1xcdTAwQzgnLCAnaScsICdcXHUwMENEJywgJ1xcdTAwQ0UnLFxuXHRcdFx0XHQnXFx1MDBDRicsICcrJywgJysnLCAnXycsICdfJywgJ1xcdTAwQTYnLCAnXFx1MDBDQycsICdfJywgJ1xcdTAwRDMnLCAnXFx1MDBERicsICdcXHUwMEQ0JywgJ1xcdTAwRDInLCAnXFx1MDBGNScsICdcXHUwMEQ1JywgJ1xcdTAwQjUnLCAnXFx1MDBGRScsXG5cdFx0XHRcdCdcXHUwMERFJywgJ1xcdTAwREEnLCAnXFx1MDBEQicsICdcXHUwMEQ5JywgJ1xcdTAwRkQnLCAnXFx1MDBERCcsICdcXHUwMEFGJywgJ1xcdTAwQjQnLCAnXFx1MDBBRCcsICdcXHUwMEIxJywgJ18nLCAnXFx1MDBCRScsICdcXHUwMEI2JywgJ1xcdTAwQTcnLFxuXHRcdFx0XHQnXFx1MDBGNycsICdcXHUwMEI4JywgJ1xcdTAwQjAnLCAnXFx1MDBBOCcsICdcXHUwMEI3JywgJ1xcdTAwQjknLCAnXFx1MDBCMycsICdcXHUwMEIyJywgJ18nLCAnICcgXTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRjtcblx0XHRcdGlmIChjaGFyQ29kZSA+IDEyNylcblx0XHRcdFx0b3V0ICs9IGV4dGVuZGVkQVNDSUlbY2hhckNvZGUgLSAxMjhdO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVVVEY4KHN0cmluZykge1xuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cmluZykpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U3RyaW5nKGJ5dGVzKSB7XG5cdFx0dmFyIGksIHN0ciA9IFwiXCI7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0c3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXREYXRlKHRpbWVSYXcpIHtcblx0XHR2YXIgZGF0ZSA9ICh0aW1lUmF3ICYgMHhmZmZmMDAwMCkgPj4gMTYsIHRpbWUgPSB0aW1lUmF3ICYgMHgwMDAwZmZmZjtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKDE5ODAgKyAoKGRhdGUgJiAweEZFMDApID4+IDkpLCAoKGRhdGUgJiAweDAxRTApID4+IDUpIC0gMSwgZGF0ZSAmIDB4MDAxRiwgKHRpbWUgJiAweEY4MDApID4+IDExLCAodGltZSAmIDB4MDdFMCkgPj4gNSxcblx0XHRcdFx0XHQodGltZSAmIDB4MDAxRikgKiAyLCAwKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVhZENvbW1vbkhlYWRlcihlbnRyeSwgZGF0YSwgaW5kZXgsIGNlbnRyYWxEaXJlY3RvcnksIG9uZXJyb3IpIHtcblx0XHRlbnRyeS52ZXJzaW9uID0gZGF0YS52aWV3LmdldFVpbnQxNihpbmRleCwgdHJ1ZSk7XG5cdFx0ZW50cnkuYml0RmxhZyA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyAyLCB0cnVlKTtcblx0XHRlbnRyeS5jb21wcmVzc2lvbk1ldGhvZCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyA0LCB0cnVlKTtcblx0XHRlbnRyeS5sYXN0TW9kRGF0ZVJhdyA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyA2LCB0cnVlKTtcblx0XHRlbnRyeS5sYXN0TW9kRGF0ZSA9IGdldERhdGUoZW50cnkubGFzdE1vZERhdGVSYXcpO1xuXHRcdGlmICgoZW50cnkuYml0RmxhZyAmIDB4MDEpID09PSAweDAxKSB7XG5cdFx0XHRvbmVycm9yKEVSUl9FTkNSWVBURUQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoY2VudHJhbERpcmVjdG9yeSB8fCAoZW50cnkuYml0RmxhZyAmIDB4MDAwOCkgIT0gMHgwMDA4KSB7XG5cdFx0XHRlbnRyeS5jcmMzMiA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyAxMCwgdHJ1ZSk7XG5cdFx0XHRlbnRyeS5jb21wcmVzc2VkU2l6ZSA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyAxNCwgdHJ1ZSk7XG5cdFx0XHRlbnRyeS51bmNvbXByZXNzZWRTaXplID0gZGF0YS52aWV3LmdldFVpbnQzMihpbmRleCArIDE4LCB0cnVlKTtcblx0XHR9XG5cdFx0aWYgKGVudHJ5LmNvbXByZXNzZWRTaXplID09PSAweEZGRkZGRkZGIHx8IGVudHJ5LnVuY29tcHJlc3NlZFNpemUgPT09IDB4RkZGRkZGRkYpIHtcblx0XHRcdG9uZXJyb3IoRVJSX1pJUDY0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZW50cnkuZmlsZW5hbWVMZW5ndGggPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMjIsIHRydWUpO1xuXHRcdGVudHJ5LmV4dHJhRmllbGRMZW5ndGggPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMjQsIHRydWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlWmlwUmVhZGVyKHJlYWRlciwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcblx0XHR2YXIgaW5mbGF0ZVNOID0gMDtcblxuXHRcdGZ1bmN0aW9uIEVudHJ5KCkge1xuXHRcdH1cblxuXHRcdEVudHJ5LnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24od3JpdGVyLCBvbmVuZCwgb25wcm9ncmVzcywgY2hlY2tDcmMzMikge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0XHRmdW5jdGlvbiB0ZXN0Q3JjMzIoY3JjMzIpIHtcblx0XHRcdFx0dmFyIGRhdGFDcmMzMiA9IGdldERhdGFIZWxwZXIoNCk7XG5cdFx0XHRcdGRhdGFDcmMzMi52aWV3LnNldFVpbnQzMigwLCBjcmMzMik7XG5cdFx0XHRcdHJldHVybiB0aGF0LmNyYzMyID09IGRhdGFDcmMzMi52aWV3LmdldFVpbnQzMigwKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0V3JpdGVyRGF0YSh1bmNvbXByZXNzZWRTaXplLCBjcmMzMikge1xuXHRcdFx0XHRpZiAoY2hlY2tDcmMzMiAmJiAhdGVzdENyYzMyKGNyYzMyKSlcblx0XHRcdFx0XHRvbmVycm9yKEVSUl9DUkMpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0d3JpdGVyLmdldERhdGEoZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdFx0b25lbmQoZGF0YSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9ucmVhZGVycm9yKGVycikge1xuXHRcdFx0XHRvbmVycm9yKGVyciB8fCBFUlJfUkVBRF9EQVRBKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb253cml0ZWVycm9yKGVycikge1xuXHRcdFx0XHRvbmVycm9yKGVyciB8fCBFUlJfV1JJVEVfREFUQSk7XG5cdFx0XHR9XG5cblx0XHRcdHJlYWRlci5yZWFkVWludDhBcnJheSh0aGF0Lm9mZnNldCwgMzAsIGZ1bmN0aW9uKGJ5dGVzKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gZ2V0RGF0YUhlbHBlcihieXRlcy5sZW5ndGgsIGJ5dGVzKSwgZGF0YU9mZnNldDtcblx0XHRcdFx0aWYgKGRhdGEudmlldy5nZXRVaW50MzIoMCkgIT0gMHg1MDRiMDMwNCkge1xuXHRcdFx0XHRcdG9uZXJyb3IoRVJSX0JBRF9GT1JNQVQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZWFkQ29tbW9uSGVhZGVyKHRoYXQsIGRhdGEsIDQsIGZhbHNlLCBvbmVycm9yKTtcblx0XHRcdFx0ZGF0YU9mZnNldCA9IHRoYXQub2Zmc2V0ICsgMzAgKyB0aGF0LmZpbGVuYW1lTGVuZ3RoICsgdGhhdC5leHRyYUZpZWxkTGVuZ3RoO1xuXHRcdFx0XHR3cml0ZXIuaW5pdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAodGhhdC5jb21wcmVzc2lvbk1ldGhvZCA9PT0gMClcblx0XHRcdFx0XHRcdGNvcHkodGhhdC5fd29ya2VyLCBpbmZsYXRlU04rKywgcmVhZGVyLCB3cml0ZXIsIGRhdGFPZmZzZXQsIHRoYXQuY29tcHJlc3NlZFNpemUsIGNoZWNrQ3JjMzIsIGdldFdyaXRlckRhdGEsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGluZmxhdGUodGhhdC5fd29ya2VyLCBpbmZsYXRlU04rKywgcmVhZGVyLCB3cml0ZXIsIGRhdGFPZmZzZXQsIHRoYXQuY29tcHJlc3NlZFNpemUsIGNoZWNrQ3JjMzIsIGdldFdyaXRlckRhdGEsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0fSwgb25yZWFkZXJyb3IpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBzZWVrRU9DRFIoZW9jZHJDYWxsYmFjaykge1xuXHRcdFx0Ly8gXCJFbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkXCIgaXMgdGhlIGxhc3QgcGFydCBvZiBhIHppcCBhcmNoaXZlLCBhbmQgaXMgYXQgbGVhc3QgMjIgYnl0ZXMgbG9uZy5cblx0XHRcdC8vIFppcCBmaWxlIGNvbW1lbnQgaXMgdGhlIGxhc3QgcGFydCBvZiBFT0NEUiBhbmQgaGFzIG1heCBsZW5ndGggb2YgNjRLQixcblx0XHRcdC8vIHNvIHdlIG9ubHkgaGF2ZSB0byBzZWFyY2ggdGhlIGxhc3QgNjRLICsgMjIgYnl0ZXMgb2YgYSBhcmNoaXZlIGZvciBFT0NEUiBzaWduYXR1cmUgKDB4MDYwNTRiNTApLlxuXHRcdFx0dmFyIEVPQ0RSX01JTiA9IDIyO1xuXHRcdFx0aWYgKHJlYWRlci5zaXplIDwgRU9DRFJfTUlOKSB7XG5cdFx0XHRcdG9uZXJyb3IoRVJSX0JBRF9GT1JNQVQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgWklQX0NPTU1FTlRfTUFYID0gMjU2ICogMjU2LCBFT0NEUl9NQVggPSBFT0NEUl9NSU4gKyBaSVBfQ09NTUVOVF9NQVg7XG5cblx0XHRcdC8vIEluIG1vc3QgY2FzZXMsIHRoZSBFT0NEUiBpcyBFT0NEUl9NSU4gYnl0ZXMgbG9uZ1xuXHRcdFx0ZG9TZWVrKEVPQ0RSX01JTiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIElmIG5vdCBmb3VuZCwgdHJ5IHdpdGhpbiBFT0NEUl9NQVggYnl0ZXNcblx0XHRcdFx0ZG9TZWVrKE1hdGgubWluKEVPQ0RSX01BWCwgcmVhZGVyLnNpemUpLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gc2VlayBsYXN0IGxlbmd0aCBieXRlcyBvZiBmaWxlIGZvciBFT0NEUlxuXHRcdFx0ZnVuY3Rpb24gZG9TZWVrKGxlbmd0aCwgZW9jZHJOb3RGb3VuZENhbGxiYWNrKSB7XG5cdFx0XHRcdHJlYWRlci5yZWFkVWludDhBcnJheShyZWFkZXIuc2l6ZSAtIGxlbmd0aCwgbGVuZ3RoLCBmdW5jdGlvbihieXRlcykge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSBieXRlcy5sZW5ndGggLSBFT0NEUl9NSU47IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRpZiAoYnl0ZXNbaV0gPT09IDB4NTAgJiYgYnl0ZXNbaSArIDFdID09PSAweDRiICYmIGJ5dGVzW2kgKyAyXSA9PT0gMHgwNSAmJiBieXRlc1tpICsgM10gPT09IDB4MDYpIHtcblx0XHRcdFx0XHRcdFx0ZW9jZHJDYWxsYmFjayhuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBpLCBFT0NEUl9NSU4pKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlb2Nkck5vdEZvdW5kQ2FsbGJhY2soKTtcblx0XHRcdFx0fSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0b25lcnJvcihFUlJfUkVBRCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciB6aXBSZWFkZXIgPSB7XG5cdFx0XHRnZXRFbnRyaWVzIDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHdvcmtlciA9IHRoaXMuX3dvcmtlcjtcblx0XHRcdFx0Ly8gbG9vayBmb3IgRW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZFxuXHRcdFx0XHRzZWVrRU9DRFIoZnVuY3Rpb24oZGF0YVZpZXcpIHtcblx0XHRcdFx0XHR2YXIgZGF0YWxlbmd0aCwgZmlsZXNsZW5ndGg7XG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQzMigxNiwgdHJ1ZSk7XG5cdFx0XHRcdFx0ZmlsZXNsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoOCwgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKGRhdGFsZW5ndGggPCAwIHx8IGRhdGFsZW5ndGggPj0gcmVhZGVyLnNpemUpIHtcblx0XHRcdFx0XHRcdG9uZXJyb3IoRVJSX0JBRF9GT1JNQVQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZWFkZXIucmVhZFVpbnQ4QXJyYXkoZGF0YWxlbmd0aCwgcmVhZGVyLnNpemUgLSBkYXRhbGVuZ3RoLCBmdW5jdGlvbihieXRlcykge1xuXHRcdFx0XHRcdFx0dmFyIGksIGluZGV4ID0gMCwgZW50cmllcyA9IFtdLCBlbnRyeSwgZmlsZW5hbWUsIGNvbW1lbnQsIGRhdGEgPSBnZXREYXRhSGVscGVyKGJ5dGVzLmxlbmd0aCwgYnl0ZXMpO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGZpbGVzbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0ZW50cnkgPSBuZXcgRW50cnkoKTtcblx0XHRcdFx0XHRcdFx0ZW50cnkuX3dvcmtlciA9IHdvcmtlcjtcblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXgpICE9IDB4NTA0YjAxMDIpIHtcblx0XHRcdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmVhZENvbW1vbkhlYWRlcihlbnRyeSwgZGF0YSwgaW5kZXggKyA2LCB0cnVlLCBvbmVycm9yKTtcblx0XHRcdFx0XHRcdFx0ZW50cnkuY29tbWVudExlbmd0aCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyAzMiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdGVudHJ5LmRpcmVjdG9yeSA9ICgoZGF0YS52aWV3LmdldFVpbnQ4KGluZGV4ICsgMzgpICYgMHgxMCkgPT0gMHgxMCk7XG5cdFx0XHRcdFx0XHRcdGVudHJ5Lm9mZnNldCA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyA0MiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdGZpbGVuYW1lID0gZ2V0U3RyaW5nKGRhdGEuYXJyYXkuc3ViYXJyYXkoaW5kZXggKyA0NiwgaW5kZXggKyA0NiArIGVudHJ5LmZpbGVuYW1lTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdGVudHJ5LmZpbGVuYW1lID0gKChlbnRyeS5iaXRGbGFnICYgMHgwODAwKSA9PT0gMHgwODAwKSA/IGRlY29kZVVURjgoZmlsZW5hbWUpIDogZGVjb2RlQVNDSUkoZmlsZW5hbWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIWVudHJ5LmRpcmVjdG9yeSAmJiBlbnRyeS5maWxlbmFtZS5jaGFyQXQoZW50cnkuZmlsZW5hbWUubGVuZ3RoIC0gMSkgPT0gXCIvXCIpXG5cdFx0XHRcdFx0XHRcdFx0ZW50cnkuZGlyZWN0b3J5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Y29tbWVudCA9IGdldFN0cmluZyhkYXRhLmFycmF5LnN1YmFycmF5KGluZGV4ICsgNDYgKyBlbnRyeS5maWxlbmFtZUxlbmd0aCArIGVudHJ5LmV4dHJhRmllbGRMZW5ndGgsIGluZGV4ICsgNDZcblx0XHRcdFx0XHRcdFx0XHRcdCsgZW50cnkuZmlsZW5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoICsgZW50cnkuY29tbWVudExlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRlbnRyeS5jb21tZW50ID0gKChlbnRyeS5iaXRGbGFnICYgMHgwODAwKSA9PT0gMHgwODAwKSA/IGRlY29kZVVURjgoY29tbWVudCkgOiBkZWNvZGVBU0NJSShjb21tZW50KTtcblx0XHRcdFx0XHRcdFx0ZW50cmllcy5wdXNoKGVudHJ5KTtcblx0XHRcdFx0XHRcdFx0aW5kZXggKz0gNDYgKyBlbnRyeS5maWxlbmFtZUxlbmd0aCArIGVudHJ5LmV4dHJhRmllbGRMZW5ndGggKyBlbnRyeS5jb21tZW50TGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZW50cmllcyk7XG5cdFx0XHRcdFx0fSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9SRUFEKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0Y2xvc2UgOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAodGhpcy5fd29ya2VyKSB7XG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xuXHRcdFx0XHRcdHRoaXMuX3dvcmtlciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNhbGxiYWNrKVxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9LFxuXHRcdFx0X3dvcmtlcjogbnVsbFxuXHRcdH07XG5cblx0XHRpZiAoIW9iai56aXAudXNlV2ViV29ya2Vycylcblx0XHRcdGNhbGxiYWNrKHppcFJlYWRlcik7XG5cdFx0ZWxzZSB7XG5cdFx0XHRjcmVhdGVXb3JrZXIoJ2luZmxhdGVyJyxcblx0XHRcdFx0ZnVuY3Rpb24od29ya2VyKSB7XG5cdFx0XHRcdFx0emlwUmVhZGVyLl93b3JrZXIgPSB3b3JrZXI7XG5cdFx0XHRcdFx0Y2FsbGJhY2soemlwUmVhZGVyKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0b25lcnJvcihlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFppcFdyaXRlclxuXG5cdGZ1bmN0aW9uIGVuY29kZVVURjgoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJ5dGVzKHN0cikge1xuXHRcdHZhciBpLCBhcnJheSA9IFtdO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG5cdFx0XHRhcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVaaXBXcml0ZXIod3JpdGVyLCBjYWxsYmFjaywgb25lcnJvciwgZG9udERlZmxhdGUpIHtcblx0XHR2YXIgZmlsZXMgPSB7fSwgZmlsZW5hbWVzID0gW10sIGRhdGFsZW5ndGggPSAwO1xuXHRcdHZhciBkZWZsYXRlU04gPSAwO1xuXG5cdFx0ZnVuY3Rpb24gb253cml0ZWVycm9yKGVycikge1xuXHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1dSSVRFKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbnJlYWRlcnJvcihlcnIpIHtcblx0XHRcdG9uZXJyb3IoZXJyIHx8IEVSUl9SRUFEX0RBVEEpO1xuXHRcdH1cblxuXHRcdHZhciB6aXBXcml0ZXIgPSB7XG5cdFx0XHRhZGQgOiBmdW5jdGlvbihuYW1lLCByZWFkZXIsIG9uZW5kLCBvbnByb2dyZXNzLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBoZWFkZXIsIGZpbGVuYW1lLCBkYXRlO1xuXHRcdFx0XHR2YXIgd29ya2VyID0gdGhpcy5fd29ya2VyO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHdyaXRlSGVhZGVyKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0dmFyIGRhdGE7XG5cdFx0XHRcdFx0ZGF0ZSA9IG9wdGlvbnMubGFzdE1vZERhdGUgfHwgbmV3IERhdGUoKTtcblx0XHRcdFx0XHRoZWFkZXIgPSBnZXREYXRhSGVscGVyKDI2KTtcblx0XHRcdFx0XHRmaWxlc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdGhlYWRlckFycmF5IDogaGVhZGVyLmFycmF5LFxuXHRcdFx0XHRcdFx0ZGlyZWN0b3J5IDogb3B0aW9ucy5kaXJlY3RvcnksXG5cdFx0XHRcdFx0XHRmaWxlbmFtZSA6IGZpbGVuYW1lLFxuXHRcdFx0XHRcdFx0b2Zmc2V0IDogZGF0YWxlbmd0aCxcblx0XHRcdFx0XHRcdGNvbW1lbnQgOiBnZXRCeXRlcyhlbmNvZGVVVEY4KG9wdGlvbnMuY29tbWVudCB8fCBcIlwiKSlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQzMigwLCAweDE0MDAwODA4KTtcblx0XHRcdFx0XHRpZiAob3B0aW9ucy52ZXJzaW9uKVxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDgoMCwgb3B0aW9ucy52ZXJzaW9uKTtcblx0XHRcdFx0XHRpZiAoIWRvbnREZWZsYXRlICYmIG9wdGlvbnMubGV2ZWwgIT09IDAgJiYgIW9wdGlvbnMuZGlyZWN0b3J5KVxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDQsIDB4MDgwMCk7XG5cdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDYsICgoKGRhdGUuZ2V0SG91cnMoKSA8PCA2KSB8IGRhdGUuZ2V0TWludXRlcygpKSA8PCA1KSB8IGRhdGUuZ2V0U2Vjb25kcygpIC8gMiwgdHJ1ZSk7XG5cdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDgsICgoKChkYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTgwKSA8PCA0KSB8IChkYXRlLmdldE1vbnRoKCkgKyAxKSkgPDwgNSkgfCBkYXRlLmdldERhdGUoKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDIyLCBmaWxlbmFtZS5sZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRcdGRhdGEgPSBnZXREYXRhSGVscGVyKDMwICsgZmlsZW5hbWUubGVuZ3RoKTtcblx0XHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKDAsIDB4NTA0YjAzMDQpO1xuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGhlYWRlci5hcnJheSwgNCk7XG5cdFx0XHRcdFx0ZGF0YS5hcnJheS5zZXQoZmlsZW5hbWUsIDMwKTtcblx0XHRcdFx0XHRkYXRhbGVuZ3RoICs9IGRhdGEuYXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YS5hcnJheSwgY2FsbGJhY2ssIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiB3cml0ZUZvb3Rlcihjb21wcmVzc2VkTGVuZ3RoLCBjcmMzMikge1xuXHRcdFx0XHRcdHZhciBmb290ZXIgPSBnZXREYXRhSGVscGVyKDE2KTtcblx0XHRcdFx0XHRkYXRhbGVuZ3RoICs9IGNvbXByZXNzZWRMZW5ndGggfHwgMDtcblx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoMCwgMHg1MDRiMDcwOCk7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjcmMzMiAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMTAsIGNyYzMyLCB0cnVlKTtcblx0XHRcdFx0XHRcdGZvb3Rlci52aWV3LnNldFVpbnQzMig0LCBjcmMzMiwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyZWFkZXIpIHtcblx0XHRcdFx0XHRcdGZvb3Rlci52aWV3LnNldFVpbnQzMig4LCBjb21wcmVzc2VkTGVuZ3RoLCB0cnVlKTtcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQzMigxNCwgY29tcHJlc3NlZExlbmd0aCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoMTIsIHJlYWRlci5zaXplLCB0cnVlKTtcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQzMigxOCwgcmVhZGVyLnNpemUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGZvb3Rlci5hcnJheSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRkYXRhbGVuZ3RoICs9IDE2O1xuXHRcdFx0XHRcdFx0b25lbmQoKTtcblx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gd3JpdGVGaWxlKCkge1xuXHRcdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnRyaW0oKTtcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5kaXJlY3RvcnkgJiYgbmFtZS5jaGFyQXQobmFtZS5sZW5ndGggLSAxKSAhPSBcIi9cIilcblx0XHRcdFx0XHRcdG5hbWUgKz0gXCIvXCI7XG5cdFx0XHRcdFx0aWYgKGZpbGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9EVVBMSUNBVEVEX05BTUUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmaWxlbmFtZSA9IGdldEJ5dGVzKGVuY29kZVVURjgobmFtZSkpO1xuXHRcdFx0XHRcdGZpbGVuYW1lcy5wdXNoKG5hbWUpO1xuXHRcdFx0XHRcdHdyaXRlSGVhZGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKHJlYWRlcilcblx0XHRcdFx0XHRcdFx0aWYgKGRvbnREZWZsYXRlIHx8IG9wdGlvbnMubGV2ZWwgPT09IDApXG5cdFx0XHRcdFx0XHRcdFx0Y29weSh3b3JrZXIsIGRlZmxhdGVTTisrLCByZWFkZXIsIHdyaXRlciwgMCwgcmVhZGVyLnNpemUsIHRydWUsIHdyaXRlRm9vdGVyLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGRlZmxhdGUod29ya2VyLCBkZWZsYXRlU04rKywgcmVhZGVyLCB3cml0ZXIsIG9wdGlvbnMubGV2ZWwsIHdyaXRlRm9vdGVyLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0d3JpdGVGb290ZXIoKTtcblx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJlYWRlcilcblx0XHRcdFx0XHRyZWFkZXIuaW5pdCh3cml0ZUZpbGUsIG9ucmVhZGVycm9yKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHdyaXRlRmlsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGNsb3NlIDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHRoaXMuX3dvcmtlcikge1xuXHRcdFx0XHRcdHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcblx0XHRcdFx0XHR0aGlzLl93b3JrZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGRhdGEsIGxlbmd0aCA9IDAsIGluZGV4ID0gMCwgaW5kZXhGaWxlbmFtZSwgZmlsZTtcblx0XHRcdFx0Zm9yIChpbmRleEZpbGVuYW1lID0gMDsgaW5kZXhGaWxlbmFtZSA8IGZpbGVuYW1lcy5sZW5ndGg7IGluZGV4RmlsZW5hbWUrKykge1xuXHRcdFx0XHRcdGZpbGUgPSBmaWxlc1tmaWxlbmFtZXNbaW5kZXhGaWxlbmFtZV1dO1xuXHRcdFx0XHRcdGxlbmd0aCArPSA0NiArIGZpbGUuZmlsZW5hbWUubGVuZ3RoICsgZmlsZS5jb21tZW50Lmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YUhlbHBlcihsZW5ndGggKyAyMik7XG5cdFx0XHRcdGZvciAoaW5kZXhGaWxlbmFtZSA9IDA7IGluZGV4RmlsZW5hbWUgPCBmaWxlbmFtZXMubGVuZ3RoOyBpbmRleEZpbGVuYW1lKyspIHtcblx0XHRcdFx0XHRmaWxlID0gZmlsZXNbZmlsZW5hbWVzW2luZGV4RmlsZW5hbWVdXTtcblx0XHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4LCAweDUwNGIwMTAyKTtcblx0XHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDE2KGluZGV4ICsgNCwgMHgxNDAwKTtcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmhlYWRlckFycmF5LCBpbmRleCArIDYpO1xuXHRcdFx0XHRcdGRhdGEudmlldy5zZXRVaW50MTYoaW5kZXggKyAzMiwgZmlsZS5jb21tZW50Lmxlbmd0aCwgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKGZpbGUuZGlyZWN0b3J5KVxuXHRcdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQ4KGluZGV4ICsgMzgsIDB4MTApO1xuXHRcdFx0XHRcdGRhdGEudmlldy5zZXRVaW50MzIoaW5kZXggKyA0MiwgZmlsZS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGZpbGUuZmlsZW5hbWUsIGluZGV4ICsgNDYpO1xuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGZpbGUuY29tbWVudCwgaW5kZXggKyA0NiArIGZpbGUuZmlsZW5hbWUubGVuZ3RoKTtcblx0XHRcdFx0XHRpbmRleCArPSA0NiArIGZpbGUuZmlsZW5hbWUubGVuZ3RoICsgZmlsZS5jb21tZW50Lmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4LCAweDUwNGIwNTA2KTtcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDgsIGZpbGVuYW1lcy5sZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDE2KGluZGV4ICsgMTAsIGZpbGVuYW1lcy5sZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4ICsgMTIsIGxlbmd0aCwgdHJ1ZSk7XG5cdFx0XHRcdGRhdGEudmlldy5zZXRVaW50MzIoaW5kZXggKyAxNiwgZGF0YWxlbmd0aCwgdHJ1ZSk7XG5cdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YS5hcnJheSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0d3JpdGVyLmdldERhdGEoY2FsbGJhY2spO1xuXHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0fSxcblx0XHRcdF93b3JrZXI6IG51bGxcblx0XHR9O1xuXG5cdFx0aWYgKCFvYmouemlwLnVzZVdlYldvcmtlcnMpXG5cdFx0XHRjYWxsYmFjayh6aXBXcml0ZXIpO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y3JlYXRlV29ya2VyKCdkZWZsYXRlcicsXG5cdFx0XHRcdGZ1bmN0aW9uKHdvcmtlcikge1xuXHRcdFx0XHRcdHppcFdyaXRlci5fd29ya2VyID0gd29ya2VyO1xuXHRcdFx0XHRcdGNhbGxiYWNrKHppcFdyaXRlcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdG9uZXJyb3IoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlVVJMcyh1cmxzKSB7XG5cdFx0dmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0cmV0dXJuIHVybHMubWFwKGZ1bmN0aW9uKHVybCkge1xuXHRcdFx0YS5ocmVmID0gdXJsO1xuXHRcdFx0cmV0dXJuIGEuaHJlZjtcblx0XHR9KTtcblx0fVxuXG5cdHZhciBERUZBVUxUX1dPUktFUl9TQ1JJUFRTID0ge1xuXHRcdGRlZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2RlZmxhdGUuanMnXSxcblx0XHRpbmZsYXRlcjogWyd6LXdvcmtlci5qcycsICdpbmZsYXRlLmpzJ11cblx0fTtcblx0ZnVuY3Rpb24gY3JlYXRlV29ya2VyKHR5cGUsIGNhbGxiYWNrLCBvbmVycm9yKSB7XG5cdFx0aWYgKG9iai56aXAud29ya2VyU2NyaXB0cyAhPT0gbnVsbCAmJiBvYmouemlwLndvcmtlclNjcmlwdHNQYXRoICE9PSBudWxsKSB7XG5cdFx0XHRvbmVycm9yKG5ldyBFcnJvcignRWl0aGVyIHppcC53b3JrZXJTY3JpcHRzIG9yIHppcC53b3JrZXJTY3JpcHRzUGF0aCBtYXkgYmUgc2V0LCBub3QgYm90aC4nKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBzY3JpcHRzO1xuXHRcdGlmIChvYmouemlwLndvcmtlclNjcmlwdHMpIHtcblx0XHRcdHNjcmlwdHMgPSBvYmouemlwLndvcmtlclNjcmlwdHNbdHlwZV07XG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkoc2NyaXB0cykpIHtcblx0XHRcdFx0b25lcnJvcihuZXcgRXJyb3IoJ3ppcC53b3JrZXJTY3JpcHRzLicgKyB0eXBlICsgJyBpcyBub3QgYW4gYXJyYXkhJykpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzY3JpcHRzID0gcmVzb2x2ZVVSTHMoc2NyaXB0cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNjcmlwdHMgPSBERUZBVUxUX1dPUktFUl9TQ1JJUFRTW3R5cGVdLnNsaWNlKDApO1xuXHRcdFx0c2NyaXB0c1swXSA9IChvYmouemlwLndvcmtlclNjcmlwdHNQYXRoIHx8ICcnKSArIHNjcmlwdHNbMF07XG5cdFx0fVxuXHRcdHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHNjcmlwdHNbMF0pO1xuXHRcdC8vIHJlY29yZCB0b3RhbCBjb25zdW1lZCB0aW1lIGJ5IGluZmxhdGVyL2RlZmxhdGVyL2NyYzMyIGluIHRoaXMgd29ya2VyXG5cdFx0d29ya2VyLmNvZGVjVGltZSA9IHdvcmtlci5jcmNUaW1lID0gMDtcblx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiAnaW1wb3J0U2NyaXB0cycsIHNjcmlwdHM6IHNjcmlwdHMuc2xpY2UoMSkgfSk7XG5cdFx0d29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UpO1xuXHRcdGZ1bmN0aW9uIG9ubWVzc2FnZShldikge1xuXHRcdFx0dmFyIG1zZyA9IGV2LmRhdGE7XG5cdFx0XHRpZiAobXNnLmVycm9yKSB7XG5cdFx0XHRcdHdvcmtlci50ZXJtaW5hdGUoKTsgLy8gc2hvdWxkIGJlZm9yZSBvbmVycm9yKCksIGJlY2F1c2Ugb25lcnJvcigpIG1heSB0aHJvdy5cblx0XHRcdFx0b25lcnJvcihtc2cuZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAobXNnLnR5cGUgPT09ICdpbXBvcnRTY3JpcHRzJykge1xuXHRcdFx0XHR3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSk7XG5cdFx0XHRcdHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG5cdFx0XHRcdGNhbGxiYWNrKHdvcmtlcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGNhdGNoIGVudHJ5IHNjcmlwdCBsb2FkaW5nIGVycm9yIGFuZCBvdGhlciB1bmhhbmRsZWQgZXJyb3JzXG5cdFx0d29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcblx0XHRmdW5jdGlvbiBlcnJvckhhbmRsZXIoZXJyKSB7XG5cdFx0XHR3b3JrZXIudGVybWluYXRlKCk7XG5cdFx0XHRvbmVycm9yKGVycik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25lcnJvcl9kZWZhdWx0KGVycm9yKSB7XG5cdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdH1cblx0b2JqLnppcCA9IHtcblx0XHRSZWFkZXIgOiBSZWFkZXIsXG5cdFx0V3JpdGVyIDogV3JpdGVyLFxuXHRcdEJsb2JSZWFkZXIgOiBCbG9iUmVhZGVyLFxuXHRcdERhdGE2NFVSSVJlYWRlciA6IERhdGE2NFVSSVJlYWRlcixcblx0XHRUZXh0UmVhZGVyIDogVGV4dFJlYWRlcixcblx0XHRCbG9iV3JpdGVyIDogQmxvYldyaXRlcixcblx0XHREYXRhNjRVUklXcml0ZXIgOiBEYXRhNjRVUklXcml0ZXIsXG5cdFx0VGV4dFdyaXRlciA6IFRleHRXcml0ZXIsXG5cdFx0Y3JlYXRlUmVhZGVyIDogZnVuY3Rpb24ocmVhZGVyLCBjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdFx0b25lcnJvciA9IG9uZXJyb3IgfHwgb25lcnJvcl9kZWZhdWx0O1xuXG5cdFx0XHRyZWFkZXIuaW5pdChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3JlYXRlWmlwUmVhZGVyKHJlYWRlciwgY2FsbGJhY2ssIG9uZXJyb3IpO1xuXHRcdFx0fSwgb25lcnJvcik7XG5cdFx0fSxcblx0XHRjcmVhdGVXcml0ZXIgOiBmdW5jdGlvbih3cml0ZXIsIGNhbGxiYWNrLCBvbmVycm9yLCBkb250RGVmbGF0ZSkge1xuXHRcdFx0b25lcnJvciA9IG9uZXJyb3IgfHwgb25lcnJvcl9kZWZhdWx0O1xuXHRcdFx0ZG9udERlZmxhdGUgPSAhIWRvbnREZWZsYXRlO1xuXG5cdFx0XHR3cml0ZXIuaW5pdChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3JlYXRlWmlwV3JpdGVyKHdyaXRlciwgY2FsbGJhY2ssIG9uZXJyb3IsIGRvbnREZWZsYXRlKTtcblx0XHRcdH0sIG9uZXJyb3IpO1xuXHRcdH0sXG5cdFx0dXNlV2ViV29ya2VycyA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogRGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIGRlZmF1bHQgd29ya2VyIHNjcmlwdHMgKHotd29ya2VyLmpzLCBkZWZsYXRlLmpzLCBhbmQgaW5mbGF0ZS5qcyksIHJlbGF0aXZlIHRvIGN1cnJlbnQgYmFzZSB1cmwuXG5cdFx0ICogRS5nLjogemlwLndvcmtlclNjcmlwdHMgPSAnLi8nO1xuXHRcdCAqL1xuXHRcdHdvcmtlclNjcmlwdHNQYXRoIDogbnVsbCxcblx0XHQvKipcblx0XHQgKiBBZHZhbmNlZCBvcHRpb24gdG8gY29udHJvbCB3aGljaCBzY3JpcHRzIGFyZSBsb2FkZWQgaW4gdGhlIFdlYiB3b3JrZXIuIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlbiB3b3JrZXJTY3JpcHRzUGF0aCBtdXN0IG5vdCBiZSBzZXQuXG5cdFx0ICogd29ya2VyU2NyaXB0cy5kZWZsYXRlci93b3JrZXJTY3JpcHRzLmluZmxhdGVyIHNob3VsZCBiZSBhcnJheXMgb2YgdXJscyB0byBzY3JpcHRzIGZvciBkZWZsYXRlci9pbmZsYXRlciwgcmVzcGVjdGl2ZWx5LlxuXHRcdCAqIFNjcmlwdHMgaW4gdGhlIGFycmF5IGFyZSBleGVjdXRlZCBpbiBvcmRlciwgYW5kIHRoZSBmaXJzdCBvbmUgc2hvdWxkIGJlIHotd29ya2VyLmpzLCB3aGljaCBpcyB1c2VkIHRvIHN0YXJ0IHRoZSB3b3JrZXIuXG5cdFx0ICogQWxsIHVybHMgYXJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgYmFzZSB1cmwuXG5cdFx0ICogRS5nLjpcblx0XHQgKiB6aXAud29ya2VyU2NyaXB0cyA9IHtcblx0XHQgKiAgIGRlZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2RlZmxhdGUuanMnXSxcblx0XHQgKiAgIGluZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2luZmxhdGUuanMnXVxuXHRcdCAqIH07XG5cdFx0ICovXG5cdFx0d29ya2VyU2NyaXB0cyA6IG51bGwsXG5cdH07XG5cbn0pKHRoaXMpO1xuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiB6aXAgIT0gXCJ1bmRlZmluZWRcIiA/IHppcCA6IHdpbmRvdy56aXApO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG4iXX0=
